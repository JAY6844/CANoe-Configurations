/*@@var:*/
/*
 * CAPL Helper Include for TP DLL - reference implementation for
 * AUTOSAR TP on FlexRay (AutosarFlexRayTP3.dll)
 * Version 1.1, (c) Vector Informatik GmbH, 2012
 *
 * This CAPL include module can be included into ECU implementations to provide
 * access to the AUTOSAR transport protocol on FlexRay.
 *
 * For usage with the diagnostics layer of CANoe in order to forward events generated by
 * the TP protocol to the diagnostics layer and vice versa please use the
 * "CAPL Callback Interface for Diagnostics" include file instead!!!
 *
 * Users do NOT have to change anything in this file!
 */
 variables {

  enum TPConnMode { eUnicast = 1, eAck_Unicast = 2, eAck_Retry_Unicast = 3, eMulticast = 10, eSegmented_Multicast = 11 };
  enum TPLengthMode { eISO = 1, eISO6 = 2, eL16M = 3, eL4G = 4 };
  enum TPOnOff { eOff = 0, eOn = 1 };
  enum TPASRVersion { eASR_2_0 = 0, eASR_3_1 = 2, eASR_3_2_2 = 4, eUsedVersion = 2 };

  struct ASRTPParameter {

    enum TPASRVersion   mProtocolVersion;     // [IN]
    enum TPConnMode     mConnectionModeTx;    // [IN]
    enum TPConnMode     mConnectionModeRx;    // [IN]
    enum TPLengthMode   mLengthModeTx;        // [IN]
    enum TPLengthMode   mLengthModeRx;        // [IN]
    int                 mAddrType;            // [IN] one (1) or two (2) byte addresses
    word                mLocalAddr;           // [IN]
    word                mRemoteAddr;          // [IN]
    enum TPOnOff        mPadding;             // [IN]
    byte                mFillByte;            // [IN]
    dword               mMaxTxPrioPDUs;       // [IN]
    long                mTxPriority;          // [IN]
    enum TPOnOff        mExclusiveTxUsage;    // [IN]
    enum TPOnOff        mAbortRxOnNewTxStart; // [IN]
    dword               mBlockSize;           // [IN]
    dword               mStMin;               // [IN]
    dword               mMaxPDULength;        // [IN]

    dword               mTimeoutAs;           // [IN]
    dword               mTimeoutAr;           // [IN]
    dword               mTimeoutBs;           // [IN]
    dword               mTimeBr;              // [IN]
    dword               mTimeCs;              // [IN]
    dword               mTimeoutCr;           // [IN]

    long                mConnectionHandle;    // [IN/OUT]
  };

  const int cPDUNameLength = 20;
  const int kTxSize = 16384; // maximum Bytes per local data buffer

  // Default TP timing parameters are defined as constants here:
  const int gkTimeoutAS = 400;
  const int gkTimeoutAR = 400;
  const int gkTimeoutBS = 500;
  const int gkTimeoutCR = 500;
  const int gkTimeBR    = 0;
  const int gkTimeCS    = 0;

  const long cDefaultTxPriority = 32768;

  char gECU[250] = ""; // name of the ECU from the database
  char gTPPrefix[512]; // used during debug outputs

  int gFRTPChannel = 1; // simulation channel in CANoe

  long gDLLVersionValues[3];
  int  gDLLVersionOK = 0;
}
/*@@end*/

/*@@caplFunc:SetTPPrefixString(long):*///function
SetTPPrefixString (long handle)
{
  snprintf(gTPPrefix, elcount(gTPPrefix), "[%.6f %s] (0x%X) ", timeNowNS()/1000000000.0, gECU, handle);
}
/*@@end*/

/*@@caplFunc:SetTPTimingParams(long,int,int,int,int,int,int,int):*///function
SetTPTimingParams (long handle, int TimeoutAS, int TimeoutAR, int TimeoutBS, int TimeBR, int TimeCS, int TimeoutCR, int verbosityLevel)
{
  FrTP_SetTimingParams (handle, TimeoutAS, TimeoutAR, TimeoutBS, TimeBR, TimeCS, TimeoutCR);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    write("%sTimings set to: ToAS=%d, ToAR=%d, ToBS=%d, tBR=%d, tCS=%d, ToCR=%d.", gTPPrefix, TimeoutAS, TimeoutAR, TimeoutBS, TimeBR, TimeCS, TimeoutCR);
  }
}
/*@@end*/

/*@@caplFunc:SetTPConnectionModeTX(long,byte,int):*///function
SetTPConnectionModeTX(long handle, byte connectionMode, int verbosityLevel)
{
  switch (connectionMode)
  {
    case 1 : 
    {
      FRTP_SetConnMode(handle, 1, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX connection mode Unicast", gTPPrefix); 
      }
      break;
    }
    case 2 : 
    {
      FRTP_SetConnMode(handle, 2, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX connection mode AckUnicast", gTPPrefix); 
      }
      break;
    }
    case 3 : 
    {
      FRTP_SetConnMode(handle, 3, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX connection mode AckRetryUnicast", gTPPrefix); 
      }
      break;
    }
    case 10 : 
    {
      FRTP_SetConnMode(handle, 10, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX connection mode Multicast", gTPPrefix); 
      }
      break;
    }
    case 11 : 
    {
      FRTP_SetConnMode(handle, 11, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX connection mode SegmentedMulticast", gTPPrefix); 
      }
      break;
    }
    default: 
    {
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sError: unknown TX connection mode %d", gTPPrefix, connectionMode);
      }
      break;
    }
  }
}
/*@@end*/

/*@@caplFunc:SetTPAddresses(long,byte,dword,dword,int):*///function
SetTPAddresses (long handle, byte addrType, dword localAddr, dword remoteAddr, int verbosityLevel)
{
  dword addrMask;

  addrMask = 0xFFFF;
  if (addrType <= 1) addrMask = 0xFF;
  localAddr  = localAddr & addrMask;
  remoteAddr = remoteAddr & addrMask;

  FrTP_SetAddresses (handle, addrType, localAddr, remoteAddr);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    if (addrType == 1)
      write("%sAddresses set: 1 Byte addressing: Local Address: %d, Remote Address: %d.", gTPPrefix, localAddr, remoteAddr); 
    else if (addrType == 2)
      write("%sAddresses set: 2 Byte addressing: Local Address: %d, Remote Address: %d.", gTPPrefix, localAddr, remoteAddr); 
    else
      write("%sAddresses set: unknown addressing: Local Address: %d, Remote Address: %d.", gTPPrefix, localAddr, remoteAddr); 
  }
}
/*@@end*/

/*@@caplFunc:SetTPBlockSize(long,dword,int):*///function
SetTPBlockSize (long handle, dword blockSize, int verbosityLevel)
{
  FrTP_SetBlockSize (handle, blockSize);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    write("%sBlock size set: %d.", gTPPrefix, blockSize); 
  }
}
/*@@end*/

/*@@caplFunc:SetTPMaxPduLength(long,word,int):*///function
SetTPMaxPduLength (long handle, word maxPDULength, int verbosityLevel)
{
  FrTP_SetMaxPDULength (handle, maxPDULength);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    write("%sMax PDU length set: %u.", gTPPrefix, maxPDULength); 
  }
}
/*@@end*/

/*@@caplFunc:SetTPPadding(long,int,byte,int):*///function
SetTPPadding (long handle, int paddingActive, byte fillByte, int verbosityLevel)
{
  if (paddingActive == 1)
  {
    FrTP_SetFillByte(handle, fillByte);
    if (verbosityLevel > 1)
    {
      SetTPPrefixString(handle);
      write("%sFillbyte set: 0x%02lX, padding: YES", gTPPrefix, fillByte); 
    }
  }
  else
  {
    FrTP_SetFillByte(handle, (fillByte | 0x80000000));
    if (verbosityLevel > 1)
    {
      SetTPPrefixString(handle);
      write("%sFillbyte set: 0x%02lX, padding: NO", gTPPrefix, fillByte); 
    }
  }
}
/*@@end*/

/*@@caplFunc:SetTPExpertMode(long,int,int):*///function
SetTPExpertMode (long handle, int expertMode, int verbosityLevel)
{
  int useTxRq = 0;
  FRConfiguration frParameter;

  FRGetConfiguration(gFRTPChannel, frParameter);
  if ((frParameter.pCCVersion == 2 /* BusDoctor */) || (frParameter.pCCVersion == 3 /* FlexCard Cyclone (I) */))
  {
    useTxRq = 1;
    SetTPPrefixString(handle);
    write("%sATTENTION: Assure that you have activated the TxRq events from the bus interface on FlexRay channel %d.", gTPPrefix, gFRTPChannel); 
  }
  else
  {
    useTxRq = 0;
  }

  if (useTxRq)
  {
    FrTP_SetExpertParam (handle, 100, 1);
    if (verbosityLevel > 1)
    {
      SetTPPrefixString(handle);
      write("%sUsing TxRq instead of Tx events from interface.", gTPPrefix); 
    }
  }
  else
  {
    FrTP_SetExpertParam (handle, 100, 0);
    if (verbosityLevel > 1)
    {
      SetTPPrefixString(handle);
      write("%sUsing Tx instead of TxRq events from interface.", gTPPrefix); 
    }
  }

  if (expertMode)
  {
    SetTPPrefixString(handle);
    write("%sExpert Mode %d not supported!", gTPPrefix, expertMode); 
  }

  if (FrTP_GetDLLInfo(3) >= 43)
  {
    // Allowing the slot sharing if build version is >= 43:
    if (verbosityLevel > 1)
    {
      SetTPPrefixString(handle);
      write("%sAllowing C-PDU sharing between connections.", gTPPrefix); 
    }
  }
  else
  {
    SetTPPrefixString(handle);
    write("%sSharing of C-PDUs between connections is not supported!", gTPPrefix); 
  }
}
/*@@end*/

/*@@caplFunc:SetTPSTmin(long,dword,int):*///function
SetTPSTmin (long handle, DWORD STmin, int verbosityLevel)
{
  FrTP_SetSTminUs(handle, STmin);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    write("%Set STmin = %d", gTPPrefix, STmin);
  }
}
/*@@end*/

/*@@caplFunc:InitTP(int):*///function
InitTP (int channel)
{
  gFRTPChannel = channel;
  FrTP_GetNodeName(gECU, elcount(gECU));

  gDLLVersionValues[0] = FrTP_GetDLLInfo(1);
  gDLLVersionValues[1] = FrTP_GetDLLInfo(2);
  gDLLVersionValues[2] = FrTP_GetDLLInfo(3);

  gDLLVersionOK = -1;
  if (gDLLVersionValues[0] < 3) 
  {
    write( "%s: ERROR: Major version of AUTOSAR TP DLL = %d, but expected >= 3!", gECU, gDLLVersionValues[0]);
    return;
  }
  if ((gDLLVersionValues[0] == 3) && (gDLLVersionValues[1] < 10)) 
  {
    write( "%s: ERROR: Minor version of AUTOSAR TP DLL = %d, but expected >= 10!", gECU, gDLLVersionValues[1]);
    return;
  }
  if ((gDLLVersionValues[0] == 3) && (gDLLVersionValues[1] == 10) && (gDLLVersionValues[2] < 63)) 
  {
    write( "%s: ERROR: Patch version of AUTOSAR TP DLL = %d, but expected >= 63!", gECU, gDLLVersionValues[2]);
    return;
  }
  writeDbgLevel( 1, "%s: found AUTOSAR TP DLL version %d.%d.%d ", gECU, gDLLVersionValues[0], gDLLVersionValues[1], gDLLVersionValues[2]);
  gDLLVersionOK = 1;
}
/*@@end*/

/*@@caplFunc:SetTPLengthModeTX(long,byte,int):*///function
SetTPLengthModeTX(long handle, byte lengthMode, int verbosityLevel)
{
  switch (lengthMode)
  {
    case 1 : 
    {
      FRTP_SetLengthMode(handle, 1, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX length mode FRTP_ISO", gTPPrefix);
      }
      break;
    }
    case 2 : 
    {
      FRTP_SetLengthMode(handle, 2, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX length mode FRTP_ISO6", gTPPrefix); 
      }
      break;
    }
    case 3 : 
    {
      FRTP_SetLengthMode(handle, 3, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX length mode FRTP_L16M", gTPPrefix); 
      }
      break;
    }
    case 4 : 
    {
      FRTP_SetLengthMode(handle, 4, 0); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet TX length mode FRTP_4G", gTPPrefix); 
      }
      break;
    }
    default: 
    {
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sError: Unknown TX length mode %d!", gTPPrefix, lengthMode); 
      }
      break;
    }
  }
}
/*@@end*/

/*@@caplFunc:SetTPTxPriority(long,long,int):*///function
SetTPTxPriority (long handle, long priority, int verbosityLevel)
{
  FrTP_SetTXPriority (handle, priority);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    write("%sTX priority set: %d.", gTPPrefix, priority); 
  }
}
/*@@end*/

/*@@caplFunc:SetTPExclusiveTxUsage(long,int,int):*///function
SetTPExclusiveTxUsage (long handle, int enable, int verbosityLevel)
{
  FrTP_SetExclusiveTXSlotUsage (handle, enable > 0 ? 1 : 0, 0x0001);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    if (enable > 0)
      write("%sExclusive TX usage is on", gTPPrefix); 
    else
      write("%sExclusive TX usage is off", gTPPrefix); 
  }
}
/*@@end*/

/*@@caplFunc:SetTPAbortRxOnNewTxStart(long,int,int):*///function
SetTPAbortRxOnNewTxStart (long handle, int enable, int verbosityLevel)
{
  int lSwitchValue;
  if (enable > 0) lSwitchValue = 1; else lSwitchValue = 0;
  FrTP_SetAbortReceptionOnNewStart (handle, lSwitchValue, lSwitchValue);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    if (enable > 0)
      write("%sAbort RX on new TX start is on", gTPPrefix); 
    else
      write("%sAbort RX on new TX start is off", gTPPrefix); 
  }
}
/*@@end*/

/*@@caplFunc:SetTPConnectionModeRX(long,byte,int):*///function
SetTPConnectionModeRX(long handle, byte connectionMode, int verbosityLevel)
{
  switch (connectionMode)
  {
    case 1 : 
    {
      FRTP_SetConnMode(handle, 0, 1); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX connection mode Unicast", gTPPrefix); 
      }
      break;
    }
    case 2 : 
    {
      FRTP_SetConnMode(handle, 0, 2); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX connection mode AckUnicast", gTPPrefix); 
      }
      break;
    }
    case 3 : 
    {
      FRTP_SetConnMode(handle, 0, 3); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX connection mode AckRetryUnicast", gTPPrefix); 
      }
      break;
    }
    case 10 : 
    {
      FRTP_SetConnMode(handle, 0, 10); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX connection mode Multicast", gTPPrefix); 
      }
      break;
    }
    case 11 : 
    {
      FRTP_SetConnMode(handle, 0, 11); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX connection mode SegmentedMulticast", gTPPrefix); 
      }
      break;
    }
    default: 
    {
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sError: unknown RX connection mode %d", gTPPrefix, connectionMode);
      }
      break;
    }
  }
}
/*@@end*/

/*@@caplFunc:SetTPLengthModeRX(long,byte,int):*///function
SetTPLengthModeRX(long handle, byte lengthMode, int verbosityLevel)
{
  switch (lengthMode)
  {
    case 1 : 
    {
      FRTP_SetLengthMode(handle, 0, 1); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX length mode FRTP_ISO", gTPPrefix);
      }
      break;
    }
    case 2 : 
    {
      FRTP_SetLengthMode(handle, 0, 2); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX length mode FRTP_ISO6", gTPPrefix); 
      }
      break;
    }
    case 3 : 
    {
      FRTP_SetLengthMode(handle, 0, 3); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX length mode FRTP_L16M", gTPPrefix); 
      }
      break;
    }
    case 4 : 
    {
      FRTP_SetLengthMode(handle, 0, 4); 
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sSet RX length mode FRTP_4G", gTPPrefix); 
      }
      break;
    }
    default: 
    {
      if (verbosityLevel > 1)
      {
        SetTPPrefixString(handle);
        write("%sError: Unknown RX length mode %d!", gTPPrefix, lengthMode); 
      }
      break;
    }
  }
}
/*@@end*/

/*@@caplFunc:SetTPMaxTXPrioPDUs(long,dword,int):*///function
SetTPMaxTXPrioPDUs (long handle, dword num, int verbosityLevel)
{
  FrTP_SetTXMaxPrioPDUs(handle, num);
  if (verbosityLevel > 1)
  {
    SetTPPrefixString(handle);
    write("%sSet maximum number of TX priority PDUs: %d.", gTPPrefix, num); 
  }
}
/*@@end*/

/*@@caplFunc:CreateTPConnection(int,char[][],int,char[][],int,ASRTPParameter,int):*///function
long CreateTPConnection (int numTxPDUs, char aTxPDUPool[][], int numRxPDUs, char aRxPDUPool[][], int aPDUNameLen, struct ASRTPParameter params, int verbosityLevel)
{
  if (gDLLVersionOK <= 0)
  {
    write("%s: ERROR: Cannot create connection due to wrong AUTOSAR TP DLL version %d.%d.%d ", gECU, gDLLVersionValues[0], gDLLVersionValues[1], gDLLVersionValues[2]);
    return 0;
  }

  if (params.mConnectionHandle != 0)
  { // destroy old connection:
    FrTP_DeleteConn(params.mConnectionHandle);
    params.mConnectionHandle = 0;
  }

  // Create connection using the TX PDU pool:
  //params.mConnectionHandle = FrTP_CreatePDUConnUnicast(aTxPDUPool, aPDUNameLen, numTxPDUs);

  // Create connection:
  params.mConnectionHandle = FrTP_CreateConnUnicast( 0x0000, "", "");

  if (params.mProtocolVersion == eASR_3_2_2)
  {
    // AUTOSAR 3.2.2 (AUDI extensions included) (3.2.2 - x.y.z)
    FrTP_SetProtocolVersion(params.mConnectionHandle, 3, 2, 2);
  }
  else if (params.mProtocolVersion == eASR_2_0)
  {
    // AUTOSAR 2.x (2.0.x - 2.1.13)
    FrTP_SetProtocolVersion(params.mConnectionHandle, 2, 0, 0);
  }
  else
  {
    // AUTOSAR 3.x (2.1.14 - 3.2.1)
    FrTP_SetProtocolVersion(params.mConnectionHandle, 3, 1, 0);
  }

  // Add the TX PDU pool:
  AddTP_TX_PDU_Pool( params.mConnectionHandle, 0x0002, numTxPDUs, aTxPDUPool, aPDUNameLen, verbosityLevel);

  // Add the RX PDU pool:
  AddTP_RX_PDU_Pool( params.mConnectionHandle, 0x0002, numRxPDUs, aRxPDUPool, aPDUNameLen, verbosityLevel);

  if (verbosityLevel > 1)
  {
    SetTPPrefixString(params.mConnectionHandle);
    write("%sCreated connection handle is: 0x%X", gTPPrefix, params.mConnectionHandle);
  }

  SetTPExpertMode(params.mConnectionHandle, 0, verbosityLevel);

  // Set TP parameters for connection:
  SetTPConnectionModeTX(params.mConnectionHandle, params.mConnectionModeTx, verbosityLevel);
  SetTPConnectionModeRX(params.mConnectionHandle, params.mConnectionModeRx, verbosityLevel);
  SetTPLengthModeTX(params.mConnectionHandle, params.mLengthModeTx, verbosityLevel);
  SetTPLengthModeRX(params.mConnectionHandle, params.mLengthModeRx, verbosityLevel);
  SetTPTimingParams(params.mConnectionHandle, params.mTimeoutAs, params.mTimeoutAr, params.mTimeoutBs, params.mTimeBr, params.mTimeCs, params.mTimeoutCr, verbosityLevel);
  SetTPAddresses(params.mConnectionHandle, params.mAddrType, params.mLocalAddr, params.mRemoteAddr, verbosityLevel);
  SetTPBlockSize(params.mConnectionHandle, params.mBlockSize, verbosityLevel);
  SetTPSTmin(params.mConnectionHandle, params.mStMin, verbosityLevel);
  SetTPPadding(params.mConnectionHandle, params.mPadding, params.mFillByte, verbosityLevel);
  SetTPMaxPduLength(params.mConnectionHandle, params.mMaxPDULength, verbosityLevel);

  SetTPTxPriority(params.mConnectionHandle, params.mTxPriority, verbosityLevel);
  SetTPExclusiveTxUsage(params.mConnectionHandle, params.mExclusiveTxUsage, verbosityLevel);
  SetTPAbortRxOnNewTxStart(params.mConnectionHandle, params.mAbortRxOnNewTxStart, verbosityLevel);
  if (params.mProtocolVersion == eASR_3_2_2)
  {
    SetTPMaxTXPrioPDUs(params.mConnectionHandle, params.mMaxTxPrioPDUs, verbosityLevel);
  }

  SetTPParamsDone(params.mConnectionHandle, verbosityLevel);

  return params.mConnectionHandle;
}
/*@@end*/

/*@@caplFunc:AddTP_RX_PDU_Pool(long,dword,int,char[][],int,int):*///function
void AddTP_RX_PDU_Pool (long handle, dword ctrlFlags, int numRxPDUs, char aRxPDUPool[][], int aPDUNameLen, int verbosityLevel)
{
  int i;
  dword flags;

  for (i = 0; (i < numRxPDUs); i++)
  {
    flags = 0;
    if (i == 0) flags |= (ctrlFlags & 0x0002); // before adding first PDU possibly remove all default RX PDUs
    FrTP_AddConnReceiveSlot(handle, flags, aRxPDUPool[i]);
  }
}
/*@@end*/

/*@@caplFunc:AddTP_TX_PDU_Pool(long,dword,int,char[][],int,int):*///function
void AddTP_TX_PDU_Pool (long handle, dword ctrlFlags, int numTxPDUs, char aTxPDUPool[][], int aPDUNameLen, int verbosityLevel)
{
  int i;
  dword flags;

  for (i = 0; (i < numTxPDUs); i++)
  {
    flags = 0;
    if (i == 0) flags |= (ctrlFlags & 0x0002); // before adding first PDU possibly remove all default TX PDUs
    FrTP_AddConnSendSlot(handle, flags, aTxPDUPool[i]);
  }
}
/*@@end*/

/*@@caplFunc:SetTPParamsDone(long,int):*///function
SetTPParamsDone (long handle, int verbosityLevel)
{
  FrTP_SetConfigurationDone(handle, 1);
}
/*@@end*/

