/*@!Encoding:1252*/
/***************************************************************************************
 * Demo- and Example-Programs
 *
 * Please note: The demo and example programs only show special aspects of the software.
 * With regard to the fact that these programs are meant for demonstration purposes only,
 * Vector Informatik's liability shall be expressly excluded in cases of ordinary
 * negligence, to the extent admissible by law or statute.
 *
 * Beta-Version
 *
 * These programs are fully operative programs. However, they are not thoroughly tested
 * yet (beta-version). With regard to the fact that the programs are a beta-version only,
 * Vector Informatik's liability shall be expressly excluded in cases of ordinary
 * negligence, to the extent admissible by law or statute.
 *
 * DESCRIPTION:
 *
 * Demo test implementation of the 'OPEN Alliance Automotive Ethernet ECU Test
 * Specification - TC8 ECU Test' (Document Version 2.0, August 23, 2017)
 *
 * Copyright (c) Vector Informatik GmbH. All rights reserved.
 ***************************************************************************************/

includes
{
  #include "..\ShareableFolders\CaplLibrary\Tc8TestLib\BasicFunctionsTestLib.cin"
  #include "..\ShareableFolders\CaplLibrary\StubFunctionLib\Ipv4StubFunctions.cin"
  #include "..\ShareableFolders\CaplLibrary\StubFunctionLib\IcmpStubFunctions.cin"
  #include "..\ShareableFolders\CaplLibrary\StubFunctionLib\TcpStubFunctions.cin"
}

variables
{
  byte gLastReceivedPackageHeader[1024];
  byte gLastReceivedPackagePayload[20];
  long gLastReceivedPackageHeaderLength; 
  long gExpectedMessageOnCongestion = 0;
  byte gDutMss[2];
  long gAmountOfCollectedData;
  
  //The following arrays manage the state of a socket
  dword gSequenceNumber[10];
  dword gSkippedSequenceNumber[10];
  dword gAcknowledgement[10];
  dword gPreviousAcknowledgement[10];
  enum TcpStateId gSocketState[10];
  word gSocketPort[10]; //port of dut
  word gConnectedPort[10]; //port of tester
  char gConnectedIP[10][64];
  enum TcpFlag gLastSentFlag[10];
  dword seqTesterArray[10], ackTesterArray[10];
  
  dword gPreparedAck; // Used to acknowledge only until a given segment.
  word gLastReceivedWindow = 0xffff;
  qword gTimeStampSendSyn, gRoundTripTime;
  dword gUnacceptableNumber = 0;
  long rto, ackTester, seqTester, ackDut, seqDut;  
  qword gTimeStampReceivedTcp; // milliseconds
  enum Bool gMessageArrived = kFalse; // despite being named MessagedArrived, this variable is only set to true when the expected number of packets arrive.
  const int kMaximumTcpSegments = 131;
  
  enum Bool gClosingSocket; // when this is true, every received TCP message is answered with RST

  long gLastReceivedLength;
  dword gPreviousSequenceNumber[10];
  
  word gVariableDutPort; // If DUT builds up a connection and chooses its own port, this port will be stored here
  word gVariableTesterPort; // This port will be generated at each testcase
  
  long gTimeDiffBetweenSynAnSynAckMilliseconds;
  
  qword gLastSentTestabilityMicroseconds;

}

on sysvar TSO::SeqNumberCorrection
{
  if(@this != 0)
    gAcknowledgement[0] += @this;
  @this = 0;
}

on sysvar TSO::AckNumberCorrection
{
  if(@this != 0)
    gSequenceNumber[0] += @this;
  @this = 0;
}

/**
 * This function should be called in the preparation of the test fixture
 */
export InitTestFixture()
{
  Internal_InitTestFixture(kTcp, "OnEthPacketTcp");  
}

/**
 * This function should be called in the completion of the test fixture
 */
export EndTestFixture()
{
  Internal_EndTestFixture();
}

/**
 * Function to start a TCP test case.
 */
export InitTestCase(char testCaseName[], int testCaseNumber, enum Bool testabilityProtocolUsed)
{
  int i; 
  
  // initialize the socket Id for each test case
  for (i = 0; i < elcount(gSocketId); i++)
  {
    gSocketId[i] = -1;
    gSequenceNumber[i] = timeNow();
    gAcknowledgement[i] = 0;
    gSocketPort[i] = 0;
    gSocketState[i] = TcpStateIdInvalid;
    gConnectedPort[i] = 0;
    strncpy(gConnectedIP[i], "0.0", elcount("0.0"));
  }
  gClosingSocket = kFalse;
  gVariableDutPort = 0;
  gVariableTesterPort = GenerateTesterPort();
  Internal_InitTestCase(testCaseName, kTcp, "TCP", testCaseNumber, testabilityProtocolUsed);
}

/**
 * Function to end a TCP test case. 
 */
export testfunction EndTestCase()
{
  Internal_EndTestCase();
}

/**
 * This function is called when an ethernet packet is received.
 * If it is sent from the DuT (checked via ShouldIncomingPacketBeProcessed),
 * and observing of packets is active, the incoming packet will
 * be processed
 */
void OnEthPacketTcp(long channel, long dir, long packetHandle)
{
  enum Bool match;
  long flags, lengTcp;
  word socketPort, connectedPort;
  word socketHandle;
  int i;
  
  if(IsUdpMessage(packetHandle) && dir == 1)
  {
    if(EthGetTokenInt64(packetHandle, "udp", "destination") == syspar::TestabilityServicesUdpPort )
      {
        gLastSentTestabilityMicroseconds = EthGetThisTimeNS() / 1000;
        write ("Received testability timestamp: %i", gLastReceivedTestabilityReply);
      }
  }
  
  if (ShouldIncomingPacketBeProcessed(channel, dir, packetHandle) == kFalse)
  {
    return;
  }

  if(AnswerArpRequestForHost1(packetHandle) == kTrue)
  {
    return;
  }  
  if(AnswerNdpSolicitation(packetHandle) == kTrue)
  {
    return;
  }
  else if(IsTcpMessage(packetHandle))
  {
    // Get timestamps of transmitted messages
    if (dir == 1)
    {
      gTimestampLastSend = EthGetThisTimeNS() / 1000;
      write("gTimestampLastSend=%lld", gTimestampLastSend);
      
      flags = EthGetTokenInt64(packetHandle, "tcp", "flags");
      if(EthGetTokenInt64(packetHandle, "ipv4", "source") == ConvertIpAddressStringToInt64(syspar::Host1Ip) &&
         flags == TcpFlagSyn)
      {
        gTimeStampSendSyn = gTimestampLastSend;
      }
    }
  }
  else if(IsUdpMessage(packetHandle))
  {
    // Get Timestamp of received Testability message
    if (dir == 0)
    {      
      byte destAddr[20];
      byte testabilityDest[20];
      int version;
      version =  ConvertIpAddressStringToByteArray(syspar::TestabilityServicesIpAddress, testabilityDest);
      if(version == 4)
      {
        EthGetTokenData(packetHandle, "ipv4", "destination", elcount(destAddr), destAddr);
      }
      else
      {
        EthGetTokenData(packetHandle, "ipv6", "destination", elcount(destAddr), destAddr);
      }
      memcmp(destAddr, testabilityDest, BytesPerIpVersion(version));
      if(memcmp(destAddr, testabilityDest, BytesPerIpVersion(version)) == 0 &&
         EthGetTokenInt64(packetHandle, "udp", "destination") == syspar::TestabilityServicesUdpPort )
      {
        gLastReceivedTestabilityReply = EthGetThisTimeNS() / 1000;
        write ("Received testability timestamp: %i", gLastReceivedTestabilityReply);
      }
    }
  }
  
  match = CompareParameters(packetHandle, channel, gReportOnFailure);
  
  if (match == kTrue)
  {
    if(gClosingSocket)
    {
      AnswerTcpMessageByReset(packetHandle);
      return;
    }
    if(IsTcpMessage(packetHandle))
    {
      byte tmpData[2];
      //get socketHandle by getting the source and destination port and comparing it to the ports in the array
      socketPort = EthGetTokenInt64(packetHandle, "tcp", "source");
      connectedPort = EthGetTokenInt64(packetHandle, "tcp", "destination");
      write("####################################################################");
      write("# Try get socket handle                                            #");
      write("####################################################################");
      for (i=0; i<10; i++)
      {
        write("socketPort = %d, gSocketPort[%d] = %d, connectedPort = %d, gConnectedPort[%d] = %d", socketPort, i, gSocketPort[i], connectedPort, i, gConnectedPort[i]);
        if (connectedPort == gConnectedPort[i])
        {
          if(gSocketPort[i] == 0xFFFF || socketPort == gSocketPort[i])
          {
           socketHandle = i;
           break;
          }
        }
      }
      write("####################################################################");
      
      EthGetTokenData(packetHandle, "tcp", "option2.data", elcount(gDutMss), gDutMss);
      gPreviousAcknowledgement[socketHandle] = gAcknowledgement[socketHandle];
      gAcknowledgement[socketHandle] = EthGetTokenInt64(packetHandle, "tcp", "sequence");
      gPreviousSequenceNumber [socketHandle] = EthGetTokenInt64(packetHandle, "tcp", "ackNumber");
      gLastReceivedLength = EthGetTokenLengthBit(packetHandle, "tcp", "data") / 8;
      flags = EthGetTokenInt64(packetHandle, "tcp", "flags");
      if((flags & (long)TcpFlagSyn) > 0 || (flags & (long)TcpFlagFin) > 0)
      {
        gAcknowledgement[socketHandle] += 1;
      }
      gLastReceivedWindow = EthGetTokenInt64(packetHandle, "tcp", "window");
      lengTcp = EthGetTokenLengthBit(packetHandle, "tcp", "data")/8;
      gAcknowledgement[socketHandle] += lengTcp;

      gTimeStampReceivedTcp = (EthGetThisTimeNS() / 1000000);
      write("gTimeStampReceivedTcp   = %lld", gTimeStampReceivedTcp);

      // Calculate Round Trip Time
      if(flags == TcpFlagSynAck)
      {
        gRoundTripTime = (EthGetThisTimeNS() / 1000) - gTimeStampSendSyn;
        write("gTimeStampSendSyn   = %lld", gTimeStampSendSyn);
        write("EthGetThisTimeNS = %lld", EthGetThisTimeNS() / 1000);
        write("gRoundTripTime   = %lld", gRoundTripTime);
      }
    }
    
    //Extract IP header and first 8 bytes of payload
    //This will be needed for constructing ICMP messages,
    //where these data shall be attached to the message
    gLastReceivedPackageHeaderLength = EthGetTokenData(packetHandle, "ipv4", "header", elcount(gLastReceivedPackageHeader), gLastReceivedPackageHeader);
    
    EthGetTokenData(packetHandle, "ipv4", "data", 8, gLastReceivedPackagePayload);
    
    EthernetPacketReceived(channel);
  }
}

/**
 * Checks whether an ethernet packet is a TCP message
 * @returns kTrue if packet is a TCP message, kFalse otherwise
 */
enum Bool IsTcpMessage(long packetHandle)
{
  if(EthGetTokenInt64(packetHandle, "eth", "type") == 0x800)
  {
    if(EthGetTokenInt64(packetHandle, "ipv4", "protocol") == 0x06)
    {
      return kTrue;
    }
  }
  else if(EthGetTokenInt64(packetHandle, "eth", "type") == 0x86DD)
  {
    if(EthGetTokenInt64(packetHandle, "ipv6", "next") == 0x06)
    {
      return kTrue;
    }
  }
  return kFalse;
}

/**
 * Checks whether an ethernet packet is a ICMP message
 * @returns kTrue if packet is a TCP message, kFalse otherwise
 */
enum Bool IsIcmpMessage(long packetHandle)
{
  if(EthGetTokenInt64(packetHandle, "eth", "type") != 0x800)
  {
    return kFalse;
  }
  if(EthGetTokenInt64(packetHandle, "ipv4", "protocol") != 0x01)
  {
    return kFalse;
  }
  return kTrue;
}

/**
 * Checks whether an ethernet packet is a UDP message
 * @returns kTrue if packet is a TCP message, kFalse otherwise
 */
enum Bool IsUdpMessage(long packetHandle)
{
  if(EthGetTokenInt64(packetHandle, "eth", "type") != 0x800)
  {
    return kFalse;
  }
  if(EthGetTokenInt64(packetHandle, "ipv4", "protocol") != 0x11)
  {
    return kFalse;
  }
  return kTrue;
}

/**
 * Sends a TCP RST message to back to the DUT. Port, sequence number and acknowledge number will be constructed from an incoming message
 * @param packetHandle The packet handle of the incoming message
 */
void AnswerTcpMessageByReset(long packetHandle)
{
  char srcPort[7], destPort[7];
  dword sequenceNumber, acknowledgeNumber;
  byte flags;
  long payloadSize, result;
  
  write("Answer tcp message by reset");
  snprintf(srcPort, elcount(srcPort), "%lld", EthGetTokenInt64(packetHandle, "tcp", "destination"));
  snprintf(destPort, elcount(srcPort), "%lld", EthGetTokenInt64(packetHandle, "tcp", "source"));
  
  sequenceNumber = EthGetTokenInt64(packetHandle, "tcp", "sequence");
  result = EthGetLastError();
  if(result != 0) write("Error @ EthGetTokenInt64 tcp sequence %d", result);
  acknowledgeNumber = EthGetTokenInt64(packetHandle, "tcp", "ackNumber");
  result = EthGetLastError();
  if(result != 0) write("Error @ EthGetTokenInt64 tcp ackNumber %d", result);
  write("sequenceNumber = %X, acknowledgeNumber = %X", sequenceNumber, acknowledgeNumber);

  flags = EthGetTokenInt64(packetHandle, "tcp", "flags");
  if((flags & (long)TcpFlagSyn) > 0 || (flags & (long)TcpFlagFin) > 0)
  {
    acknowledgeNumber++;
  }
  payloadSize = EthGetTokenLengthBit(packetHandle, "tcp", "data")/8;
  acknowledgeNumber += payloadSize;
  
  InternalSendTCPMessage(syspar::Wildcard,
    syspar::Host1Ip,
    syspar::DIface0Ip,
    srcPort,
    destPort,
    acknowledgeNumber,
    sequenceNumber,
    TcpFlagRstAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    0,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Randomly generates a port the is used by the tester
 * IANA recommends using the range from 49152-65535 (https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml)
 * @returns the generated port
 */
word GenerateTesterPort()
{
  const word kMinPort = 49152;
  const word kMaxPort = 65535;
  return random(kMaxPort - kMinPort) + kMinPort;
}


/**
 * Sends a TCP Urg message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendUrgMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendUrgMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagUrg,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Urg message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendUrgAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendUrgAckMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagUrgAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Syn and Rst message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendSynRstMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  int seqNumOffset
  )
{
  write("Entering testfunction SendSynRstMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0] + seqNumOffset,
    gAcknowledgement[0],
    TcpFlagSynRst,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Syn,Ack along with Rst flag message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendSynAckWithRstMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendSynAckWithRstMessage");
  gSequenceNumber[0] -= 1;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagSynAckRst,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn,Ack message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendSynAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendSynAckMessage");
  gSequenceNumber[0] -= 1;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagSynAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

export testfunction SendSynAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char window[],
  char optionsNumber[],
  char mss[]
  )
{
  write("Entering testfunction SendSynAckMessage");
  gSequenceNumber[0] -= 1;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagSynAck,
    window,
    syspar::Wildcard,
    syspar::Wildcard,
    optionsNumber,
    kCompleteMessage,
    "",
    strlen(""),
    mss,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn,Ack message. This function is useful when several sockets are used.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param socketHandle The number of the socket to match the packet.
 */
export testfunction SendSynAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  word socketHandle
  )
{
  write("Entering testfunction SendSynAckMessage");
  gSequenceNumber[socketHandle] -= 1;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[socketHandle],
    gAcknowledgement[socketHandle],
    TcpFlagSynAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[socketHandle] += 1;
}

/**
 * Sends a TCP Syn,Ack message with a defined acknowledge Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param ackNumber The TCP acknowledge number.
 */
export testfunction SendSynAckMessageWithAckNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword ackNumber
  )
{
  write("Entering testfunction SendSynAckMessageWithAckNumber");
  gSequenceNumber[0] -=1 ;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    ackNumber,
    TcpFlagSynAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn,Ack message with a unacceptable acknowledge Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendSynAckMessageWithUnacceptableAckNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendSynAckMessageWithUnacceptableAckNumber");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gAcknowledgement[0], gLastReceivedWindow);
  gSequenceNumber[0] -= 1;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gUnacceptableNumber,
    TcpFlagSynAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Ack message with a unacceptable acknowledge Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param ackNumber The TCP acknowledge number.
 */
export testfunction SendAckMessageWithUnacceptableAckNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendAckMessageWithUnacceptableAckNumber");
  gSequenceNumber[0] -= 1;
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gAcknowledgement[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gUnacceptableNumber,
    TcpFlagSynAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn message with options.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param optionsNumber Select the options required for a specific testcase.
 */
export testfunction SendSynMessageWithOptions(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[], 
  char optionsNumber[]
  )
{
  write("Entering testfunction SendSynMessageWithOptions");
  gAcknowledgement[0] = 0;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagSyn,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    optionsNumber,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn message with options and a specific length
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param mssLen The maximum Segment Size of the Maximum Segment Size Option.
 */
export testfunction SendSynMessageWithOptionsAndLength(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[], 
  char optionsNumber[],
  char mssLen []
  )
{
  write("Entering testfunction SendSynMessageWithOptionsAndLength");
  gAcknowledgement[0] = 0;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagSyn,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    optionsNumber,
    kCompleteMessage,
    "",
    strlen(""),
    mssLen,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn message with options and a specific length
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param mssLen The maximum Segment Size of the Maximum Segment Size Option.
 */
export testfunction SendSynMessageWithOptionsAndLength(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[], 
  char optionsNumber[],
  int mssLen
  )
{
  char mssLenStr[6];
  
  write("Entering testfunction SendSynMessageWithOptionsAndLength");
  snprintf(mssLenStr, elcount(mssLenStr), "%d", mssLen);
  gAcknowledgement[0] = 0;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagSyn,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    optionsNumber,
    kCompleteMessage,
    "",
    strlen(""),
    mssLenStr,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn,Ack message with options.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param mssLen The maximum Segment Size of the Maximum Segment Size Option.
 */
export SendSynAckMessageWithOptions(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[], 
  char optionsNumber[],
  dword mssLen
  )
{
  char mssLenString[10];
  
  snprintf(mssLenString, elcount(mssLenString), "%d", mssLen);
  SendSynAckMessageWithOptions(
    srcIpAddress,
    destIpAddress, 
    srcPort,
    destPort,
    optionsNumber,
    mssLenString
  );
}
/**
 * Sends a TCP Syn,Ack message with options.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param mssLen The maximum Segment Size of the Maximum Segment Size Option.
 */
export SendSynAckMessageWithOptions(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[], 
  char optionsNumber[],
  char mssLen[]
  )
{
  write("Entering testfunction SendSynAckMessageWithOptions");
  gSequenceNumber[0] -= 1;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagSynAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    optionsNumber,
    kCompleteMessage,
    "",
    strlen(""),
    mssLen,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendSynMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendSynMessage");
  gAcknowledgement[0] = 0;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagSyn,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Syn message with a defined Sequence Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param sequenceNumber The TCP sequence number
 */
export testfunction SendSynMessageWithSeqNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword sequenceNumber
  )
{
  write("Entering testfunction SendSynMessageWithSeqNumber");
  gAcknowledgement[0] = 0;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    sequenceNumber,
    gAcknowledgement[0],
    TcpFlagSyn,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Syn message with a defined Sequence Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param sequenceNumber The TCP sequence number
 */
export testfunction SendSynMessageWithSeqNumberOffset(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword sequenceNumberOffset
  )
{
  write("Entering testfunction SendSynMessageWithSeqNumberOffset");
  gAcknowledgement[0] = 0;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0] + sequenceNumberOffset,
    gAcknowledgement[0],
    TcpFlagSyn,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Ack message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendAckMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends the last ACK message for 3 times.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendThreeLastAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  int i =1;
  
  write("Entering testfunction SendThreeLastAckMessage");
  while(i<4)
  {  
   InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    seqTester,
    ackTester,
    TcpFlagAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
    );
    i++;
  }  
}

/**
 * Sends several TCP Ack messages.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param windowValue The window value to match the packet.
 * @param numberOfSegments The number of segments to be sent.
 */
export testfunction SendSeveralAckWithWindow(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char windowValue[],
  long numberOfSegments
  )
{
  int i = 0;
  
  write("Entering testfunction SendSeveralAckWithWindow");
  while(i<numberOfSegments)
  {
   InternalSendTCPMessage(syspar::Wildcard, srcIpAddress, destIpAddress, srcPort, destPort, gSequenceNumber[0], gAcknowledgement[0],    
                          TcpFlagAck, windowValue, syspar::Wildcard, syspar::Wildcard, syspar::Wildcard, kCompleteMessage,
                          "", strlen(""), syspar::Wildcard, syspar::Wildcard, syspar::Wildcard);
   testWaitForTimeout(100);
   i++;
  }
}

/**
 * Sends several TCP Ack messages for all the received Tcp messages
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendAckForAllSegmentsReceived(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  int i=1;
  
  write("Entering testfunction SendAckForAllSegmentsReceived");
  while(i<10)
  {
     InternalSendTCPMessage(
      syspar::Wildcard,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      seqTesterArray[i],
      ackTesterArray[i],
      TcpFlagAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      "",
      strlen(""),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
     );
    i++;
    testWaitForTimeout(100);
  }
}

/**
 * Sends a TCP Ack message With Sequence Number Less One
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendAckMessageWithSequenceNumberLessOne(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendAckMessageWithSequenceNumberLessOne");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0] - 1,
    gAcknowledgement[0],
    TcpFlagAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Ack message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param windowSize The window size for a TCP segment.
 */
export testfunction SendPreparedAckMessageWithWindowSize(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword windowSize
  )
{ 
  char windowStr[10];
  snprintf(windowStr, elcount(windowStr), "%d", windowSize);
  
  write("Entering testfunction SendPreparedAckMessageWithWindowSize");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gPreparedAck,
    TcpFlagAck,
    windowStr,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}
/**
 * Sends a TCP Ack message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param windowSize The window size for a TCP segment.
 * @param ackOffset Offset of acknumber, if neccessary (e.g. datalength = 0)
 */
export testfunction SendAckMessageWithWindowSize(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char windowSize[],
  dword ackOffset
  )
{
  write("Entering testfunction SendAckMessageWithWindowSize");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0]-ackOffset,
    TcpFlagAck,
    windowSize,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}
/**
 * Sends a TCP Ack message with options and a specific length
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param mssLen The maximum Segment Size of the Maximum Segment Size Option.
 */
export testfunction SendAckMessageWithOptionsAndLength(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[], 
  char optionsNumber[],
  char mssLen []
  )
{
  write("Entering testfunction SendAckMessageWithOptionsAndLength");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    optionsNumber,
    kCompleteMessage,
    "",
    strlen(""),
    mssLen,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Fin message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendFinMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendFinMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagFin,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Fin,Ack message without increasing sequence number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction RetransmitFinAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction RetransmitFinAckMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0]-1,
    gAcknowledgement[0],
    TcpFlagFinAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Fin,Ack message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param ackOffset The (negative) Offset for acknumber on sending
 * @param seqOffset The offset for seqNumber if necessary (in Time-Wait state e.g.)
 */
export testfunction SendFinAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword ackOffset,
  dword seqOffset
  )
{
  write("Entering testfunction SendFinAckMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0]-ackOffset,
    TcpFlagFinAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] = gSequenceNumber[0] + 1 - seqOffset;
}

/**
 * Sends a TCP Fin,Ack message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendFinAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendFinAckMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagFinAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Fin,Ack message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param ackOffSet The (negative) Offset for acknumber on sending 
 */
export testfunction SendFinAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword ackOffSet
  )
{
  write("Entering testfunction SendFinAckMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0]-ackOffSet,
    TcpFlagFinAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += 1;
}

/**
 * Sends a TCP Rst,Ack message wit unacceptable acknowledgement number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendRstAckMessageWithUnacceptableAck(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendRstAckMessageWithUnacceptableAck");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gAcknowledgement[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gUnacceptableNumber,
    TcpFlagRstAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Rst,Ack message wit unacceptable sequence number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendDataMessageWithUnacceptableSeq(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[]
  )
{
   write("Entering testfunction SendDataMessageWithUnacceptableSeq");
   gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gSequenceNumber[0], gLastReceivedWindow);
   InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gUnacceptableNumber,
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Fin message wit unacceptable sequence number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendFinMessageWithUnacceptableSeq(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{  
  write("Entering testfunction SendFinMessageWithUnacceptableSeq");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gSequenceNumber[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gUnacceptableNumber,
    gAcknowledgement[0],
    TcpFlagFin,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Ack message wit unacceptable sequence number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendAckMessageWithUnacceptableSeq(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendAckMessageWithUnacceptableSeq");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gSequenceNumber[0], gLastReceivedWindow);
   InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gUnacceptableNumber,
    gAcknowledgement[0],
    TcpFlagAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Syn,Ack message wit unacceptable sequence number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendSynAckMessageWithUnacceptableSeq(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendSynAckMessageWithUnacceptableSeq");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gSequenceNumber[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gUnacceptableNumber,
    gAcknowledgement[0],
    TcpFlagSynAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Syn message wit unacceptable sequence number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendSynMessageWithUnacceptableSeq(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{ 
  write("Entering testfunction SendSynMessageWithUnacceptableSeq");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gSequenceNumber[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gUnacceptableNumber,
    gAcknowledgement[0],
    TcpFlagSyn,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Rst message wit unacceptable sequence number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendRstMessageWithUnacceptableSeq(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{ 
  write("Entering testfunction SendRstMessageWithUnacceptableSeq");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gSequenceNumber[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gUnacceptableNumber,
    gAcknowledgement[0],
    TcpFlagRst,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Rst,Ack message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendRstAckMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendRstAckMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagRstAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Rst message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendRstMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendRstMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagRst,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP Rst message with greater sequence number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendRstMessageWithGreaterSeqNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendRstMessageWithGreaterSeqNumber");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0] + gLastReceivedWindow + 2,
    gAcknowledgement[0],
    TcpFlagRst,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP segment message with unacceptable Ack number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendTcpAckWithUnacceptableAckNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction SendTcpAckWithUnacceptableAckNumber");
  gAcknowledgement[0] = CalculateUnacceptableSeqAckNumber(gAcknowledgement[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    "",
    strlen(""),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a full sized TCP segment message
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export testfunction SendFullSizedTcpSegment(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  dword i;
  char data[0x10000];
  data[0] = '\0';
  
  write("Entering testfunction SendFullSizedTcpSegment");
  for(i = 0; i < _min(atol(syspar::MSS), _min(1460, gLastReceivedWindow)); i++)
  {
    strncat(data, "s", 0x10000);
  }
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += strlen(data);
}

/**
 * Sends a TCP data segment
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param sendingType Set the sending typ of TCP message (e.g. invaild checksum).
 * @param data The TCP payload.
 */
export testfunction SendDataMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum SendingType sendingType,
  char data[]
  )
{
  write("Entering testfunction SendDataMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    sendingType,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
    gSequenceNumber[0] += elCount(data)-1;
}

/**
 * Sends a TCP window probe
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param sendingType Set the sending typ of TCP message (e.g. invaild checksum).
 * @param data The TCP payload.
 */
export testfunction SendWindowProbe(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum SendingType sendingType,
  char data[]
  )
{
  char OneByteData[2];
  
  write("Entering testfunction SendWindowProbe");
  strncpy(OneByteData, data, 2);
  
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    sendingType,
    OneByteData,
    strlen(OneByteData),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  // Do not increase sequence number !
}

/**
 * Sends a TCP data segment
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 * @param AckOffset The Ack offset
 */
export testfunction SendDataMessageWithNegAckOffSet(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  dword AckOffset
  )
{
  write("Entering testfunction SendDataMessage");
  gAcknowledgement[0] = gAcknowledgement[0] - AckOffset;
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += elCount(data)-1; // 
}

/**
 * Sends a TCP data segment
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[]
  )
{
  write("Entering testfunction SendDataMessage");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += elCount(data)-1; // 
}

/**
 * Sends a TCP data segment until DUT sends ACK message with window 0.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageUntilReceivedAck(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[]
  )
{
  write("Entering testfunction SendDataMessageUntilReceivedAck");
  PrepareWaitForEthernet(syspar::Host1Mac, syspar::DIface0MacAddr);
  PrepareWaitForIp(destIpAddress, srcIpAddress, 0x06);           /* TCP Protocol Type */
  PrepareWaitForTcp(destPort, srcPort);
  
  InternalAddExpectedParameter("tcp", "flags", TcpFlagAck);
  
  StartObservationOfIncomingPackets(kAnswerExpected);
  
  while(1)
  {
    InternalSendTCPMessage(
      syspar::Wildcard,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagPshAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      data,
      strlen(data),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
  );
  gSequenceNumber[0] += elCount(data)-1; 
  
  if(gReceivedMessagesPerChannel[1] == 1)
    break;
  
  testWaitForTimeout(100);
  }
  
}


/**
 * Sends a TCP data segment
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param dataLength The length of TCP payload.
 */
export testfunction SendDataMessage(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  word dataLength
  )
{
write("Entering testfunction SendDataMessage");
InternalSendTCPMessage(
      syspar::Wildcard,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagPshAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      "1",
      dataLength,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
    );
  gSequenceNumber[0] += dataLength;
}

/**
 * Sends a TCP data segment with Tcp flag.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param flags TCP flags to indicate the Control bit.
 * @param dataLength The length of TCP payload.
 */
export testfunction SendDataSegmentWithFlag(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  word dataLength
  )
{
write("Entering testfunction SendDataMessageWithFlag");
InternalSendTCPMessage(
      syspar::Wildcard,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      flags,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      "1",
      dataLength,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
    );
  gSequenceNumber[0] += dataLength;
}

/**
 * Sends a TCP data segment with a TCP flag 
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param flags TCP flags to indicate the Control bit.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageWithFlag(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[]
  )
{
  write("Entering testfunction SendDataMessageWithFlag");
  
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    flags,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += elCount(data)-1;
}

/**
 * Sends a TCP Ack message with options and a specific length
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param optionsNumber Select the options required for a specific testcase.
 */
export testfunction SendDataMessageWithOptions(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[], 
  char optionsNumber[],
  char mssLen [],
  char data[]
  )
{
  write("Entering testfunction SendDataMessageWithOptions");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    optionsNumber,
    kCompleteMessage,
    data,
    strlen(data),
    mssLen,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += elCount(data)-1; // 
}

/**
 * Sends a TCP data with several segments
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param numberOfSegments The number of segments which will be send.
 * @param data The TCP payload.
 */
export testfunction SendDataWithSeveralSegments(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  long numberOfSegments,
  char data[]
  )
{
  int i;
  char dataBuffer[100];
  
  write("Entering testfunction SendDataWithSeveralSegments");
  dataBuffer[0] = '\0';
  for(i = 0; i<numberOfSegments; i++)
  {
    strncat(dataBuffer, data, elCount(dataBuffer));
  }
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    dataBuffer,
    (elCount(data) - 1) * numberOfSegments,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
    );
  
  gSequenceNumber[0] += (elCount(data) - 1) * numberOfSegments; 
}

/**
 * Sends a TCP data with several segments with a gap in sequence numbers at the beginning
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param numberOfSegments The number of segments which will be send.
 * @param data The TCP payload.
 * @param dataLength The length of each Data segment.
 */
export testfunction SendSeveralDataSegmentsWithGapSeq(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  long numberOfSegments,
  char data[],
  char dataLength[]
  )
{
  int i;
  
  write("Entering testfunction SendSeveralDataSegmentsWithGapSeq");
  InternalSendTCPMessage(
        syspar::Wildcard,
        srcIpAddress,
        destIpAddress,
        srcPort,
        destPort,
        gSequenceNumber[0], 
        gAcknowledgement[0],
        TcpFlagPshAck,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        kCompleteMessage,
        data,
        atol(dataLength),
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard
        );
  
  gSequenceNumber[0] += (elCount(data) - 1); 
  
  // Gap in the sequece numbers
  gSkippedSequenceNumber[0] = gSequenceNumber[0];
  gSequenceNumber[0] += (elCount(data) - 1);
  
  for(i = 1; i<numberOfSegments; i++)
  {

     InternalSendTCPMessage(
      syspar::Wildcard,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagPshAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      data,
      atol(dataLength),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
      );
    gSequenceNumber[0] += (elCount(data) - 1);
  }
  
  
  
}

/**
 * Sends a TCP data with several segments with the missing sequence numbers
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param numberOfSegments The number of segments which will be send.
 * @param data The TCP payload.
 * @param dataLength The length of each Data segment.
 */
export testfunction SendMissingSeqs(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  char dataLength[]
  )
{
  write("Entering testfunction SendMissingSeqs");
  InternalSendTCPMessage(
        syspar::Wildcard,
        srcIpAddress,
        destIpAddress,
        srcPort,
        destPort,
        gSkippedSequenceNumber[0], 
        gAcknowledgement[0],
        TcpFlagPshAck,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        kCompleteMessage,
        data,
        atol(dataLength),
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard
        );
  
  //gSequenceNumber[0] = gSkippedSequenceNumber[0] + (elCount(data) - 1);
  
}

/**
 * Sends a TCP data with several segments
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */
export SendDataToFillDutWindow(
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  int i;
  i = 0;
  
  
  while(gLastReceivedWindow > atol(syspar::MSS))
  {
    write("gLastReceivedWindow = %d syspar::MSS = %s", gLastReceivedWindow, syspar::MSS);
    SendDataMessage
    (
      localIpAddress,
      dutIpAddress,
      localPort,
      dutPort,
      atol(syspar::MSS)
    );
    
    WaitForTcpAck
    (
      syspar::ParamListenTimeMs,
      dutIpAddress,
      localIpAddress,
      dutPort,
      localPort,
      kEquals
    );
    
    i++;
    
    if(i > 130)
      break;
  } 
  
   SendDataMessage
    (
      localIpAddress,
      dutIpAddress,
      localPort,
      dutPort,
      gLastReceivedWindow
    );
    
    WaitForTcpAck
    (
      syspar::ParamListenTimeMs,
      dutIpAddress,
      localIpAddress,
      dutPort,
      localPort,
      kEquals
    );
}

/**
 * Sends a TCP data with several segments to fill the DUTs window and verify that
 * the even number of segments is at least half of number of ACKs
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 */

export SendDataToFillDutWindowWithVerifyNumberOfAck(
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  int i;
  
  PrepareWaitAndStartObservation(
   dutIpAddress,
   localIpAddress,
  dutPort,
  localPort,
  0,
  0,
  0,
  TcpFlagAck,
  syspar::Wildcard,
  0,
  syspar::Wildcard,
  syspar::Wildcard,
  syspar::Wildcard,
  syspar::Wildcard,
  kFragDefault,
  kIPv4,
  kFalse,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kEquals,
  kFalse,
  0,
  kFalse,
  kWaitUntilTimeout);
  
  i = 1;
  while(gLastReceivedWindow > atol(syspar::MSS) && i <= kMaximumTcpSegments)
  {
    SendDataMessage(localIpAddress, dutIpAddress, localPort, dutPort, atol(syspar::MSS));
    testWaitForTimeout(100);
    if((i % 2) == 0)
    {
      if(gReceivedMessagesPerChannel[1] >= (i / 2))
      {
        testStepPass("SendDataToFillDutWindowWithVerifyNumberOfAck", "After data segment %d the number of received ACKs is %d (and thus at least half that number)", i, gReceivedMessagesPerChannel[1]);
      }
      else
      {
        testStepFail("SendDataToFillDutWindowWithVerifyNumberOfAck", "After data segment %d the number of received ACKs is %d (and thus not at least half that number)", i, gReceivedMessagesPerChannel[1]);
        break;
      }
    }
    i++;
  }
  gObservingEthPackets = kFalse;
  InternalClearAllParameters();
}

/**
 * Sends a TCP data segment
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageWithSpecificChecksum(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  char checksum[]
  )
{
  write("Entering testfunction SendDataMessageWithSpecificChecksum");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    checksum,
    syspar::Wildcard
  );
  gSequenceNumber[0] += elCount(data)-1; // 
}

/**
 * Sends 3 TCP SynAck segments and to 3 different created ports.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort1 The first TCP source port.
 * @param srcPort2 The second TCP source port.
 * @param srcPort3 The third TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendThreeSynAckSegmentsToThreePorts(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort1[],
  char destPort2[],
  char destPort3[],
  char data[]
  )
{  
  int i;
  
  write("Entering testfunction SendThreeSynAckSegmentsToThreePorts");
  for (i = 0; i < 3; i++)
  {
   switch(i)
    {
      case 0:

        gAcknowledgement[0] = 0;
        InternalSendTCPMessage(
          syspar::Wildcard,
          srcIpAddress,
          destIpAddress,
          srcPort,
          destPort1,
          gSequenceNumber[0],
          gAcknowledgement[0],
          TcpFlagSynAck,
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard,
          kCompleteMessage,
          data,
          strlen(data),
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard
          );
        
        gSequenceNumber[0] += (elCount(data) - 1) * 1;
        break;
      
      
      case 1:

        gAcknowledgement[0] = 0;
        InternalSendTCPMessage(
          syspar::Wildcard,
          srcIpAddress,
          destIpAddress,
          srcPort,
          destPort2,
          gSequenceNumber[0],
          gAcknowledgement[0],
          TcpFlagSynAck,
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard,
          kCompleteMessage,
          data,
          strlen(data),
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard
          );
        
        gSequenceNumber[0] += (elCount(data) - 1) * 1;
        break;
      
      
       case 2:
      
        gAcknowledgement[0] = 0;
        InternalSendTCPMessage(
          syspar::Wildcard,
          srcIpAddress,
          destIpAddress,
          srcPort,
          destPort3,
          gSequenceNumber[0],
          gAcknowledgement[0],
          TcpFlagSynAck,
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard,
          kCompleteMessage,
          data,
          strlen(data),
          syspar::Wildcard,
          syspar::Wildcard,
          syspar::Wildcard
          );
        
        gSequenceNumber[0]+= (elCount(data) - 1) * 1;
        break;

    }    
  }
}

/**
 * Sends a TCP data segment with a Specific Sequence Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param gSequenceNumber The Sequence Number of the TCP packet
 * @param data The TCP payload.
 */
export testfunction SendDataMessageWithSpecificSequenceNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword sequenceNumber,
  char data[]
  )
{  
  write("Entering testfunction SendDataMessageWithSpecificSequenceNumber");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    sequenceNumber,
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP data segment with a Out of Window Sequence Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 * @param offset The offset for ackNumber
 */
export testfunction SendDataMessageWithOutOfWindowSequenceNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  dword offset
  )
{  
  write("Entering testfunction SendDataMessageWithOutOfWindowSequenceNumber");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gSequenceNumber[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gUnacceptableNumber,
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  // decrease ack due to expected value in answer from DUT  
  gAcknowledgement[0] = gAcknowledgement[0] - offset;
} 

/**
 * Sends a TCP data segment with a Out of Window Sequence Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageWithOutOfWindowSequenceNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[]
  )
{  
  write("Entering testfunction SendDataMessageWithOutOfWindowSequenceNumber");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gSequenceNumber[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gUnacceptableNumber,
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
}

/**
 * Sends a TCP data segment that is in the receive window of DUT but not at left window edge
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageInWindowOfDut(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[]
  )
{  
  write("Entering testfunction SendDataMessageInWindowOfDut");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0] + gLastReceivedWindow - 1,
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  ); 
  gSequenceNumber[0] += elCount(data)-1;
}

/**
 * Sends a TCP data segment with a Out of Window Sequence Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageWithUnacceptableAcknowledgeNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[]
  )
{  
  write("Entering testfunction SendDataMessageWithUnacceptableAcknowledgeNumber");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gAcknowledgement[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gUnacceptableNumber,
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  // decrease seq/ack due to expected value in answer from DUT
  //gAcknowledgement[0]--;
}

/**
 * Sends a TCP data segment with a Out of Window Sequence Number
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageWithUnacceptableAcknowledgeNumber(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  dword offset
  )
{  
  write("Entering testfunction SendDataMessageWithUnacceptableAcknowledgeNumber");
  gUnacceptableNumber = CalculateUnacceptableSeqAckNumber(gAcknowledgement[0], gLastReceivedWindow);
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gUnacceptableNumber,
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  // decrease ack due to expected value in answer from DUT
  gAcknowledgement[0] = gAcknowledgement[0] - offset;
}

/**
 * Sends a TCP Ack message with options and a specific length
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param optionsNumber Select the options required for a specific testcase.
 */
export testfunction SendDataMessageWithSpecificSequenceNumberAndChecksum(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[], 
  dword sequenceNumber,
  char MssLen[],
  char data[], 
  char checksum[]
  )
{  
  write("Entering testfunction SendDataMessageWithSpecificSequenceNumberAndChecksum");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    sequenceNumber,
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    MssLen,
    checksum,
    syspar::Wildcard
  ); 
}

/**
 * Sends a TCP data segment with Reserved Field value
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageWithReservedField(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  char reservedField[]
  )
{
  write("Entering testfunction SendDataMessageWithReservedField");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    reservedField
  );
  gSequenceNumber[0] += elCount(data)-1; // 
}

/**
 * Sends a TCP data segment with Offset value
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 */
export testfunction SendDataMessageWithOffset(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char offset[],
  char data[]
  )
{
  write("Entering testfunction SendDataMessageWithOffset");
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagPshAck,
    syspar::Wildcard,
    offset,
    syspar::Wildcard,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += elCount(data)-1; // 
}

/**
 * Sends a TCP data segment with Offset value
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 * @param urgentPointerOffset The urgent pointer relative to the sequence number of the 0th byte.
 */
export testfunction SendDataMessageWithUrgPointer(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  long urgentPointerOffset
  )
{
  char urgPointer[10];
  
  write("Entering testfunction SendDataMessageWithUrgPointer");
  snprintf(urgPointer, 4, "%03X", gSequenceNumber[0] - 1 + urgentPointerOffset);
  
  InternalSendTCPMessage(
    syspar::Wildcard,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    gSequenceNumber[0],
    gAcknowledgement[0],
    TcpFlagUrgPsh,
    syspar::Wildcard,
    syspar::Wildcard,
    urgPointer,
    syspar::Wildcard,
    kCompleteMessage,
    data,
    strlen(data),
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard
  );
  gSequenceNumber[0] += elCount(data)-1; // 
}

/**
 * Send several TCP packets and waits for the Ack message from the DUT for every TCP packet sent
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 * @param numberOfPackets The number of packets to be sent.
 */ 
export CauseDutSendAckForEveryTcpPacketReceived(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[],
  char data[],
  long numberOfPackets
  )
{
  int i;
  
  
	 for (i = 0; i < numberOfPackets; i++)
	  {

		  SendDataMessage(localIpAddress, dutIpAddress, localPort, dutPort, data);
		  WaitForTcpAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort, kEquals);
		  
	  }
}

/**
 * Move from Listen to Syn-Sent state by connecting the DUT with tester and then waiting for Syn message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToSynSentState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  char resolvedDutPort[7];
  
  
  Stub_TcpConnect(localIpAddress, localPort);
  if(IsVariableDutPort(dutPort))
  {
    strncpy(resolvedDutPort, syspar::Wildcard, elcount(dutPort));
    InternalSetExtractedParameter("tcp", "source", kExtractInt64);
  }
  else
  {
    strncpy(resolvedDutPort, dutPort, elcount(resolvedDutPort));
  }
  WaitForTcpSyn(timeout, dutIpAddress, localIpAddress, resolvedDutPort, localPort);
  if(IsVariableDutPort(dutPort))
  {
    gVariableDutPort = gExtractingParameters[gExtractingParametersCount-1].Value;
    gSocketPort[0] = gVariableDutPort;
    write("extracted source port from SYN message. DUT uses port %d (%x)", gVariableDutPort, gVariableDutPort);
  }
  gSocketState[0] = TcpStateIdSynSent;
}

/**
 * Move from Listen to Syn-Received state by passive OPEN call.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToSynReceivedStateByPassiveOpen(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  Stub_TcpListenAndAccept(1);
  SendSynMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  WaitForTcpSynAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort);
  gSocketState[0] = TcpStateIdSynReceived;
}

/**
 * Move from Listen to Syn-Received state by sending a Syn Message and then waiting for Syn,Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToSynReceivedState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToSynSentState(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  SendSynMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  WaitForTcpSynAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort);
  gSocketState[0] = TcpStateIdSynReceived;
}

/**
 * Move from Listen to Syn-Received state by sending a Syn Message and then waiting for Syn,Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToSynReceivedStateDecrementAcknowledgeNumber(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToSynReceivedState(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  gAcknowledgement[0]--;
}

/**
 * Move from Listen to Established state by sending a Syn Message, waiting for Syn,Ack message sending Ack Message(DUT active open)
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToEstablishedState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToEstablishedState(
    timeout,
    localIpAddress,
    dutIpAddress,
    localPort,
    dutPort,
    syspar::Wildcard,
    0xFFFF,
    0
  );
}

/**
 * Move from Listen to Established state by sending a Syn Message, waiting for Syn,Ack message sending Ack Message(DUT active open).
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 * @param mss The testers maximum segment size.
 * @param windowSize The window size of the tester.
 */

export CauseDutMoveToEstablishedState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[],
  char mss[],
  dword windowSize)
{
  CauseDutMoveToEstablishedState(timeout, localIpAddress, dutIpAddress,  localPort, dutPort, mss, windowSize, 0);
}

/**
 * Move from Listen to Established state by sending a Syn Message, waiting for Syn,Ack message sending Ack Message(DUT active open).
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 * @param mss The testers maximum segment size.
 * @param windowSize The window size of the tester.
 * @param delayMilliseconds Tester will wait this time before sending SYN-ACK
 */ 
export CauseDutMoveToEstablishedState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[],
  char mss[],
  dword windowSize,
  int delayMilliseconds
  )
{
  char optionsNumber[3], windowStr[10];
  qword timestampSynReceived;
  
  if(!IsWildcard(mss))
  {
    snprintf(optionsNumber, elCount(optionsNumber), "3");
  }
  else
  {
    snprintf(optionsNumber, elCount(optionsNumber), syspar::Wildcard);
  }
  snprintf(windowStr, elCount(windowStr), "%d", windowSize);
  
  CauseDutMoveToSynSentState(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  timestampSynReceived = gTimeStampReceivedTcp;
  if(delayMilliseconds > 0)
  {
    testWaitForTimeout(delayMilliseconds);
  }
  SendSynAckMessage(localIpAddress, dutIpAddress, localPort, dutPort, windowStr, optionsNumber, mss);
  WaitForTcpAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort, kEquals);
  gTimeDiffBetweenSynAnSynAckMilliseconds = gTimestampLastSend/1000 - timestampSynReceived;
  write("timediff between SYN and SYN-ACK is %d ms", gTimeDiffBetweenSynAnSynAckMilliseconds);
  gSocketState[0] = TcpStateIdEstablished;
}

/**
 * Move from Listen to Established state by sending a Syn Message, waiting for Syn,Ack message sending Ack Message(DUT passive open).
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToEstablishedStateByPassiveOpen(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  Stub_TcpListenAndAccept(1);
  SendSynMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  WaitForTcpSynAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort);
  SendAckMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  gSocketState[0] = TcpStateIdEstablished;
}


/**
 * Move from Listen to Close-Wait state by moving to established state and then send a TCP Fin,Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToCloseWaitState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToEstablishedState(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  SendFinAckMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  WaitForTcpAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort, kEquals);
  gSocketState[0] = TcpStateIdCloseWait;
}

/**
 * Move from Listen to Last-Ack state by moving to Close-Wait state and then wait for a TCP Fin,Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToLastAckState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToCloseWaitState(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  Stub_TcpShutdown("0x02");
  WaitForTcpFinAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort);
  gSocketState[0] = TcpStateIdLastAck;
}

/**
 * Move from Listen to Closed state by moving to Last-Ack state and then send a TCP Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToClosedState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToLastAckState(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  SendAckMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  gSocketState[0] = TcpStateIdClosed;
}

/**
 * Move from Listen to Fin-Wait1 state by by moving to Syn-Received state and then waiting for a Syn,Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToFinWait1State(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToEstablishedState(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  Stub_TcpShutdown("0x01");
  WaitForTcpFinAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort);
  gSocketState[0] = TcpStateIdFinWait1;
}

/**
 * Move from Listen to Fin-Wait2 state by moving to Fin-Wait1 state and then send a Ack Message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToFinWait2State(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToFinWait1State(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  SendAckMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  gSocketState[0] = TcpStateIdFinWait2;
}

/**
 * Move from Listen to Closing state by moving to Fin-Wait1 state, send a Fin,Ack message then wait for a Syn,Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToClosingState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToFinWait1State(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  gAcknowledgement[0] -= 1; //lowering the acknowledgement number by one is necessary to distinguish between transition to closing or to time-wait state
  SendFinAckMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  WaitForTcpAckIgnoringOtherFlags(timeout, dutIpAddress, localIpAddress, dutPort, localPort);
  gSocketState[0] = TcpStateIdClosing;
}

export CauseDutMoceToClosedState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
)
{
  
}

/**
 * Move from Listen to Closing state by moving to Fin-Wait2 state, send a Fin,Ack message then wait for a Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToTimeWaitState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToFinWait1State(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  SendFinAckMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  WaitForTcpAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort, kEquals);
  gSocketState[0] = TcpStateIdTimeWait;
}

/**
 * Move from Listen to Time-Wait state by moving through Fin_Wait2 state.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToTimeWaitStateThroughFinWait2(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToFinWait2State(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  SendFinAckMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  WaitForTcpAck(timeout, dutIpAddress, localIpAddress, dutPort, localPort, kEquals);
  gSocketState[0] = TcpStateIdTimeWait;
}

/**
 * Move from Listen to Time-Wait state by moving through Closing state.
 * @param timeout The amount of time in milliseconds to wait.
 * @param localIpAddress The local IP address to match the packet.
 * @param dutIpAddress The DUT IP address to match the packet.
 * @param localPort The TCP local port to match the packet.
 * @param dutPort The TCP DUT port to match the packet.
 */ 
export CauseDutMoveToTimeWaitStateThroughClosingState(
  long timeout,
  char localIpAddress[],
  char dutIpAddress[],
  char localPort[],
  char dutPort[]
  )
{
  CauseDutMoveToClosingState(timeout, localIpAddress, dutIpAddress, localPort, dutPort);
  SendAckMessage(localIpAddress, dutIpAddress, localPort, dutPort);
  gSocketState[0] = TcpStateIdTimeWait;
}

/**
 * Sends a TCP message.
 * @param TTL The time to live of the ipv4 header.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param sequenceNumber Sequence number of the first data.
 * @param acknowledgeNumber Acknowledge number of the receive segment.
 * @param flags TCP flags to indicate the Control bit.
 * @param window the number of data which will be to send.
 * @param offset The TCP offset.
 * @param urgentPointer the urgent pointer of TCP.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param sendingType Set the sending typ of TCP message (e.g. invaild checksum).
 * @param data The TCP payload.
 */
void InternalSendTCPMessage(
  char TTL[],
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword sequenceNumber,
  dword acknowledgeNumber,
  enum TcpFlag flags,
  char window[],
  char offset[],
  char urgentPointer[],
  char optionsNumber[],
  enum SendingType sendingType,
  char data[],
  long dataLength,
  char mssLen[],
  char checksum[],
  char reservedField[]
  )
{
  long p,result,ipLength;
  byte timestampData[6], optionData[100];
  byte buffer[28], reservedFieldByte[1];
  int64 optionsOffset, headerSize;
  
  SetBusContext(GetBusNameContext("Ethernet_1"));
  
  // Determine the Ip version based on the source IP address
  if(IpVersionOfString(srcIpAddress) == 4)
    p = EthInitPacket("ipv4");
  else
    p = EthInitPacket("ipv6");
  
  EthInitProtocol(p, "tcp");
  
  if (syspar::DIface0VLAN >= 0)
  {
    EthAddToken(p, "eth", "vlanId");
    EthSetTokenInt(p, "eth", "vlanId", syspar::DIface0VLAN);
  }

  //Set MAC address
  result = EthSetTokenInt64(p, "eth", "destination", ConvertMacAddressStringToInt64(syspar::DIface0MacAddr));
  if(result != 0) write("Error @ EthSetTokenInt64 eth destination %d", result);
  result = EthSetTokenInt64(p, "eth", "source", ConvertMacAddressStringToInt64(syspar::Host1Mac));
  if(result != 0) write("Error @ EthSetTokenInt64 eth source %d", result);

  //set IP addresses  
  result = EthSetIpAddressToken(p, "destination", destIpAddress);
  if(result != 0) write("Error @ EthSetTokenInt64 ipv4 dest %d", result); 
  result = EthSetIpAddressToken(p, "source", srcIpAddress);
  if(result != 0) write("Error @ EthSetTokenInt64 ipv4 src %d", result);
  
  //set TCP ports
  result = EthSetTokenInt64(p, "tcp", "destination", IsVariableDutPort(destPort) ? gVariableDutPort : atol(destPort));
  if(result != 0) write("Error @ EthSetTokenInt64 tcp dest %d", result);
  result = EthSetTokenInt64(p, "tcp", "source", IsVariableTesterPort(srcPort) ? gVariableTesterPort : atol(srcPort));
  if(result != 0) write("Error @ EthSetTokenInt64 tcp src %d", result);
  
  //set TCP sequence number
  result = EthSetTokenInt64(p, "tcp", "sequence", sequenceNumber);
  if(result != 0) write("Error @ EthSetTokenInt64 tcp sequence %d", result);
  
  //set TCP acknowledge number
  result = EthSetTokenInt64(p, "tcp", "ackNumber", acknowledgeNumber);
  if(result != 0) write("Error @ EthSetTokenInt64 tcp ackNumber %d", result);
  
  //set TCP window
  if(isWildcard(window))
  {
    result = EthSetTokenInt64(p, "tcp", "window", 0xFFFF);
    if(result != 0) write("Error @ EthSetTokenInt64 tcp window %d", result);
  }
  else
  {
    result = EthSetTokenInt64(p, "tcp", "window", atol(window));
    if(result != 0) write("Error @ EthSetTokenInt64 tcp window %d", result);
  }
  
  //set Reserved Field
   if(!isWildcard(reservedField))
  {  reservedFieldByte[0]= atol(reservedField);
     result = EthSetTokenData(p, "tcp", "header", 12, 1, reservedFieldByte); 
     if (result != 0) write("Error @ EthAddToken %d", result);
  }
  
  //TCP Options start
  if(!IsWildcard(optionsNumber))
  {
    switch(atol(optionsNumber))
    {
      case 1:
        //End of options 
        result = EthAddToken(p, "tcp", "option0"); 
        if (result != 0) write("Error @ EthAddToken %d", result);
        break;
        
      case 2:      
        //No Operation x3
        write("add options");
        result = EthAddToken(p, "tcp", "option1"); 
        if (result != 0) write("Error @ EthAddToken %d", result);
        result = EthAddToken(p, "tcp", "option1"); 
        if (result != 0) write("Error @ EthAddToken %d", result);
        result = EthAddToken(p, "tcp", "option1"); 
        if (result != 0) write("Error @ EthAddToken %d", result);
        
        //End of options 
        result = EthAddToken(p, "tcp", "option0"); 
        if (result != 0) write("Error @ EthAddToken %d", result);
        
        write("options added");
        break;  
        
      case 3:
        //Changing MSS option length
        result = EthAddToken(p, "tcp", "option2");
        if (result != 0) write("Error @ EthAddToken %d", result);
        result = EthSetTokenint64(p, "tcp", "option2.length", 4);
        if (result != 0) write("Error @ EthSetTokenData MSS options %d", result);
        optionData.Word(0) = swapWord(atol(mssLen));
        write("mss = %s, optionData = %d, %d", mssLen, optionData[0], optionData[1]);
        result = EthSetTokenData(p, "tcp", "option2.data", 2, optionData);
        if (result != 0) write("Error @ EthSetTokenData MSS option %d", result);

        break;
        
      case 4:
        //Unimplemented TCP option
        result = EthAddToken(p, "tcp", "option3"); 
        if (result != 0) write("Error @ EthAddToken %d", result);
        break;
                
      case 6:      
        write("option 1 and 2");
        result = EthAddToken(p, "tcp", "option1"); 
        if (result != 0) write("Error @ EthAddToken %d", result);
        result = EthAddToken(p, "tcp", "option2"); 
        if (result != 0) write("Error @ EthAddToken %d", result);
        
      case 7:
        //MSS option with illegal length
        result = EthAddToken(p, "tcp", "option2");
        if (result != 0) write("Error @ EthAddToken %d", result);
        result = EthSetTokenint64(p, "tcp", "option2.length", swapWord(atol(mssLen)));
        if (result != 0) write("Error @ EthSetTokenData MSS options %d", result);
        optionData.Word(0) = swapWord(atol(syspar::MSS));
        write("mss = %s, optionData = %d, %d", mssLen, optionData[0], optionData[1]);
        result = EthSetTokenData(p, "tcp", "option2.data", 2, optionData);
        if (result != 0) write("Error @ EthSetTokenData MSS option %d", result);
        
      default:
        write("Error: Unexpected optionsNumber");
        break;
    }
  }
  //TCP Options end
  
  //set TCP flags
  result = EthSetTokenInt64(p, "tcp", "flags", flags);
  if(result != 0) write("Error @ EthSetTokenInt64 tcp flags %d", result);
  
  //Set TCP data
  if(strlen(data) != 0)
  {
    result = EthResizeToken(p, "tcp", "data", dataLength*8); //length is in bits
    if(result != 0) write("Error @ EthResizeToken tcp data %d", result);
    result = EthSetTokenData(p, "tcp", "data", strlen(data), data);
    if(result != 0) write("Error @ EthSetTokenData tcp data %d", result);
  }
    
  //set TCP urgent pointer
  if(!isWildcard(urgentPointer))
  {
    result = EthSetTokenInt64(p, "tcp", "pointer", atol(urgentPointer));
    if(result != 0) write("Error @ EthSetTokenInt64 tcp urgent pointer %d", result);
  }
  
  if(!isWildcard(TTL))
  {
    result = EthSetTokenInt64(p, "ipv4", "ttl", atol(TTL));
    if(result != 0) write("Error @ EthSetTokenInt64 ipv4 ttl %d", result);
  }
  
  result = EthCompletePacket(p);
  if(result != 0) write("Error @ EthCompletePacket %d", result);

  
  // After complete packet  
  if(!isWildcard(offset))
  {
    result = EthSetTokenInt64(p, "tcp", "offset", atol(offset));
    if(result != 0) write("Error @ EthSetTokenInt64 tcp offset %d", result);
    
    // Recalculate TCP checksum
    result = EthSetTokenInt64(p, "tcp", "checksum", CalculateChecksum(p, "tcp"));
    if(result != 0) write("Error @ EthSetTokenInt64 tcp checksum %d", result);
  }
  
  if(sendingType == kInvalidChecksum)
  {
    MakeChecksumInvalid(p, "tcp");
  }
  
  //set Checksum
   if(!isWildcard(checksum))
  {
       result = EthSetTokenInt64(p, "tcp", "checksum", atol(checksum));
       if(result != 0) write("Error @ EthSetTokenInt64 checksum %d", result);
  }
  
  result = EthOutputPacket(p);
  if(result != 0) write("Error @ EthOutputPacket %d", result);
  
  EthReleasePacket(p);
  if(result != 0) write("Error @ EthReleasePacket %d", result);
}

/**
 * Send an ICMPv4 Destination Unreachable or an ICMPv6 Datagram_too_big message.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param MTU The path maximum transmission unit of the connection.
 */
export testfunction SendIcmpUnreachableOrTooBig(
  char destMac[],
  char srcMac[],
  char destIpAddress[],
  char srcIpAddress[],
  char Mtu[]
  )
{
  long p,result;
  int64 optionsOffset;
  byte nextHop[10], buffer[1600];
  int64 headerSize;
  
  write("Entering testfunction SendIcmpUnreachableOrTooBig");
  
  SetBusContext(GetBusNameContext("Ethernet_1"));
    
  if(IpVersionOfString(destIpAddress) == 4)
  {
    p = EthInitPacket("icmpv4");
  
    result = EthSetTokenInt64(p, "icmpv4", "type", 3); // 3: destination unreachable
    if(result != 0) write("Error @ EthSetTokenInt64 icmpv4 type");
    
    result = EthSetTokenInt64(p, "icmpv4", "code", 4); // 4: Fragmentation needed and DF bit set
    if(result != 0) write("Error @ EthSetTokenInt64 icmpv4 code");
    
    //Add last Internet header and 8 bytes of original datagram
    result = EthResizeToken(p,"icmpv4","data",(gLastReceivedPackageHeaderLength+8)*8); // 12: 8 byte Ip payload
    if(result !=0) write("Error @EthResizeToken icmp payload %d", result);
       
    memcpy(buffer, gLastReceivedPackageHeader, gLastReceivedPackageHeaderLength);
    memcpy_off(buffer, 0 + gLastReceivedPackageHeaderLength, gLastReceivedPackagePayload, 0, 8);
    result = EthSetTokenData(p, "icmpv4", "data", gLastReceivedPackageHeaderLength+8, buffer);
    if(result !=0) write("Error @EthSetTokenData icmp payload %d", result);
    
    // set next hop from icmp in ipv4 payload (unknown token designator, icmp payload starts after this field)
    nextHop.word(0) = swapWord((word) atol(Mtu)); 
    result = EthSetTokenData(p, "ipv4", "data", 6, 2, nextHop);
    if(result !=0) write("Error @EthSetTokenData ip payload icmp next hop %d", result);
  }
  else
  {
    p = EthInitPacket("icmpv6");
    
    result = EthSetTokenInt64(p, "icmpv6", "type", 2); // 2: packet too big
    if(result != 0) write("Error @ EthSetTokenInt64 icmpv6 type");
    
    result = EthSetTokenInt64(p, "icmpv6", "code", 0); // 0: datagram too big
    if(result != 0) write("Error @ EthSetTokenInt64 icmpv6 code");
    
    //Add last Internet header and 8 bytes of original datagram
    result = EthResizeToken(p, "icmpv6", "data", (syspar::Ipv6MinimumPMTU - 8) * 8); // As much data as will fit the minimum ipv6 PMTU
    if(result !=0) write("Error @EthResizeToken icmp payload %d", result);
      
    memcpy(buffer, gLastReceivedPackageHeader, gLastReceivedPackageHeaderLength);
    memcpy_off(buffer, 0 + gLastReceivedPackageHeaderLength, gLastReceivedPackagePayload, 0, syspar::Ipv6MinimumPMTU - gLastReceivedPackageHeaderLength);
    result = EthSetTokenData(p, "icmpv6", "data", syspar::Ipv6MinimumPMTU - 8, buffer);
    if(result !=0) write("Error @EthSetTokenData icmp payload %d", result);
    
    // set next hop from icmp in ipv6 payload (unknown token designator, icmp payload starts after this field)
    nextHop.dword(0) = swapdWord((dword) atol(Mtu)); 
    result = EthSetTokenData(p, "ipv6", "data", 4, 4, nextHop);
    if(result !=0) write("Error @EthSetTokenData ip payload icmp next hop %d", result);
  }

  result = EthSetTokenInt64(p, "eth", "destination", ConvertMacAddressStringToInt64(destMac));
  if(result != 0) write("Error @ EthSetTokenInt64 eth dest");
  
  result = EthSetTokenInt64(p, "eth", "source", ConvertMacAddressStringToInt64(srcMac));
  if(result != 0) write("Error @ EthSetTokenInt64 eth src");
  result = EthSetIpAddressToken(p, "destination", destIpAddress);
  if(result != 0) write("Error @ EthSetIpAddressToken ip dest");
  result = EthSetIpAddressToken(p, "source", srcIpAddress);
  if(result != 0) write("Error @ EthSetIpAddressToken ip src");
  
  if (syspar::DIface0VLAN >= 0)
  {
    EthAddToken(p, "eth", "vlanId");
    EthSetTokenInt(p, "eth", "vlanId", syspar::DIface0VLAN);
  }
  
  result = EthCompletePacket(p);
  if(result != 0) write("Error @ EthCompletePacket %d",result);

  result = EthOutputPacket(p);
  if(result != 0) write("Error @ EthOutputPacket %d",result);
  
  EthReleasePacket(p);
  if(result != 0) write("Error @ EthReleasePacket %d",result);
}

/**
 * Sends a ICMP message with a type, code and MTU length.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param type Provide the type of an Icmp message.
 * @param code For detailed descriptions of errors.
 * @param MTU The path maximum transmission unit of the connection.
 */
export SendIcmpUnreachableOrTooBig(
  char destMac[],
  char srcMac[],
  char destIpAddress[],
  char srcIpAddress[],
  int Mtu
  )
{
  char MtuString[10];
  snprintf(MtuString, elcount(MtuString), "%d", Mtu);
  SendIcmpUnreachableOrTooBig(
   destMac,
   srcMac,
   destIpAddress,
   srcIpAddress,
   MtuString
  );
}
/**
 * Waits for several TCP data messages. The amount of expected messages increases only 1 per loop
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param NumberOfExpectedIncreasingLoops  The amount of loops wherein the number of received should be checked/acknowledged.
*/
  export testfunction ReceiveMessagesInCongestionAvoidance(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  long NumberOfExpectedIncreasingLoops
  )
{
  int i,j;
  int numberOfSegmentsExpected;
  write("Entering testfunction ReceiveMessagesInCongestionAvoidance");
  i = 0;
  j = 0;
  numberOfSegmentsExpected = gExpectedMessageOnCongestion + 1;
  
  while (j < NumberOfExpectedIncreasingLoops)
  {

    write ("numberofSegmentsExpected is %i", numberOfSegmentsExpected);
    i = 0;
  
    while(i < numberOfSegmentsExpected)
    {   
      InternalWaitforTcpMessage( 
        timeout, 
        srcIpAddress, 
        destIpAddress,
        srcPort,
        destPort,
        0,
        gAcknowledgement[0],
        gSequenceNumber[0],
        flags,
        data,
        0,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        kFragDefault,
        kIPv4,
        kFalse,
        kNotCheck,
        kNotCheck,
        kNotCheck,
        kEquals,
        kEquals,
        kEquals,
        kNotCheck,
        kNotCheck,
        kEquals,
        kTrue,
        0,
        kTrue,
        kAnswerExpected
       );
       i++;
    }
      
    InternalWaitForUnexpectedTcpMessage(
      1000,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      flags,
      kEquals,
      0,
      kNotCheck
      );

    InternalSendTCPMessage(
      syspar::Wildcard,
      destIpAddress,
      srcIpAddress,
      destPort,
      srcPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      "",
      strlen(""),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
    );
    
    numberOfSegmentsExpected = numberOfSegmentsExpected + 1;
    j++;
  }
    
  
}

/**
 * Waits for several TCP data messages. After RTO occured, starting with one message,
 * amount of expected messages is doubled (and acknowledged) until ssthreshold is
 * achieved
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param sstreshold  The TCP segment size treshold.
 * @param MaximumSegmentSize The maximum segement size.
*/

export testfunction ReceiveMessagesUntilCongestionAvoidance(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  word sstreshold,
  word MaximumSegmentSize
  )
{
  int i;
  int numberOfSegmentsExpected;
  write("Entering testfunction ReceiveMessagesUntilCongestionAvoidance");
  i = 0;
  numberOfSegmentsExpected = 1;  

  while(numberOfSegmentsExpected*MaximumSegmentSize < sstreshold)
  {
    gExpectedMessageOnCongestion = numberOfSegmentsExpected;
    write ("numberofSegmentsExpected is %i", numberOfSegmentsExpected);
    i = 0;
    while(i < numberOfSegmentsExpected)
    {   
      InternalWaitforTcpMessage( 
        timeout, 
        srcIpAddress, 
        destIpAddress,
        srcPort,
        destPort,
        0,
        gAcknowledgement[0],
        gSequenceNumber[0],
        flags,
        data,
        0,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        kFragDefault,
        kIPv4,
        kFalse,
        kNotCheck,
        kNotCheck,
        kNotCheck,
        kEquals,
        kEquals,
        kEquals,
        kNotCheck,
        kNotCheck,
        kEquals,
        kTrue,
        0,
        kTrue,
        kAnswerExpected
       );
       i++;
    }
      
    InternalWaitForUnexpectedTcpMessage(
      1000,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      flags,
      kEquals,
      0,
      kNotCheck
      );

    InternalSendTCPMessage(
      syspar::Wildcard,
      destIpAddress,
      srcIpAddress,
      destPort,
      srcPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      "",
      strlen(""),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
    );
    
    numberOfSegmentsExpected = numberOfSegmentsExpected * 2;
    write ("MSS*Segments = %i, sstreshold = %i", MaximumSegmentSize*numberOfSegmentsExpected, sstreshold);
  }
  
  
}

export testfunction CauseRetransmitBySendingThreeAckOnFirstSegment(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  enum Bool checkChecksum,
  int numberOfSegmentsExpexted)
{
  dword acknumber, acknumberEnd;
  dword seqnumber, seqnumberEnd;
    
  int i,j;
  i = 0;
  j = 0;
  write("Entering testfunction CauseRetransmitBySendingThreeAckOnFirstSegment");

  // Expect IncomingTCPMessage and acknowledge. Store seq, ack numbers temporarily to 
  // be able to send same ack message again and again
  
  InternalWaitforTcpMessage( 
     timeout, 
     srcIpAddress, 
     destIpAddress,
     srcPort,
     destPort,
     0,
     gAcknowledgement[0],
     gSequenceNumber[0],
     flags,
     data,
     0,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     kFragDefault,
     kIPv4,
     checkChecksum,
     kNotCheck,
     kNotCheck,
     kNotCheck,
     kEquals,
     kEquals,
     kEquals,
     kNotCheck,
     kNotCheck,
     kBitwiseAndGreatherThanZero,
     kTrue,
     0,
     kTrue,
     kAnswerExpected
    );
  
  acknumber = gAcknowledgement[0];
  seqnumber = gSequenceNumber[0];
  i++;
  
//  InternalSendTCPMessage(
//    syspar::Wildcard,
//    srcIpAddress,
//    destIpAddress,
//    srcPort,
//    destPort,
//    gSequenceNumber[0],
//    gAcknowledgement[0],
//    TcpFlagAck,
//    syspar::Wildcard,
//    syspar::Wildcard,
//    syspar::Wildcard,
//    syspar::Wildcard,
//    kCompleteMessage,
//    "",
//    strlen(""),
//    syspar::Wildcard,
//    syspar::Wildcard,
//    syspar::Wildcard
//  );
  
  //Now reply each arriving message with same Ack message as before
  
  while(i<numberOfSegmentsExpexted)
  {
    write ("Starting %i th loop now",i+1); 
    InternalWaitforTcpMessage( 
     timeout, 
     srcIpAddress, 
     destIpAddress,
     srcPort,
     destPort,
     0,
     gAcknowledgement[0],
     gSequenceNumber[0],
     flags,
     data,
     0,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     kFragDefault,
     kIPv4,
     checkChecksum,
     kNotCheck,
     kNotCheck,
     kNotCheck,
     kEquals,
     kEquals,
     kEquals,
     kNotCheck,
     kNotCheck,
     kEquals,
     kTrue,
     0,
     kTrue,
     kAnswerExpected
    );
    
    seqnumberEnd = gSequenceNumber[0];
    acknumberEnd = gAcknowledgement[0];
    
    
    if (j<3) //if 3 same ack messages have been sent, sent no one more
    {
      InternalSendTCPMessage(
        syspar::Wildcard,
        destIpAddress,
        srcIpAddress,
        destPort,
        srcPort,
        seqnumber,
        acknumber,
        TcpFlagAck,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        kCompleteMessage,
        "",
        strlen(""),
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard
      );
      j++; //count sent Ack messages
    }
    i++;
  }
  
  // Now receive retransmitted first Segment
  
 InternalWaitforTcpMessage( 
     timeout, 
     srcIpAddress, 
     destIpAddress,
     srcPort,
     destPort,
     0,
     acknumber-5,
     seqnumber,
     flags,
     data,
     0,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     kFragDefault,
     kIPv4,
     checkChecksum,
     kNotCheck,
     kNotCheck,
     kNotCheck,
     kEquals,
     kEquals,
     kEquals,
     kNotCheck,
     kNotCheck,
     kEquals,
     kTrue,
     0,
     kTrue,
     kAnswerExpected
    );
  
  gAcknowledgement[0] = acknumberEnd;
  gSequenceNumber[0] = seqnumberEnd;
 
}

/**
 * Waits for a several TCP data messages. Does not accept more than expexted number of segments.
 * Compares amount of collected payload of incoming messages to stored amound from function
 * WaitForTcpDataSeveralTimesAndStoreAmountOfData
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 * @param numberOfSegmentsExpexted The amount of expected segements.
 */
export testfunction WaitForTcpDataSeveralTimesAndCompareAmountOfData(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  enum Bool checkChecksum,
  int numberOfSegmentsExpexted
  )
{
  int i;
  int length, amountOfCollectedData;
  char incomingdata[100];
  i = 0;
  amountOfCollectedData = 0;
  
  write("Entering testfunction WaitForTcpDataSeveralTimesAndCompareAmountOfData");
  
  write ("numberofSegmentsExpected is %i", numberOfSegmentsExpexted);
  
  while(i<numberOfSegmentsExpexted)
  {
    write ("Starting %i th loop now",i+1);
    InternalSetExtractedParameter("tcp", "data", kExtractData);
    InternalWaitforTcpMessage( 
     timeout, 
     srcIpAddress, 
     destIpAddress,
     srcPort,
     destPort,
     0,
     gAcknowledgement[0],
     gSequenceNumber[0],
     flags,
     data,
     0,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     kFragDefault,
     kIPv4,
     checkChecksum,
     kNotCheck,
     kNotCheck,
     kNotCheck,
     kEquals,
     kEquals,
     kEquals,
     kNotCheck,
     kNotCheck,
     kBitwiseAndGreatherThanZero,
     kTrue,
     0,
     kTrue,
     kAnswerExpected
    );
   i++;
   length = gExtractingParameters[gExtractingParametersCount-1].DataValueLength;
   amountOfCollectedData = amountOfCollectedData + length;
   write ("Data income: %d bytes", length);
   memcpy(incomingdata, gExtractingParameters[gExtractingParametersCount-1].DataValue, length);
   write("data = %s", incomingdata);
   write("Amount of collected data is now: %i",amountOfCollectedData);
   gExtractingParametersCount++;
  }
  
  if (gAmountOfCollectedData != amountOfCollectedData)
  {
    write ("%i != %i", gAmountOfCollectedData, amountOfCollectedData);
    testStepFail("Amount of retransmitted data does not match");
  }
  
  InternalWaitForUnexpectedTcpMessage(
     1000,
     srcIpAddress,
     destIpAddress,
     srcPort,
     destPort,
     flags,
     kBitwiseAndGreatherThanZero,
     0,
     kNotCheck
    );
   
}


/**
 * Waits for a several TCP data messages. Does not accept more than expexted number of segments.
 * Stores amount of collected payload of incoming messages to 
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 * @param numberOfSegmentsExpexted The amount of expected segements.
 */
export testfunction WaitForTcpDataSeveralTimesAndStoreAmountOfData(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  enum Bool checkChecksum,
  int numberOfSegmentsExpexted
  )
{
  int i;
  int length;
  char incomingdata[100];
  i = 0;
  gAmountOfCollectedData = 0;
  
  write("Entering testfunction WaitForTcpDataSeveralTimesAndStoreAmountOfData");
  
  write ("numberofSegmentsExpected is %i", numberOfSegmentsExpexted);
  
  while(i<numberOfSegmentsExpexted)
  {
    write ("Starting %i th loop now",i+1); 
    InternalSetExtractedParameter("tcp", "data", kExtractData);
    InternalWaitforTcpMessage( 
     timeout, 
     srcIpAddress, 
     destIpAddress,
     srcPort,
     destPort,
     0,
     gAcknowledgement[0],
     gSequenceNumber[0],
     flags,
     data,
     0,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     kFragDefault,
     kIPv4,
     checkChecksum,
     kNotCheck,
     kNotCheck,
     kNotCheck,
     kEquals,
     kEquals,
     kEquals,
     kNotCheck,
     kNotCheck,
     kBitwiseAndGreatherThanZero,
     kTrue,
     0,
     kTrue,
     kAnswerExpected
    );
   i++;
   length = gExtractingParameters[gExtractingParametersCount-1].DataValueLength;
   gAmountOfCollectedData = gAmountOfCollectedData + length;
   write ("Data income: %d bytes. ParameterIndx: %d", length, gExtractingParametersCount-1);
   memcpy(incomingdata, gExtractingParameters[gExtractingParametersCount-1].DataValue, length);
   write("data = %s", incomingdata);
   write("Amount of collected data is now: %i",gAmountOfCollectedData);
   gExtractingParametersCount++;
  }
  
  InternalWaitForUnexpectedTcpMessage(
     1000,
     srcIpAddress,
     destIpAddress,
     srcPort,
     destPort,
     flags,
     kBitwiseAndGreatherThanZero,
     0,
     kNotCheck
    );
  
}




/**
 * Waits for a several TCP data messages. Does not aacept more than expexted number of segments
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 * @param numberOfSegmentsExpexted The amount of expected segements.
 */
export testfunction WaitForTcpDataSeveralTimes(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  enum Bool checkChecksum,
  int numberOfSegmentsExpexted
  )
{
  int i;
  dword firstseqnumber;
  
  write("Entering testfunction WaitForTcpDataSeveralTimes");
  i = 0;
  
  write ("numberofSegmentsExpected is %i", numberOfSegmentsExpexted);
  firstseqnumber = gAcknowledgement[0];
  while(i<numberOfSegmentsExpexted)
  {
    write ("Starting %i th loop now",i+1); 
    InternalWaitforTcpMessage( 
     timeout, 
     srcIpAddress, 
     destIpAddress,
     srcPort,
     destPort,
     0,
     gAcknowledgement[0],
     gSequenceNumber[0],
     flags,
     data,
     0,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     syspar::Wildcard,
     kFragDefault,
     kIPv4,
     checkChecksum,
     kNotCheck,
     kNotCheck,
     kNotCheck,
     kEquals,
     kEquals,
     kEquals,
     kNotCheck,
     kNotCheck,
     kBitwiseAndGreatherThanZero,
     kTrue,
     0,
     kTrue,
     kAnswerExpected
    );
   i++;
  }
  //Check for any other message beside a retransmitted first one.
  InternalWaitForUnexpectedTcpMessage(
     1000,
     srcIpAddress,
     destIpAddress,
     srcPort,
     destPort,
     flags,
     kBitwiseAndGreatherThanZero,
     0,
     kNotCheck,
     firstseqnumber,
     kNotEquals
    );
  
}

/**
 * Waits for a TCP data message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 */
export testfunction WaitForTcpData(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  enum CheckType flagsCheck
  )
{
  write("Entering testfunction WaitForTcp");
  
  InternalWaitforTcpMessage(
    timeout,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    0,
    gAcknowledgement[0],
    gSequenceNumber[0],
    flags,
    syspar::Wildcard,
    0,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kFragDefault,
    kIPv4,
    kTrue,
    kNotCheck,
    kNotCheck,
    kNotCheck,
    kEquals,
    kEquals,
    kNotCheck,
    kNotCheck,
    kNotCheck,
    flagsCheck,
    kTrue,
    0,
    kTrue,
    kAnswerExpected
  );
}

/**
 * Waits for a TCP data message with a previously saved sequence number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 */
export testfunction WaitForTcpDataWithSavedSequenceNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpDataWithSavedSequenceNumber");
  
  InternalWaitforTcpMessage(
    timeout,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    0,
    seqDut,
    gSequenceNumber[0],
    TcpFlagUndefined,
    syspar::Wildcard,
    0,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kFragDefault,
    kIPv4,
    kTrue,
    kNotCheck,
    kNotCheck,
    kNotCheck,
    kEquals,
    kEquals,
    kNotCheck,
    kNotCheck,
    kNotCheck,
    kNotCheck,
    kTrue,
    0,
    kTrue,
    kAnswerExpected
  );
}
/**
 * Waits for several TCP Data messages and prepares to acknowledge the first one.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param numberOfPackets The number of TCP packets to be received
 */
export testfunction WaitForSeveralTcpDataAndPrepareToAckFirst(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  long numberOfPackets
  )
{  
  word i;
  write("Entering testfunction WaitForSeveralTcpDataAndPrepareToAckFirst");
  
  for (i = 0; i < numberOfPackets; i++)
  {
    InternalWaitforTcpMessage(
      timeout,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      0,
      gAcknowledgement[0],
      gSequenceNumber[0],
      TcpFlagNone,
      syspar::Wildcard,
      0,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kFragDefault,
      kIPv4,
      kTrue,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kEquals,
      kEquals,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kTrue,
      0,
      kTrue,
      kAnswerExpected
    );
    if(i == 0)
    {
      gPreparedAck = gAcknowledgement[0]; 
    }
  }
}

/**
 * Waits for a TCP data message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 */
export testfunction WaitForTcpData(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  enum Bool checkChecksum
  )
{
  write("Entering testfunction WaitForTcpData");
  
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   checkChecksum,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kTrue,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP data message with fragmentation and IP version and save the sequence number to later recognize a packet with the same number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param fragmentation Provides the fragmentation type of the message.
 * @param ipVersion.
 * @param checkFrag Check which fragmentation typ in IPv4 header. 
 */
export testfunction WaitForTcpDataFragmentedAndSaveSequenceNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword dataLength,
  enum TcpFlag flags,
  enum FragmentationFlag fragFlag,
  enum IpVersion ipVersion,
  enum CheckType checkFrag
  )
{
  write("Entering testfunction WaitForTcpDataFragmentedAndSaveSequenceNumber");
  seqDut = gAcknowledgement[0];
  write("saved sequencenumber = %d", seqDut);
  
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   syspar::Wildcard,
   dataLength,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   fragFlag,
   ipVersion,
   kFalse,
   checkFrag,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kLessThanOrEqual,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP data message with fragmentation and IP version. It also extrracts the sequence number for later comparison.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param fragmentation Provides the fragmentation type of the message.
 * @param ipVersion.
 * @param checkFrag Check which fragmentation typ in IPv4 header. 
 */
export testfunction WaitForTcpDataFragmented(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword dataLength,
  enum TcpFlag flags,
  enum FragmentationFlag fragFlag,
  enum IpVersion ipVersion,
  enum CheckType checkFrag
  )
{
  write("Entering testfunction WaitForTcpDataFragmented");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   syspar::Wildcard,
   dataLength,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   fragFlag,
   ipVersion,
   kFalse,
   checkFrag,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kLessThanOrEqual,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
   InternalSetExtractedParameter("tcp", "sequence", kExtractInt64);
}

/**
 * Waits for a TCP data message with fragmentation and IP version. Expects a previously saved sequence number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param fragmentation Provides the fragmentation type of the message.
 * @param ipVersion.
 * @param checkFrag Check which fragmentation typ in IPv4 header. 
 */
export testfunction WaitForTcpDataFragmentedWithSavedSequenceNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword dataLength,
  enum TcpFlag flags,
  enum FragmentationFlag fragFlag,
  enum IpVersion ipVersion,
  enum CheckType checkFrag
  )
{
  write("Entering testfunction WaitForTcpDataFragmented");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   seqDut,
   gSequenceNumber[0],
   flags,
   syspar::Wildcard,
   dataLength,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   fragFlag,
   ipVersion,
   kFalse,
   checkFrag,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kLessThanOrEqual,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
   InternalSetExtractedParameter("tcp", "sequence", kExtractInt64);
}

/**
 * Waits for a TCP data message with fragmentation and IP version. It also extrracts the sequence number for later comparison.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param dataLength The payload length
 * @param checkDataLength The checktype of the data length
 * @param flags TCP flags (Control bit) to match the packet.
 * @param fragmentation Provides the fragmentation type of the message.
 * @param ipVersion.
 * @param checkFrag Check which fragmentation typ in IPv4 header. 
 */
export testfunction WaitForTcpDataFragmented(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword dataLength,
  enum CheckType checkDataLength,
  enum TcpFlag flags,
  enum FragmentationFlag fragFlag,
  enum IpVersion ipVersion,
  enum CheckType checkFrag
  )
{
  write("Entering testfunction WaitForTcpDataFragmented");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   syspar::Wildcard,
   dataLength,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   fragFlag,
   kIPv4,
   kFalse,
   checkFrag,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   checkDataLength,
   kLessThanOrEqual,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
   InternalSetExtractedParameter("tcp", "sequence", kExtractInt64);
}

/**
 * Waits for a TCP data message with fragmentation with checking the data length.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param ipVersion IP version of the TCP message.
 * @param checkDataLength Check if datalength need sto be checked.
 */
export testfunction WaitForTcpDataMTULength(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword dataLength,
  enum TcpFlag flags,
  enum IpVersion ipVersion,
  enum CheckType checkDataLength
  )
{
  write("Entering testfunction WaitForTcpDataMTULength");
    InternalWaitforTcpMessage(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       gAcknowledgement[0],
       gSequenceNumber[0],
       flags,
       syspar::Wildcard,
       dataLength,
       syspar::Wildcard,
       syspar::Wildcard,
       syspar::Wildcard,
       syspar::Wildcard,
       kFragDefault,
       ipVersion,
       kFalse,
       kEquals,
       kNotCheck,
       kNotCheck,
       kEquals,
       kEquals,
       kEquals,
       checkDataLength,
       kNotCheck,
       kEquals,
       kTrue,
       0,
       kTrue,
   kAnswerExpected
    );
}

/**
 * Waits for a TCP data message with fragmentation with checking the data length. Uses a saved Sequence Number
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param ipVersion IP version of the TCP message.
 * @param checkDataLength Check if datalength need sto be checked.
 */
export testfunction WaitForTcpDataMTULengthWithSavedSequenceNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword dataLength,
  enum TcpFlag flags,
  enum IpVersion ipVersion,
  enum CheckType checkDataLength
  )
{
  write("Entering testfunction WaitForTcpDataMTULengthWithSavedSequenceNumber");
    InternalWaitforTcpMessage(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       seqDut,
       gSequenceNumber[0],
       flags,
       syspar::Wildcard,
       dataLength,
       syspar::Wildcard,
       syspar::Wildcard,
       syspar::Wildcard,
       syspar::Wildcard,
       kFragDefault,
       ipVersion,
       kFalse,
       kEquals,
       kNotCheck,
       kNotCheck,
       kEquals,
       kEquals,
       kEquals,
       checkDataLength,
       kNotCheck,
       kBitwiseAndGreatherThanZero,
       kTrue,
       0,
       kTrue,
   kAnswerExpected
    );
}

/**
 * Waits for a TCP data message with check the data length of last received data package.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 * @param ipVersion.
 */
export testfunction WaitForTcpDataLastReceivedWithSavedSequenceNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  enum CheckType checkDataLength
  )
{
  write("Entering testfunction WaitForTcpDataLastReceivedWithSavedSequenceNumber");
    InternalWaitforTcpMessage(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       seqDut,
       gSequenceNumber[0],
       flags,
       syspar::Wildcard,
       gLastReceivedLength,
       syspar::Wildcard,
       syspar::Wildcard,
       syspar::Wildcard,
       syspar::Wildcard,
       kFragDefault,
       kIPv4,
       kFalse,
       kEquals,
       kNotCheck,
       kNotCheck,
       kEquals,
       kEquals,
       kEquals,
       checkDataLength,
       kNotCheck,
       kBitwiseAndGreatherThanZero,
       kTrue,
       0,
       kTrue,
   kAnswerExpected
    );
}

/**
 * Waits for several TCP data messages with fragmentation with checking the data length is 
   not exceed.
 * @param timeout The amount of time in milliseconds to wait.
 * @param observationTime The observation time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param dataLength The Length of TCP payload.
 */
export testfunction WaitForSeveralTcpDataAndAck(
  long timeout,
  long observationTime,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword dataLength
  )
{
  long startTime;
  
  startTime = timeNow();
  
  while(timeNow() - startTime < observationTime*100) // observationTime*100: convert observationTime to ms
  {
    InternalWaitforTcpMessage(
      timeout,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      0,
      0,
      gSequenceNumber[0],
      TcpFlagPsh,
      syspar::Wildcard,
      dataLength,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kFragDefault,
      kIPv4,
      kFalse,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kEquals,
      kNotCheck,
      kGreaterThan,
      kNotCheck,
      kBitwiseAndGreatherThanZero,
      kTrue,
      0,
      kFalse,
      kNoAnswerExpected
    );
    
    // Break if  big segment was received
    if(TestGetVerdictLastTestCase() == 1)
     break;
    
    // Acknowledge the next segment
    gAcknowledgement[0] += dataLength;
        
    InternalSendTCPMessage(
      syspar::Wildcard,
      destIpAddress,
      srcIpAddress,
      destPort,
      srcPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      "",
      strlen(""),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
    );
  }
}

/**
 * Waits for several TCP data messages with fragmentation with checking the data length does exceed the last received data length.
 * @param timeout The amount of time in milliseconds to wait.
 * @param observationTime The observation time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param dataLength The Lenght of TCP payload.
 */
export testfunction WaitForSeveralTcpDataAndAckUsingLastReceivedLength(
  long timeout,
  long observationTime,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  long startTime;
  
  startTime = timeNow();
  
  while(timeNow() - startTime < observationTime*100) // observationTime*100: convert observationTime to ms
  {
    InternalWaitforTcpMessage(
      timeout,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      0,
      gAcknowledgement[0],
      gSequenceNumber[0],
      TcpFlagPsh,
      syspar::Wildcard,
      gLastReceivedLength,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kFragDefault,
      kIPv4,
      kFalse,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kEquals,
      kEquals,
      kNotCheck,
      kLessThanOrEqual,
      kNotCheck,
      kBitwiseAndGreatherThanZero,
      kTrue,
      0,
      kFalse,
      kAnswerExpected
    );
    
    // Break if segment is not correct or was not received
    if(TestGetVerdictLastTestCase() == 1)
     break;
    
    testWaitForTimeout(2e3);
    
     InternalSendTCPMessage(
        syspar::Wildcard,
        destIpAddress,
        srcIpAddress,
        destPort,
        srcPort,
        gSequenceNumber[0],
        gAcknowledgement[0],
        TcpFlagAck,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard,
        kCompleteMessage,
        "",
        strlen(""),
        syspar::Wildcard,
        syspar::Wildcard,
        syspar::Wildcard
        );
  }
}
/**
 * Waits for several TCP data messages with a given length until a bigger packet is received.
 * @param timeout The amount of time in milliseconds to wait.
 * @param observationTime The observation time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param dataLength The Length of TCP payload.
 */
export testfunction WaitForSeveralTcpDataAndAckUntilBigPacket(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  dword maxAcknowledgment;
  
  // When maxAcknowledgment is reached, the entire message was sent.
  maxAcknowledgment = gAcknowledgement[0] + 0xFFFF; 
  
  gMessageArrived = kTrue;
  while(maxAcknowledgment > gAcknowledgement[0])
  {
    InternalWaitforTcpMessage(
      timeout,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      0,
      gAcknowledgement[0],
      gSequenceNumber[0],
      TcpFlagPsh,
      syspar::Wildcard,
      gLastReceivedLength,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kFragDefault,
      kIPv4,
      kFalse,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kEquals,
      kNotCheck,
      kGreaterThan,
      kNotCheck,
      kBitwiseAndGreatherThanZero,
      kFalse,
      0,
      kFalse,
      kNoAnswerExpected
    );
    
    gAcknowledgement[0] += gLastReceivedLength;
    
    InternalSendTCPMessage(
      syspar::Wildcard,
      destIpAddress,
      srcIpAddress,
      destPort,
      srcPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      "",
      strlen(""),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
    );
    
    if(gMessageArrived == kFalse)
    {  
      //Received a bigger packet
      testStepPass("WaitForSeveralTcpDataAndAckUntilBigPacket", "Received a bigger packet.");
      return;
    }
  }
  testStepFail("WaitForSeveralTcpDataAndAckUntilBigPacket", "DUT never sent a bigger packet.");
  
}

/**
 * Waits for a TCP data message of the last Ack.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param windowValue The expected window value.
 */
export testfunction WaitForTcpDataOfLastReceivedAck(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  char windowValue[]
  )
{
  write("Entering testfunction WaitForTcpDataOfLastReceivedAck");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   ackDut,
   seqDut,
   flags,
   data,
   0,
   syspar::Wildcard,
   windowValue,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP data segment with urgent pointer value.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param urgPointer The urgent pointer value providing the offset of the last data byte.
 */
export testfunction WaitForTcpDataWitUrgPointer(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  char urgPointer[]
  )
{
  write("Entering testfunction WaitForTcpDataWitUrgPointer");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagUrgPsh,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   urgPointer,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for several TCP data segment with urgent pointer value.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param data The TCP Payload to match the packet.
  * @param maxNumberOfSegments Max number of incoming Tcp segment.
 */
export testfunction WaitForSeveralTcpDataWitUrgPointer(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  long maxNumberOfSegments
  )
{
  int i;
  char sequenceCurrent[10];
  long currentUrgentPointer;
  
  write("Entering testfunction WaitForSeveralTcpDataWitUrgPointer");
  currentUrgentPointer = (maxNumberOfSegments - 1) * atol(syspar::MSS);
   
  for(i = 0; i < maxNumberOfSegments; i++)
  {
    snprintf(sequenceCurrent, elcount(sequenceCurrent), "%d", currentUrgentPointer);
    currentUrgentPointer -= atol(syspar::MSS);
    InternalWaitforTcpMessage(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       gAcknowledgement[0],
       gSequenceNumber[0],
       TcpFlagUrg,
       data,
       0,
       syspar::Wildcard,
       syspar::Wildcard,
       syspar::Wildcard,
       sequenceCurrent,
       kFragDefault,
       kIPv4,
       kFalse,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kEquals,
       kEquals,
       kEquals,
       kNotCheck,
       kNotCheck,
       kBitwiseAndGreatherThanZero,
       kTrue,
       0,
       kFalse,
       kAnswerExpected
    );
    
    // Break if data segment is not correct or was not received
    if(TestGetVerdictLastTestCase() == 1)
    break;
  }
   
  
  
    
}

/**
 * Waits for a TCP data message. Saves the extracted parameter.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 */
export testfunction WaitForTcpDataAndSaveIdentificationField(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[]
  )

{
  
  write("Entering testfunction WaitForTcpDataAndSaveIdentificationField");
  InternalSetExtractedParameter("ipv4", "identification", kExtractInt64);
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP data message. Compares the extracted parameter with the parameter extracted previously with "WaitForTcpDataAndSaveIdentificationField".
 * Compares the Identification number of two consecutive received packets.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checktype How to compare the expected and the observed value e.g. kEquals to check for equality.
 */
export testfunction WaitForTcpDataAndCompareIdentificationField(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  enum CheckType idFieldEqual
  )

{ 
  write("Entering testfunction WaitForTcpDataAndCompareIdentificationField");
  InternalAddExpectedParameter("ipv4", "identification", gExtractingParameters[gExtractingParametersCount-1].Value, idFieldEqual);
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP data message. Compares the extracted parameter with the parameter extracted previously with "WaitForTcpDataAndSaveIdentificationField".
 * Compares the Identification number of two consecutive received packets.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checktype How to compare the expected and the observed value e.g. kEquals to check for equality.
 */
export testfunction WaitForTcpDataAndCompareIdentificationField(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  enum CheckType idFieldEqual,
  int seqNumberOffset,
  int ackNumberOffset
  )

{ 
  write("Entering testfunction WaitForTcpDataAndCompareIdentificationField");
  InternalAddExpectedParameter("ipv4", "identification", gExtractingParameters[gExtractingParametersCount-1].Value, idFieldEqual);
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0] + seqNumberOffset,
   gSequenceNumber[0] + ackNumberOffset,
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP data message. Saves the timestamp of the previous message and calculate the retransmission time.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 */
export testfunction WaitForTcpDataAndNoteTheRetransmissionTime(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  int seqNumOffset
  )

{  long timeStampLastMessage;
  
   write("Entering testfunction WaitForTcpDataAndNoteTheRetransmissionTime");
   timeStampLastMessage = gTimeStampReceivedTcp;
   InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0] + seqNumOffset,
   gSequenceNumber[0],
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
  rto = gTimeStampReceivedTcp - timeStampLastMessage;
  if(rto != 0)
  {
   testStep("WaitForTcpDataAndNoteTheRetransmissionTime", "The retransmission timeout is %d ms", rto);
  }
}

/**
 * waits for rto*0.8 milliseconds
 */
export testfunction WaitUntilJustBeforeRTO()
{
  testWaitForTimeout(rto*0.8);
}
  


/**
 * Waits for a TCP data message. Checks that the retransmission timer is double than the previous one (including a tolerance threshold).
 * Compares the Identification number of two consecutive received packets.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 */
export testfunction WaitForTcpDataAndCheckRetransmissionTimer(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  int seqNumOffset
  )

{ 
  qword timeStampLastMessage;
  long timeDiff, lowerBound, upperBound;
  
  write("Entering testfunction WaitForTcpDataAndCheckRetransmissionTimer");
  timeStampLastMessage = gTimeStampReceivedTcp;
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0] + seqNumOffset,
   gSequenceNumber[0],
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
  timeDiff = gTimeStampReceivedTcp - timeStampLastMessage;
  lowerBound = 2*rto*0.9;
  upperBound = 2*rto*1.1;
   if (timeDiff > lowerBound && timeDiff < upperBound)
  {
    testStepPass("", "DUT sent a segment with the correct retransmission timeout. Observed: %d ms, Expected: Between %d ms and %d ms", timeDiff, lowerBound, upperBound);  
  }
  else
  {
    testStepFail("", "DUT sent a segment with the wrong retransmission timeout. Observed: %d ms, Expected: Between %d ms and %d ms", timeDiff, lowerBound, upperBound);
  }  
}

/**
 * Waits for a TCP data message. Checks that the retransmission timer is increasing in a more than linear rate.
 * It finishes after 4 received messages.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 */
export testfunction WaitForTcpDataAndCheckRetransmissionTimerNotlinear(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[]
  )

{ 
  long timeStampLastMessage, lastTimeOut = 0;
  int i = 0;
  
  write("Entering testfunction WaitForTcpDataAndCheckRetransmissionTimerNotlinear");
  while(i<5)
  {
   timeStampLastMessage = gTimeStampReceivedTcp;
   
   InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,  
   kBitwiseAndGreatherThanZero,
   kTrue,   
   0,
   kFalse,
   kAnswerExpected
  );
    i++;
    timeout = gTimeStampReceivedTcp + (gTimeStampReceivedTcp - timeStampLastMessage)*0.8;

    if ((gTimeStampReceivedTcp - timeStampLastMessage) < lastTimeOut)
      {
        write("DUT sent a segment with the wrong retransmission timeout: %d, %d", gTimeStampReceivedTcp, timeStampLastMessage);
        testStepFail("DUT sent a segment with the wrong retransmission timeout");  
      }
    else
      {
         write("DUT sent a segment with the correct retransmission timeout: %d, %d", gTimeStampReceivedTcp, timeStampLastMessage);
      }
      
    lastTimeOut = gTimeStampReceivedTcp - timeStampLastMessage;

  }
  
}

/**
 * Waits for a TCP data message. Checks that the DUT uses a timeout defined by the variable dutTimeout (including a tolerance threshold).
 * Compares the Identification number of two consecutive received packets.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param dutTimeout The timeout that the DUT is expected to use.
 * @param flags The expected flags parameter.
 */
export testfunction WaitForTcpAndCheckInitialRto(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  long dutTimeout,
  enum TcpFlag flags
  )

{
  long timeStampLastMessage;
  long lowerBound, upperBound;
  long timeDiff;
  
  write("Entering testfunction WaitForTcpAndCheckInitialRto");
  timeStampLastMessage = gTimeStampReceivedTcp;
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   0,
   flags,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
  
  lowerBound = dutTimeout - 100;
  upperBound = dutTimeout + 100;
  timeDiff = gTimeStampReceivedTcp - timeStampLastMessage;
   if (timeDiff > lowerBound && timeDiff < upperBound)
  {
    testStepPass("", "DUT sent a segment with the correct timeout. Expected: Between %d ms and %d ms. Observed: %d ms", lowerBound, upperBound, timeDiff);  
  }
  else
  {
    testStepFail("", "DUT sent a segment with the wrong timeout. Expected: Between %d ms and %d ms. Observed: %d ms", lowerBound, upperBound, timeDiff);
  } 
}

/**
 * Waits for a TCP data message. Checks that the DUT uses a timeout defined by the variable dutTimeout (including a tolerance threshold).
 * Compares the Identification number of two consecutive received packets.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags The expected flags parameter.
 */
export testfunction WaitForTcpAndCheckInitialRto(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags
  )

{
  long timeStampLastMessage;
  long lowerBound, upperBound;
  long timeDiff;
  long expectedTimeDiff;
  
  write("Entering testfunction WaitForTcpAndCheckInitialRto");
  timeStampLastMessage = gTimeStampReceivedTcp;
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   0,
   flags,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
  
  expectedTimeDiff = gTimeDiffBetweenSynAnSynAckMilliseconds + _max(syspar::TimeResolutionOfDutMilliseconds, 2*gTimeDiffBetweenSynAnSynAckMilliseconds);
  lowerBound = expectedTimeDiff*0.8;
  upperBound = expectedTimeDiff*1.2;
  timeDiff = gTimeStampReceivedTcp - timeStampLastMessage;
  if (timeDiff > lowerBound && timeDiff < upperBound)
  {
    testStepPass("", "DUT sent a segment with the correct timeout. Expected: Between %d ms and %d ms. Observed: %d ms", lowerBound, upperBound, timeDiff);  
  }
  else
  {
    testStepFail("", "DUT sent a segment with the wrong timeout. Expected: Between %d ms and %d ms. Observed: %d ms", lowerBound, upperBound, timeDiff);
  }
}


/**
 * Waits for a TCP message where the PSH flag is not set
 * Compares the Identification number of two consecutive received packets.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForTcpPshNotSet(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )

{
  
  write("Entering testfunction WaitForTcpPshNotSet");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   0,
   TcpFlagPsh,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndEqualsZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );  
}

/**
 * Waits for several TCP data messages. Checks that the DUT uses a timeout defined by the variable dutTimeout.
 * Compares the Identification number of two consecutive received packets.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags The flag of the expected message to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param Msl The Maximum segment lifetime (MSL) used by DUT.
 * @param checkTypeAckNumber Checktype of AcknowledgenumberCheck.
 */
export testfunction WaitForSeveralTcpMessagesAndCheckRetransmissionDelay(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  long msl,
  enum CheckType checkTypeAckNumber,
  int seqNumOffset
  )
  
{
  int i;
  long retransmissionTimeout;
  long timeoutarray[100];
  long timeStampLastMessage;
  write("Entering testfunction WaitForSeveralTcpMessagesAndCheckRetransmissionDelay");
  
  timeStampLastMessage = gTimeStampReceivedTcp;
  timeoutarray[0] = timeStampLastMessage;
  gMessageArrived = kFalse;
  InternalWaitforTcpMessage(
         timeout,
         srcIpAddress,
         destIpAddress,
         srcPort,
         destPort,
         0,
         gAcknowledgement[0] + seqNumOffset,
         gSequenceNumber[0],
         flags,
         data,
         0,
         syspar::Wildcard,
         syspar::Wildcard,
         syspar::Wildcard,
         syspar::Wildcard,
         kFragDefault,
         kIPv4,
         kFalse,
         kNotCheck,
         kNotCheck,
         kNotCheck,
         kEquals,
         checkTypeAckNumber,
         kNotCheck,
         kNotCheck,
         kNotCheck,
         kEquals,
         kTrue,
         0,
         kFalse,
         kAnswerExpected
  );
  if(!gMessageArrived)
  {
    return;
  }
  retransmissionTimeout = gTimeStampReceivedTcp - timeStampLastMessage;
  timeout = gTimeStampReceivedTcp + (gTimeStampReceivedTcp - timeStampLastMessage)*0.8;
  timeoutarray[1] = gTimeStampReceivedTcp;
  i = 2;
  while(retransmissionTimeout < 2*msl)
  {   
      gMessageArrived = kFalse;
      InternalWaitforTcpMessage(
         2.1*msl, //timeout???
         srcIpAddress,
         destIpAddress,
         srcPort,
         destPort,
         0,
         gAcknowledgement[0] + seqNumOffset,
         gSequenceNumber[0],
         flags,
         data,
         0,
         syspar::Wildcard,
         syspar::Wildcard,
         syspar::Wildcard,
         syspar::Wildcard,
         kFragDefault,
         kIPv4,
         kFalse,
         kNotCheck,
         kNotCheck,
         kNotCheck,
         kEquals,
         checkTypeAckNumber,
         kNotCheck,
         kNotCheck,
         kNotCheck,
         kEquals,
         kTrue,
         0,
         kFalse,
         kAnswerExpected
        );
      timeoutarray[i] = gTimeStampReceivedTcp;
    
      if ((timeoutarray[i]-timeoutarray[i-1]) <= (timeoutarray[i-1]-timeoutarray[i-2]))
      {
        testStepFail("", "The delay is not being incremented. Last delay: %d ms. Delay before last delay: %d ms", timeoutarray[i]-timeoutarray[i-1], timeoutarray[i-1]-timeoutarray[i-2]);
        return;
      }
      else
      {
        testStepPass("", "The delay was correctly incremented. Last delay: %d ms. Delay before last delay: %d ms", timeoutarray[i]-timeoutarray[i-1], timeoutarray[i-1]-timeoutarray[i-2]);
      }
      retransmissionTimeout = timeoutarray[i]-timeoutarray[i-1];
      timeout = gTimeStampReceivedTcp + (gTimeStampReceivedTcp - timeStampLastMessage)*0.8;
      if (!gMessageArrived)
      {
        return;
      }
      i++;
    }
  
   testStep("", "The delay reached 2*MSL = %d ms. Now it will be checked whether it gets fixed at that value.", 2*syspar::Msl);
   InternalWaitforTcpMessage(
         2.1*msl,
         srcIpAddress,
         destIpAddress,
         srcPort,
         destPort,
         0,
         gAcknowledgement[0] + seqNumOffset,
         gSequenceNumber[0],
         flags,
         data,
         0,
         syspar::Wildcard,
         syspar::Wildcard,
         syspar::Wildcard,
         syspar::Wildcard,
         kFragDefault,
         kIPv4,
         kFalse,
         kNotCheck,
         kNotCheck,
         kNotCheck,
         kEquals,
         checkTypeAckNumber,
         kNotCheck,
         kNotCheck,
         kNotCheck,
         kEquals,
         kTrue,
         0,
         kFalse,
         kAnswerExpected
   );
   timeoutarray[i] = gTimeStampReceivedTcp;
   if (abs((timeoutarray[i]-timeoutarray[i-1]) - (timeoutarray[i-1]-timeoutarray[i-2])) < 0.1*2*msl)
   {
     testStepPass("", "The delay was constant after reaching 2*MSL");
   }
   else
   {
      testStepFail("", "The delay was not constant after reaching 2*MSL");
   }
}

/**
 * Waits for a TCP data message and compares the mss if the corresponding option exists.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param mss The maximum segment size.
 */
export testfunction WaitForTcpWithDutMss(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpDataWithOptionalMss");
    
  InternalAddExpectedDataParameter("tcp", "optionalMss", gDutMss, 2, kTrue, 0, kEquals);
  
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagNone,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kTrue,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for several TCP data messages with a specific configured window.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param windowValue The window value to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 */
export testfunction WaitForSeveralTcpDataWithWindow(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  char windowValue[],
  enum Bool checkChecksum,
  long numberOfSegments
  )
{
  int i = 0;
  write("Entering testfunction WaitForSeveralTcpDataWithWindow");
  
  while(i<numberOfSegments)
  {
   InternalWaitforTcpMessage( 
     timeout, 
     srcIpAddress, 
     destIpAddress,
     srcPort, destPort,
     0,
     gAcknowledgement[0],
     gSequenceNumber[0],
     flags,
     data,
     0,
     syspar::Wildcard,
     windowValue,
     syspar::Wildcard,
     syspar::Wildcard,
     kFragDefault,
     kIPv4,
     checkChecksum,
     kNotCheck,
     kNotCheck,
     kNotCheck,
     kEquals,
     kEquals,
     kEquals,
     kNotCheck,
     kNotCheck,
     kEquals,
     kTrue,
     0,
     kFalse,
     kAnswerExpected
    );
   testWaitForTimeout(100);
   i++;
  }
}

/**
 * Waits for several TCP data messages and check that the size of the last packet is the same than the previous one.
 * The function is limited to the reception of 4 packets.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param idFieldEqual If kTrue, only accept packets with the same length.
 */
export testfunction WaitForSeveralTcpDataAndCheckSameSizeBetweenPackets(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  enum CheckType idFieldEqual
)
{ 
  int i = 0;
  
  write("Entering testfunction WaitForSeveralTcpDataAndCheckSameSizeBetweenPackets");
  while(i<4)
   {

  InternalSetExtractedParameter("ipv4", "length", kExtractInt64);
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );


  InternalAddExpectedParameter("ipv4", "length", gExtractingParameters[0].Value, idFieldEqual);
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
    i++;
  InternalSetExtractedParameter("tcp", "sequence", kExtractInt64);
}

}

/**
 * Waits for a TCP data message and check that the size of the last packet is the same than the previous one and that they have different sequence numbers.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 */
export testfunction WaitForTcpDataAndCheckDifferentSequenceNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags
)
{
  write("Entering testfunction WaitForTcpDataAndCheckDifferentSequenceNumber");
    InternalWaitforTcpMessage(
      timeout,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      0,
      gPreviousAcknowledgement[0],
      gSequenceNumber[0],
      TcpFlagPsh,
      syspar::Wildcard,
      gLastReceivedLength,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kFragDefault,
      kIPv4,
      kFalse,
      kNotCheck,
      kNotCheck,
      kNotCheck,
      kNotEquals,
      kEquals,
      kNotCheck,
      kEquals,
      kNotCheck,
      kBitwiseAndGreatherThanZero,
      kTrue,
      0,
      kFalse,
      kAnswerExpected
    );
}

/**
 * Waits for a TCP message and sends ACK until the until N segments are received. Then it will not send more acknowledges.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 * @param windowValue The window value to match the packet.
 * @param N The number of data segments expected.
 */
export testfunction WaitSegmentsAndSendAckBeforeReceiveCorrectNSegments(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  char windowValue[],
  long N
  )
{
  int i=1;
  
  write("Entering testfunction WaitSegmentsAndSendAckBeforeReceiveCorrectNSegments");
  PrepareWaitForEthernet(syspar::Host1Mac, syspar::DIface0MacAddr); 
  PrepareWaitForIp(destIpAddress, srcIpAddress, 0x06);           /* TCP Protocol Type */
  PrepareWaitForTcp(destPort, srcPort);
  
  InternalAddExpectedParameter("tcp", "flags", TcpFlagPshAck);
  
  StartObservationOfIncomingPackets(kAnswerExpected);

  while(1)
  { //I wait for a Segment
    InternalWaitforSeveralTcpMessages(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       gAcknowledgement[0],
       gSequenceNumber[0],
       TcpFlagPshAck,
       syspar::Wildcard,
       0,
       syspar::Wildcard,
       windowValue,
       syspar::Wildcard,
       kFalse,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       0
       );
    
  gSequenceNumber[0] += elCount(data)-1; 
  if(gReceivedMessagesPerChannel[0] == N)
    break;
  i++;
  testWaitForTimeout(100);
    
  InternalSendTCPMessage(
      syspar::Wildcard,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagPshAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      data,
      strlen(data),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
      );
  }
}

/**
 * Waits for a TCP message and sends ACK until the until N segments are received. Then it will send last acknowledges.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 * @param windowValue The window value to match the packet.
 * @param N The number of data segments expected.
 */
export testfunction WaitSegmentsAndSendAckUntilReceiveCorrectNSegments(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  char windowValue[],
  long N
  )
{
  int i;
  i = 0;
  
  write("Entering testfunction WaitSegmentsAndSendAckUntilReceiveCorrectNSegments");
  PrepareWaitForEthernet(syspar::Host1Mac, syspar::DIface0MacAddr);  /* IPv4 Ethertype */
  PrepareWaitForIp(destIpAddress, srcIpAddress, 0x06);           /* TCP Protocol Type */
  PrepareWaitForTcp(destPort, srcPort);
  
  //InternalAddExpectedParameter("tcp", "flags", TcpFlagPsh);
  
  StartObservationOfIncomingPackets(kAnswerExpected);

  while(i < N)
  { //I wait for a Segment
    InternalWaitforSeveralTcpMessages(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       gAcknowledgement[0],
       gSequenceNumber[0],
       TcpFlagPsh, // TcpFlagPshAck,
       syspar::Wildcard,
       0,
       syspar::Wildcard,
       windowValue,
       syspar::Wildcard,
       kFalse,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       0
       );
  ackDut = gAcknowledgement[0];
  seqDut = gSequenceNumber[0];
    
  InternalSendTCPMessage(
      syspar::Wildcard,
      destIpAddress,
      srcIpAddress,
      destPort,
      srcPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagPshAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      data,
      strlen(data),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
      );
    
    write ("Doing Loop Nr: %i",i);
  gSequenceNumber[0] += elCount(data)-1;
  write ("gReceivedMessagesPerChannel[1] = %i", gReceivedMessagesPerChannel[1]);
  if(gReceivedMessagesPerChannel[1] == N)
    break;
  
  ackTesterArray[i] = gAcknowledgement[0];
  seqTesterArray[i] = gSequenceNumber[0];
  i++;
  ackTester = gAcknowledgement[0];
  seqTester = gSequenceNumber[0];
  testWaitForTimeout(100);
  
  }
}

/**
 * Waits for a TCP message and sends ACK until the until N segments are received. Then it will send last acknowledges.
 * @param srcIpAddress The source IP address.
 * @param destIpAddress The destination IP address.
 * @param srcPort The TCP source port.
 * @param destPort The TCP destination port.
 * @param data The TCP payload.
 * @param windowValue The window value to match the packet.
 * @param N The number of data segments expected.
 */
export testfunction WaitSegmentsAndSendSameAckUntilReceiveThirdAck(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char data[],
  char windowValue[]
  )
{
  int i;
  long retransmissionTimeout;
  long timeStampLastMessage;
  
  //Definition of the variables to save the acknowledge and sequence number of the first Segment and Acknowledgement
  long ackDut, seqDut, ackTester, seqTester;
  i = 1;
  
  write("Entering testfunction WaitSegmentsAndSendSameAckUntilReceiveThirdAck");
  
  PrepareWaitForEthernet(syspar::Host1Mac, syspar::DIface0MacAddr);
  PrepareWaitForIp(destIpAddress, srcIpAddress, 0x06);           /* TCP Protocol Type */
  PrepareWaitForTcp(destPort, srcPort);
  
  InternalAddExpectedParameter("tcp", "flags", TcpFlagPsh);
  
  StartObservationOfIncomingPackets(kAnswerExpected);
  
  InternalWaitforTcpMessage(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       gAcknowledgement[0],
       gSequenceNumber[0],
       TcpFlagPsh,
       syspar::Wildcard,
       0,
       syspar::Wildcard,
       windowValue,
       syspar::Wildcard,
       syspar::Wildcard,
       kFragDefault,
       kIPv4,
       kFalse,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kEquals,
       kTrue,
       0,
       kFalse,
       kAnswerExpected
       );
  
  ackDut = gAcknowledgement[0];
  seqDut = gSequenceNumber[0];
  
  
  InternalSendTCPMessage(
      syspar::Wildcard,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      gSequenceNumber[0],
      gAcknowledgement[0],
      TcpFlagPshAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      data,
      strlen(data),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
      );
  
  ackTester = gAcknowledgement[0];
  seqTester = gSequenceNumber[0];


  while(i<3)
  { //I wait for a Segment
    InternalWaitforTcpMessage(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       gAcknowledgement[0],
       gSequenceNumber[0],
       TcpFlagPshAck,
       syspar::Wildcard,
       0,
       syspar::Wildcard,
       windowValue,
       syspar::Wildcard,
       syspar::Wildcard,
       kFragDefault,
       kIPv4,
       kFalse,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kEquals,
       kTrue,
       0,
       kFalse,
       kAnswerExpected
       );
  timeStampLastMessage = gLastReceivedTestabilityReply;  
    
  InternalSendTCPMessage(
      syspar::Wildcard,
      srcIpAddress,
      destIpAddress,
      srcPort,
      destPort,
      seqTester,
      ackTester,
      TcpFlagPshAck,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard,
      kCompleteMessage,
      data,
      strlen(data),
      syspar::Wildcard,
      syspar::Wildcard,
      syspar::Wildcard
      );
    
  i++;
  testWaitForTimeout(100);
  }
     
  InternalWaitforTcpMessage(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       ackDut,
       seqDut,
       TcpFlagPshAck,
       syspar::Wildcard,
       0,
       syspar::Wildcard,
       windowValue,
       syspar::Wildcard,
       syspar::Wildcard,
       kFragDefault,
       kIPv4,
       kFalse,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kEquals,
       kTrue,
       0,
       kFalse,
       kAnswerExpected
       );
  retransmissionTimeout = gLastReceivedTestabilityReply - timeStampLastMessage;
  
  if(retransmissionTimeout > 3000)
    testStepFail("The retransmission timer expired before receiving the correct message");
}

/**
 * Waits for a TCP data message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param ttl The time to live value to match the packet.
 */
export testfunction WaitForTcpDataWithTtl(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  char ttl[]
  )
{
  write("Entering testfunction WaitForTcpDataWithTtl");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   ttl,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Ack message within time.
 * @param timeout The amount of time in milliseconds to wait.
 * @param replyTimeoutMs The amount of time in milliseconds to wait for a reply.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param checktypeTimeout The check for the message timeout.
 */
export testfunction WaitForTimedependingTcpPshAck(
  long timeout,
  qword replyTimeoutMs,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum CheckType checktypeTimeout
  )
{
  write("Entering testfunction WaitForTimedependingTcpPshAck");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   gRoundTripTime + (replyTimeoutMs * 1000),
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagPshAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   checktypeTimeout,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP data message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 */
export testfunction WaitForTcpData(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  word dataLength,
  enum CheckType checkTypeDataLength,
  enum Bool checkChecksum
  )
{
  write("Entering testfunction WaitForTcpData");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   syspar::Wildcard,
   dataLength,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   checkChecksum,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kNotCheck,
   checkTypeDataLength,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}
/**
 * Waits for a TCP data message with a previously saved sequence number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 */
export testfunction WaitForTcpDataWithSavedSequenceNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  word dataLength,
  enum CheckType checkTypeDataLength,
  enum Bool checkChecksum
  )
{
  write("Entering testfunction WaitForTcpDataWithSavedSequenceNumber");
  InternalWaitforTcpMessage(
    timeout,
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    0,
    seqDut,
    gSequenceNumber[0],
    flags,
    syspar::Wildcard,
    dataLength,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kFragDefault,
    kIPv4,
    checkChecksum,
    kNotCheck,
    kNotCheck,
    kNotCheck,
    kEquals,
    kEquals,
    kNotCheck,
    checkTypeDataLength,
    kNotCheck,
    kBitwiseAndGreatherThanZero,
    kTrue,
    0,
    kFalse,
    kAnswerExpected
  );
}

/**
 * Waits for a TCP data message with Timestamp.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flags TCP flags (Control bit) to match the packet.
 * @param data The TCP Payload to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 * @param checTimestamp The Timestamp of the message to match the packet.
 */
export testfunction WaitForTcpDataAfterStubFunction(
  long timeout,
  qword responseTimeoutMs,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flags,
  char data[],
  enum Bool checkChecksum,
  enum CheckType checTimestamp
  )
{
  write("Entering testfunction WaitForTcpDataAfterStubFunction");
  write("gLastReceivedTestabilityReply = %lld", gLastReceivedTestabilityReply);
  write("gLastSendTestability = %11d", gLastSentTestabilityMicroseconds);
  write("responseTimeoutMs = %lld", responseTimeoutMs * 1000);
  write("Expected = %lld", gLastSentTestabilityMicroseconds + (responseTimeoutMs * 1000));
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   gLastSentTestabilityMicroseconds + (responseTimeoutMs * 1000),
   gAcknowledgement[0],
   gSequenceNumber[0],
   flags,
   data,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   checkChecksum,
   kNotCheck,
   checTimestamp,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Syn,Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForTcpSynAck(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpSynAck");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagSynAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Syn,Ack message with determined Acknowledge Number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param ackNumber The TCP acknowledge number
 */
export testfunction WaitForTcpSynAckWithAckNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword ackNumber
  )
{
  write("Entering testfunction WaitForTcpSynAckWithAckNumber");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   ackNumber,
   TcpFlagSynAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Syn,Ack message with determined Acknowledge Number offset.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param ackNumber The TCP acknowledge number
 */
export testfunction WaitForTcpSynAckWithAckNumberOffset(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword ackNumberOffset
  )
{
  write("Entering testfunction WaitForTcpSynAckWithAckNumber");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0] + ackNumberOffset,
   TcpFlagSynAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}


/**
 * Waits for a TCP Rst control message with a zero sequence number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param isSeqNumberZero Check if the sequence number is zero to match the packet.
 */
export testfunction WaitForTcpRst(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum Bool isSeqNumberZero
  )
{
  write("Entering testfunction WaitForTcpRst");
  if(isSeqNumberZero == kTrue)
  {
    gAcknowledgement[0] = 0;
  }
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagRst,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Rst control message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export WaitForTcpRst(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  WaitForTcpRstCheckType(timeout, srcIpAddress, destIpAddress, srcPort, destPort, kEquals);
}


/**
 * Waits for a TCP Rst control message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param checkFlag The checktype for flags
 */
export testfunction WaitForTcpRstCheckType(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum CheckType checkFlag
  )
{
  write("Entering testfunction WaitForTcpRst");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagRst,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   checkFlag,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Rst control message. All other flags will be ignored
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForTcpRstIgnoringOtherFlags(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpRstIgnoringOtherFlags");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagRst,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Rst control message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForTcpRstAfterUnacceptableAcknowledge(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpRstAfterUnacceptableAcknowledge");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gUnacceptableNumber,
   gSequenceNumber[0],
   TcpFlagRst,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Syn message with checking the received sequence number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param checkTypeSeqNumber Check sequence number or not
 * @param checkTypeAckNumber Check ack number or not
 */
export testfunction WaitForTcpSyn(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum CheckType checkTypeSeqNumber,
  enum CheckType checkTypeAckNumber
  )
{
  write("Entering testfunction WaitForTcpSyn");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   0,
   TcpFlagSyn,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   checkTypeSeqNumber,
   checkTypeAckNumber,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Syn message with checking the received sequence number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param checkTypeSeqNumber Check sequence number or not
 */
export testfunction WaitForTcpSyn(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum CheckType checkTypeSeqNumber
  )
{
  write("Entering testfunction WaitForTcpSyn");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   0,
   TcpFlagSyn,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   checkTypeSeqNumber,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Syn message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForTcpSyn(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpSyn");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   0,
   TcpFlagSyn,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Syn message. This function is useful when several sockets are used.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param socketHandle The number of the socket to match the packet.
 */
export testfunction WaitForTcpSynWithSocketHandle(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  word socketHandle
  )
{
  write("Entering testfunction WaitForTcpSynWithSocketHandle");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[socketHandle],
   0,
   TcpFlagSyn,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Syn message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param mssLen The maximum Segment Size of the Maximum Segment Size Option.
 */
export testfunction WaitForTcpSynWithOptions(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char optionsNumber[],
  word mssLen
  )
{
  write("Entering testfunction WaitForTcpSynWithOptions");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   0,
   TcpFlagSyn,
   syspar::Wildcard,
   0,
   optionsNumber,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   mssLen,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Fin message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForTcpFin(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpFin");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagFin,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Fin message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForTcpFinAck(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpFinAck");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagFinAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param checkTypeFlag How the Flag should be checked
 */
export testfunction WaitForTcpAck(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum CheckType checkTypeFlag
  )
{
  write("Entering testfunction WaitForTcpAck");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   checkTypeFlag,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}


/**
 * Waits for a TCP Ack message. The other flags can have an arbitrary value.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForTcpAckIgnoringOtherFlags(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForTcpAck");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Ack message. This function is useful when several sockets are used.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param socketHandle The number of the socket to match the packet.
 * @param checkTypeFlag How should the Flag be checked?
 */
export testfunction WaitForTcpAck(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  word socketHandle,
  enum CheckType checkTypeFlag
  )
{
  write("Entering testfunction WaitForTcpAck");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[socketHandle],
   gSequenceNumber[socketHandle],
   TcpFlagAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   checkTypeFlag,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param windowValue The window value to match the packet.
 * @param checkWindowSize Verify the window size of incoming messages.
 */
export testfunction WaitForTcpAckWithWindow(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char windowValue[],
  enum CheckType checkWindowSize 
  )
{
  write("Entering testfunction WaitForTcpAckWithWindow");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   windowValue,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   checkWindowSize,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for several TCP Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param windowValue The window value to match the packet.
 * @param numberOfPackets The number of TCP packets to be received
 */
export testfunction WaitForSeveralTcpData(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  char windowValue[],
  long numberOfPackets
  )
{  
  word i = 1;
  write("Entering testfunction WaitForSeveralTcpData");
  
  for (i = 0; i < numberOfPackets; i++)
  {
       InternalWaitforTcpMessage(
       timeout,
       srcIpAddress,
       destIpAddress,
       srcPort,
       destPort,
       0,
       gAcknowledgement[0],
       gSequenceNumber[0],
       TcpFlagNone,
       syspar::Wildcard,
       0,
       syspar::Wildcard,
       windowValue,
       syspar::Wildcard,
       syspar::Wildcard,
       kFragDefault,
       kIPv4,
       kFalse,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kEquals,
       kEquals,
       kNotCheck,
       kNotCheck,
       kNotCheck,
       kEquals,
       kTrue,
       0,
       kFalse,
   kAnswerExpected
      );
  }
}

/**
 * Waits for a TCP Ack message with determined Acknowledge number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param ackNumber The TCP acknowledge number
 */
export testfunction WaitForTcpAckWithAckNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword ackNumber
  )
{ 
  write("Entering testfunction WaitForTcpAckWithAckNumber");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gAcknowledgement[0],
   TcpFlagAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Ack message with determined Acknowledge number.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param ackNumber The TCP acknowledge number
 */
export testfunction WaitForTcpAckWithAckNumberOffset(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  dword ackNumberOffset
  )
{ 
  write("Entering testfunction WaitForTcpAckWithAckNumber");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   0,
   gAcknowledgement[0],
   gSequenceNumber[0] + ackNumberOffset,
   TcpFlagAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Ack message within time.
 * @param timeout The amount of time in milliseconds to wait.
 * @param replyTimeoutMs The amount of time in milliseconds to wait for a reply.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param checktypeTimeout The check for the message timeout.
 */
export testfunction WaitForTimedependingTcpAck(
  long timeout,
  qword replyTimeoutMs,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum CheckType checktypeTimeout
  )
{
  write("Entering testfunction WaitForTimedependingTcpAck");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   gRoundTripTime + (replyTimeoutMs * 1000),
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagAck,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   checktypeTimeout,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP Data message within time.
 * @param timeout The amount of time in milliseconds to wait.
 * @param replyTimeoutMs The amount of time in milliseconds to wait for a reply.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param checktypeTimeout The check for the message timeout.
 */
export testfunction WaitForTimedependingTcpData(
  long timeout,
  qword replyTimeoutMs,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum CheckType checktypeTimeout
  )
{
  write("Entering testfunction WaitForTimedependingTcpData");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   gRoundTripTime + (replyTimeoutMs * 1000),
   gAcknowledgement[0],
   gSequenceNumber[0],
   TcpFlagPsh,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   checktypeTimeout,
   kEquals,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kBitwiseAndGreatherThanZero,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
}

/**
 * Waits for a TCP ACK message with in interval.
 * @param timeout The amount of time in milliseconds to wait.
 * @param minimumTime The expected packet may not arrive before this time in milliseconds
 * @param destMac The destination MAC address to match the packet.
 * @param srcMac The source MAC address to match the packet.
 * @param destIp The destination IP address to match the packet.
 * @param srcIp The source IP address to match the packet.
 */

export testfunction WaitForTcpAckInterval(
  long timeout,
  long minimumTime,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
 char passVerb[100], failVerb[100];
  
  PrepareWaitAndStartObservation(
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    0,
    gAcknowledgement[0],
    gSequenceNumber[0],
    TcpFlagAck,
    syspar::Wildcard,
    0,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kFragDefault,
    kIPv4,
    kFalse,
    kNotCheck,
    kNotCheck,
    kNotCheck,
    kEquals,
    kEquals,
    kEquals,
    kNotCheck,
    kNotCheck,
    kEquals,
    kTrue,
    0,
    kFalse,
    kNoAnswerExpected
  );
  
  if (WaitForIncomingPacket(kNoAnswerExpected, _max(1, minimumTime)) == -1) //we have to use at least 1 millisecond, because otherwise this will always be -1
  {  
    testStepFail("WaitForTcpMessage", "DUT sent %s message too early.", TcpFlagAck.name());
    return;
  }
  
  StartObservationOfIncomingPackets(kAnswerExpected);
  if (WaitForIncomingPacket(kAnswerExpected, timeout - minimumTime) == 0)
  {
    gMessageArrived = kTrue;
    testStepPass("WaitForTcpMessage", "DUT sent the expected %s message.", TcpFlagAck.name());
  }
  
  else
  {
      testStepFail("WaitForTcpMessage", "DUT did not send the expected %s message", TcpFlagAck.name());
  }
 
  InternalClearAllParameters();
}
/**
 * Waits for a TCP PSH message with in interval.
 * @param timeout The amount of time in milliseconds to wait.
 * @param minimumTime The expected packet may not arrive before this time in milliseconds
 * @param destMac The destination MAC address to match the packet.
 * @param srcMac The source MAC address to match the packet.
 * @param destIp The destination IP address to match the packet.
 * @param srcIp The source IP address to match the packet.
 */

export testfunction WaitForTcpPshInterval(
  long timeout,
  long minimumTime,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
 char passVerb[100], failVerb[100];
  
  PrepareWaitAndStartObservation(
    srcIpAddress,
    destIpAddress,
    srcPort,
    destPort,
    0,
    gAcknowledgement[0],
    gSequenceNumber[0],
    TcpFlagPsh,
    syspar::Wildcard,
    0,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    syspar::Wildcard,
    kFragDefault,
    kIPv4,
    kFalse,
    kNotCheck,
    kNotCheck,
    kNotCheck,
    kEquals,
    kEquals,
    kEquals,
    kNotCheck,
    kNotCheck,
    kBitwiseAndGreatherThanZero,
    kTrue,
    0,
    kFalse,
    kNoAnswerExpected
  );
  
  if (WaitForIncomingPacket(kNoAnswerExpected, _max(1, minimumTime)) == -1) //we have to use at least 1 millisecond, because otherwise this will always be -1
  {  
    testStepFail("WaitForTcpMessage", "DUT sent %s message too early.", TcpFlagPsh.name());
    return;
  }
  
  StartObservationOfIncomingPackets(kAnswerExpected);
  if (WaitForIncomingPacket(kAnswerExpected, timeout - minimumTime) == 0)
  {
    gMessageArrived = kTrue;
    testStepPass("WaitForTcpMessage", "DUT sent the expected %s message.", TcpFlagPsh.name());
  }
  
  else
  {
      testStepFail("WaitForTcpMessage", "DUT did not send the expected %s message", TcpFlagPsh.name());
  }
 
  InternalClearAllParameters();
}

/**
 * Waits for a TCP message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param timestamp The Timestamp of TCP message to match the packet.
 * @param seqNumber The sequence number to match the packet.
 * @param ackNumber The acknowledge number to match the packet.
 * @param flag set the control bit to the corresponding tcp message type
 * @param data The TCP Payload to match the packet.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param windowValue The window value to match the packet.
 * @param ttl
 * @param urgPointer
 * @param fragmentationFlag
 * @param ipVersionParameter Unused.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 * @param checkFrag Check which fragmentation typ in IPv4 header. 
 * @param checTimestamp The Timestamp of the message to match the packet.
 * @param checkTypeTimestampAndLast The Timestamp of the message depending on last send message to match the packet.
 * @param checkTypeSeqNumber Check the sequence number.
 * @param checkTypeAckNumber Check the acknowledge number.
 * @param checkTypeData Check the Tcp payload.
 * @param mssLen Segment size of option maximum segment size.
 * @param checkFragmentationOrDataLength If true: check if the packet either has an expected dataLength or has the DF bit unset.
 */
void InternalWaitforTcpMessage(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  int64 timestamp,
  dword seqNumber,
  dword ackNumber,
  enum TcpFlag flag,
  char data[],
  dword dataLength,
  char optionsNumber[],
  char windowValue[],
  char ttl[],
  char urgPointer[],
  enum FragmentationFlag fragFlag,
  enum IpVersion ipVersionParameter,
  enum Bool checkChecksum,
  enum CheckType checkFrag,
  enum CheckType checkTypeTimestamp,
  enum CheckType checkTypeTimestampAndLast,
  enum CheckType checkTypeSeqNumber,
  enum CheckType checkTypeAckNumber,
  enum CheckType checkTypeData,
  enum CheckType checkTypeDataLength,
  enum CheckType checkTypeWindowSize,
  enum CheckType checkTypeFlag,
  enum Bool writeReport,
  word mssLen,
  enum Bool checkFragmentationOrDataLength,
  enum ExpectedResult expectedResult
  )
{
  char passVerb[100], failVerb[100];
  
  PrepareWaitAndStartObservation(
  srcIpAddress,
  destIpAddress,
  srcPort,
  destPort,
  timestamp,
  seqNumber,
  ackNumber,
  flag,
  data,
  dataLength,
  optionsNumber,
  windowValue,
  ttl,
  urgPointer,
  fragFlag,
  ipVersionParameter,
  checkChecksum,
  checkFrag,
  checkTypeTimestamp,
  checkTypeTimestampAndLast,
  checkTypeSeqNumber,
  checkTypeAckNumber,
  checkTypeData,
  checkTypeDataLength,
  checkTypeWindowSize,
  checkTypeFlag,
  writeReport,
  mssLen,
  checkFragmentationOrDataLength,
  expectedResult);
  
  if(expectedResult == kAnswerExpected)
  {
    strncpy(passVerb, "sent", elcount(passVerb));
    strncpy(failVerb, "didn't send", elcount(failVerb));
  }
  else if(expectedResult == kNoAnswerExpected)
  {
    strncpy(passVerb, "didn't send", elcount(passVerb));
    strncpy(failVerb, "sent", elcount(failVerb));
  }

  if (WaitForIncomingPacket(expectedResult, timeout) == 0)
  {
    gMessageArrived = kTrue;
    if (writeReport == kTrue)
    {
      testStepPass("WaitForTcpMessage", "DUT %s the expected %s message.", passVerb, flag.name());
    }
  }
  
  else
  {
    gMessageArrived = kFalse;
    if (writeReport == kTrue)
    {
      testStepFail("WaitForTcpMessage", "DUT %s the expected %s message", failVerb, flag.name());
    }
  }
 
  InternalClearAllParameters();
}

void PrepareWaitAndStartObservation(
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  int64 timestamp,
  dword seqNumber,
  dword ackNumber,
  enum TcpFlag flag,
  char data[],
  dword dataLength,
  char optionsNumber[],
  char windowValue[],
  char ttl[],
  char urgPointer[],
  enum FragmentationFlag fragFlag,
  enum IpVersion ipVersionParameter,
  enum Bool checkChecksum,
  enum CheckType checkFrag,
  enum CheckType checkTypeTimestamp,
  enum CheckType checkTypeTimestampAndLast,
  enum CheckType checkTypeSeqNumber,
  enum CheckType checkTypeAckNumber,
  enum CheckType checkTypeData,
  enum CheckType checkTypeDataLength,
  enum CheckType checkTypeWindowSize,
  enum CheckType checkTypeFlag,
  enum Bool writeReport,
  word mssLen,
  enum Bool checkFragmentationOrDataLength,
  enum ExpectedResult expectedResult)
{
  byte optionData[2];
  
  int ipVersion;

  PrepareWaitForEthernet(syspar::Host1Mac, syspar::DIface0MacAddr);
  ipVersion = PrepareWaitForIp(destIpAddress, srcIpAddress, 0x06);           /* TCP Protocol Type */
  
  if(!IsWildcard(destPort))
  {
    if(IsVariableTesterPort(destPort))
    {
      InternalAddExpectedParameter("tcp", "destination", gVariableTesterPort);
    }
    else
    {
      InternalAddExpectedParameter("tcp", "destination", atol(destPort));
    }
  }
  
  if(!IsWildcard(srcPort))
  {
    if(IsVariableDutPort(srcPort))
    {
      InternalAddExpectedParameter("tcp", "source", gVariableDutPort);
    }
    else
    {
      InternalAddExpectedParameter("tcp", "source", atol(srcPort));
    }
  }
  
  if(!IsWildcard(data))
  {
    byte dataBytes[1000];
    memcpy(dataBytes, data, strlen(data));
    InternalAddExpectedDataParameter("tcp", "data", dataBytes, strlen(data), kTrue, 0, checkTypeData);
  }
  
  if(!IsWildcard(windowValue))
  {
    if(checkTypeWindowSize != kNotCheck)
    {
      InternalAddExpectedParameter("tcp", "window", atol(windowValue), checkTypeWindowSize);
    }
    else
    {
      InternalAddExpectedParameter("tcp", "window", atol(windowValue));
    }
  }
  
  if(!IsWildcard(ttl))
  {
    InternalAddExpectedParameter("ipv4", "ttl", atol(ttl));
  }
  
  if(!IsWildcard(urgPointer))
  {
    InternalAddExpectedParameter("tcp", "pointer", atol(urgPointer));
  }
  
  
  if(!IsWildcard(optionsNumber))
  {
    switch(atol(optionsNumber))
    {
      case 1:
        //End of options 
        InternalAddExpectedParameter("tcp", "option0", 1); 
        break;
        
      case 2:
        // MSS option 
        optionData.Word(0) = swapWord(mssLen);
        InternalAddExpectedDataParameter("tcp", "option2.data", optionData, 2, kTrue, 0, kEquals);
        break;   
        
      case 3:
        // MSS option 
        InternalAddExpectedParameter("tcp", "option2.length", 4);
        break;   
        
      default:
        write("Error: Unexpected optionsNumber");
        break;
    }
  }


  if(checkChecksum == kTrue)
  {
    InternalAddExpectedParameter("tcp", "checksum", 0, kValidChecksum);
  }
  
  if(checkTypeAckNumber != kNotCheck && (flag & TcpFlagAck) > 0)
  {
    InternalAddExpectedParameter("tcp", "ackNumber", ackNumber, checkTypeAckNumber);
  }
  
  if(checkTypeSeqNumber != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "sequence", seqNumber, checkTypeSeqNumber);
  }
  
  if(checkTypeTimestamp != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "timestamp", timestamp, checkTypeTimestamp);
  }
  
  if(checkTypeTimestampAndLast != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "timestamp+", timestamp, checkTypeTimestampAndLast);
  }
  
  if(checkTypeFlag != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "flags", flag, checkTypeFlag);
  }
  
  
  if(checkTypeDataLength != kNotCheck)
  {
    if(checkFragmentationOrDataLength == kTrue)
    {
      CopyExpectedParameters(0,1);
    }
    InternalAddExpectedParameter("tcp", "length", dataLength, checkTypeDataLength, 0);
  }
  
  
  if(checkFrag != kNotCheck)
  { 
    int group;
    //If only checking for fragmentation or datalength: Add expected fragmentation parameter to second group
    if(checkFragmentationOrDataLength == kTrue)
    {
      group=1;
    }
    else
    {
      group=0;
    }
    
    if(ipVersion == 4)
    {
       InternalAddExpectedParameter("ipv4", "flags", fragFlag, checkFrag, group);
    }
    
    if(ipVersion == 6)
    {
      if(fragFlag == kDF && (checkFrag == kEqualsBitwiseOr || checkFrag == kBitwiseAndGreatherThanZero || checkFrag == kEquals))
      {
        // Check for fragmentation header being present.
        InternalAddExpectedParameter("ipv6", "fragment.next", 0, kNotEquals, group);
      }
      else
      {
        InternalAddExpectedParameter("ipv6", "fragment.next", 0, kEquals, group);
      }
    }
  }
  StartObservationOfIncomingPackets(expectedResult);
}

/**
 * Waits a specific amount of time for an unexpected TCP response.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedTcpResponseButAcceptRetransmittedFinSyn(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
   write("Entering testfunction WaitForUnexpectedTcpResponseButAcceptRetransmittedSyn");
   InternalWaitForUnexpectedTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   TcpFlagUndefined,
   kNotCheck,
   0,
   kNotCheck,
   gAcknowledgement[0],
   kGreaterThan
  );
  
//   InternalWaitForUnexpectedTcpMessage(
//   timeout,
//   srcIpAddress,
//   destIpAddress,
//   srcPort,
//   destPort,
//   TcpFlagUndefined,
//   kNotCheck,
//   0,
//   kNotCheck
//  );
}

/**
 * Waits a specific amount of time for an unexpected TCP response.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedTcpResponse(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForUnexpectedTcpResponse");
  InternalWaitForUnexpectedTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   TcpFlagUndefined,
   kNotCheck,
   0,
   kNotCheck
  );
}

/**
 * Waits a specific amount of time for an unexpected TCP Syn,Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedTcpSynAck(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForUnexpectedTcpSynAck");
  InternalWaitForUnexpectedTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   TcpFlagSynAck,
   kEquals,
   0,
   kNotCheck
  );
}

/**
 * Waits a specific amount of time for an unexpected TCP Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedTcpAck(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForUnexpectedTcpAck");
  InternalWaitForUnexpectedTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   TcpFlagAck,
   kEquals,
   0,
   kNotCheck
  );
}

/**
 * Waits a specific amount of time for an unexpected TCP Ack message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedTcpAckWithSkippedSequenceNumber(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  
  )
{
  write("Entering testfunction WaitForUnexpectedTcpAckWithSkippedSequenceNumber");
  InternalWaitforTcpMessage(
  timeout,
  srcIpAddress,
  destIpAddress,
  srcPort,
  destPort,
  0,
  gAcknowledgement[0],
  gSkippedSequenceNumber[0],
  TcpFlagAck,
  syspar::Wildcard,
  0,
  syspar::Wildcard,
  syspar::Wildcard,
  syspar::Wildcard,
  syspar::Wildcard,
  kFragDefault,
  kIPv4,
  kFalse,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kEquals,
  kGreaterThan,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kEquals,
  kTrue,
  0,
  kFalse,
  kNoAnswerExpected
  );
}

/**
 * Waits a specific amount of time for an unexpected TCP Rst message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedTcpRst(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForUnexpectedTcpRst");
  InternalWaitForUnexpectedTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   TcpFlagRst,
   kEquals,
   0,
   kNotCheck
  );
}


/**
 * Waits a specific amount of time for an unexpected TCP message and optionally awaits for a RST packet.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedTcpPacketOrWaitForTcpRst(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForUnexpectedTcpPacketOrWaitForTcpRst");
  InternalWaitForUnexpectedTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   TcpFlagRst,
   kNotEquals,
   0,
   kNotCheck
  );
}

/**
 * Waits a specific amount of time for an unexpected TCP responsee and optionally awaits for a Syn packet.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedTcpReplyOrWaitForTcpSyn(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[]
  )
{
  write("Entering testfunction WaitForUnexpectedTcpReplyOrWaitForTcpSyn");
  InternalWaitForUnexpectedTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   srcPort,
   destPort,
   TcpFlagSyn,
   kNotEquals,
   0,
   kNotCheck
  );
}

/**
 * Waits for several TCP messages.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param timestamp The Timestamp of TCP message to match the packet.
 * @param seqNumber The sequence number to match the packet.
 * @param ackNumber The acknowledge number to match the packet.
 * @param flag set the control bit to the corresponding tcp message type
 * @param data The TCP Payload to match the packet.
 * @param optionsNumber Select the options required for a specific testcase.
 * @param windowValue The window value to match the packet.
 * @param checkChecksum If kTrue, only accept packets with a valid checksum.
 * @param checTimestamp The Timestamp of the message to match the packet.
 * @param checkTypeTimestampAndLast The Timestamp of the message depending on last send message to match the packet.
 * @param checkTypeSeqNumber Check the sequence number.
 * @param checkTypeAckNumber Check the acknowledge number.
 * @param checkTypeData Check the Tcp payload.
 * @param mssLen Segment size of option maximum segment size.
 */
void InternalWaitforSeveralTcpMessages(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  int64 timestamp,
  dword seqNumber,
  dword ackNumber,
  enum TcpFlag flag,
  char data[],
  dword dataLength,
  char optionsNumber[],
  char windowValue[],
  char ttl[],
  enum Bool checkChecksum,
  enum CheckType checkTypeTimestamp,
  enum CheckType checkTypeTimestampAndLast,
  enum CheckType checkTypeSeqNumber,
  enum CheckType checkTypeAckNumber,
  enum CheckType checkTypeData,
  enum CheckType checkTypeDataLength,
  enum CheckType checkTypeWindowSize,
  word mssLen
  )
{
  byte optionData[2];

  PrepareWaitForEthernet(syspar::Host1Mac, syspar::DIface0MacAddr);
  PrepareWaitForIp(destIpAddress, srcIpAddress, 0x06);           /* TCP Protocol Type */
  PrepareWaitForTcp(destPort, srcPort);
  
  InternalAddExpectedParameter("tcp", "flags", flag);
  
  if(!IsWildcard(data))
  {
    byte dataBytes[1000];
    memcpy(dataBytes, data, strlen(data));
    InternalAddExpectedDataParameter("tcp", "data", dataBytes, strlen(data), kTrue, 0, checkTypeData);
  }
  
   if(!IsWildcard(windowValue))
  {
    if(checkTypeWindowSize != kNotCheck)
    {
      InternalAddExpectedParameter("tcp", "window", atol(windowValue), checkTypeWindowSize);
    }
    else
    {
      InternalAddExpectedParameter("tcp", "window", atol(windowValue));
    }
  }
  
   if(!IsWildcard(ttl))
  {
    InternalAddExpectedParameter("ipv4", "ttl", atol(ttl));
  }
  
  
   if(!IsWildcard(optionsNumber))
  {
    switch(atol(optionsNumber))
    {
      case 1:
        //End of options 
        InternalAddExpectedParameter("tcp", "option0", 1); 
        break;
        
      case 2:
        // MSS option 
        optionData.Word(0) = swapWord(mssLen);
        InternalAddExpectedDataParameter("tcp", "option2.data", optionData, 2, kTrue, 0, kEquals);
        break;   
        
      case 3:
        // MSS option 
        InternalAddExpectedParameter("tcp", "option2.length", 4);
        break;   
        
      default:
        write("Error: Unexpected optionsNumber");
        break;
    }
  }


  if(checkChecksum == kTrue)
  {
    InternalAddExpectedParameter("tcp", "checksum", 0, kValidChecksum);
  }
  
  if(checkTypeAckNumber != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "ackNumber", ackNumber, checkTypeAckNumber);
  }
  
  if(checkTypeSeqNumber != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "sequence", seqNumber, checkTypeSeqNumber);
  }
  
  if(checkTypeTimestamp != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "timestamp", timestamp, checkTypeTimestamp);
  }
  
  if(checkTypeTimestampAndLast != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "timestamp+", timestamp, checkTypeTimestampAndLast);
  }
  
  if(checkTypeDataLength != kNotCheck)
  {
    InternalAddExpectedParameter("tcp", "length", dataLength, checkTypeDataLength);
  } 
  
  StartObservationOfIncomingPackets(kAnswerExpected);
}

/**
 * Waits a specific amount of time for an unexpected TCP message and optionally awaits for a RST packet.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedDataSegment(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flag,
  enum CheckType checkTypeFlag
  )
{
  write("Entering testfunction WaitForUnexpectedDataSegment");
   InternalWaitForUnexpectedTcpMessage(
     timeout,
     srcIpAddress,
     destIpAddress,
     srcPort,
     destPort,
     flag,
     checkTypeFlag,
     0,
     kNotCheck
    );
}

/**
 * Waits a specific amount of time for an unexpected TCP message and optionally awaits for a RST packet.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedDataSegmentExpectRetransmit(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flag,
  enum CheckType checkTypeFlag
  )
{
  write("Entering testfunction WaitForUnexpectedDataSegmentExpectRetransmit");
   InternalWaitforTcpMessage(
  timeout,
  srcIpAddress,
  destIpAddress,
  srcPort,
  destPort,
  0,
  gAcknowledgement[0],
  gSequenceNumber[0],
  TcpFlagAck,
  syspar::Wildcard,
  0,
  syspar::Wildcard,
  syspar::Wildcard,
  syspar::Wildcard,
  syspar::Wildcard,
  kFragDefault,
  kIPv4,
  kFalse,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kEquals,
  kGreaterThan,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kBitwiseAndGreatherThanZero,
  kTrue,
  0,
  kFalse,
  kNoAnswerExpected
  );
}

/**
 * Waits a specific amount of time for an unexpected TCP message except a zero window probe
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForUnexpectedDataSegmentExceptZeroWindowProbe(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flag,
  enum CheckType checkTypeFlag
  )
{
  write("Entering testfunction WaitForUnexpectedDataSegmentExceptZeroWindowProbe");
   InternalWaitforTcpMessage(
  timeout,
  srcIpAddress,
  destIpAddress,
  srcPort,
  destPort,
  0,
  gAcknowledgement[0],
  gSequenceNumber[0],
  TcpFlagAck,
  syspar::Wildcard,
  1,
  syspar::Wildcard,
  syspar::Wildcard,
  syspar::Wildcard,
  syspar::Wildcard,
  kFragDefault,
  kIPv4,
  kFalse,
  kNotCheck,
  kNotCheck,
  kNotCheck,
  kEquals,
  kEquals,
  kNotCheck,
  kGreaterThan,
  kNotCheck,
  kEquals,
  kTrue,
  0,
  kFalse,
  kNoAnswerExpected
  );
}

/**
 * Waits a specific amount of time for an unexpected TCP message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flag set the control bit to the corresponding tcp message type
 * @param checkTypeFlag Check the control bit of the incoming tcp message.
 * @param dataLength The length of TCP payload.
 * @param checkTypeDataLength Check TCP payload length.  
 */
void InternalWaitForUnexpectedTcpMessage(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flag,
  enum CheckType checkTypeFlag,
  dword dataLength,
  enum CheckType checkTypeDataLength
  )
{
  InternalWaitForUnexpectedTcpMessage(
  timeout,
  srcIpAddress,
  destIpAddress,
  srcPort,
  destPort,
  flag,
  checkTypeFlag,
  dataLength,
  checkTypeDataLength,
  0,
  kNotCheck  
  );
}

/**
 * Waits a specific amount of time for an unexpected TCP message.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param srcPort The TCP source port to match the packet.
 * @param destPort The TCP destination port to match the packet.
 * @param flag set the control bit to the corresponding tcp message type
 * @param checkTypeFlag Check the control bit of the incoming tcp message.
 * @param dataLength The length of TCP payload.
 * @param checkTypeDataLength Check TCP payload length.
 * @param sequencenumber The sequencenumber
 * @param checkTypeSequence Check for sequence number
 */
void InternalWaitForUnexpectedTcpMessage(
  long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char srcPort[],
  char destPort[],
  enum TcpFlag flag,
  enum CheckType checkTypeFlag,
  dword dataLength,
  enum CheckType checkTypeDataLength,
  dword sequencenumber,
  enum CheckType checkTypeSequence
  )
{
  
  PrepareWaitForEthernet(syspar::Host1Mac, syspar::DIface0MacAddr);
  PrepareWaitForIp(destIpAddress, srcIpAddress, 0x06);           /* TCP Protocol Type */
  if(!IsWildcard(destPort))
  {
   InternalAddExpectedParameter("tcp", "destination", atol(destPort));
  }
  
  if(!IsWildcard(srcPort))
  {
    if(IsVariableDutPort(srcPort))
    {
      InternalAddExpectedParameter("tcp", "source", gVariableDutPort);
    }
    else
    {
      InternalAddExpectedParameter("tcp", "source", atol(srcPort));
    }
  }
  
  if (checkTypeSequence != kNotCheck)
  {
    InternalAddExpectedParameter("tcp","sequence", sequencenumber, checkTypeSequence);
  }
  
  if(flag != TcpFlagUndefined)
  {
    InternalAddExpectedParameter("tcp", "flags", flag, checkTypeFlag); 
  } 
  
  if(checkTypeDataLength != kNotCheck)
  {
   
    InternalAddExpectedParameter("tcp", "length", dataLength, checkTypeDataLength);
  }

  StartObservationOfIncomingPackets(kNoAnswerExpected);

  
  if(WaitForIncomingPacket(kNoAnswerExpected, timeout) == 0)
  {
    testStepPass("WaitForUnexpectedTcpMessage", "DUT didn't send a %s message", flag.name());  
  }
  else
  {
    testStepFail("WaitForUnexpectedTcpMessage", "DUT sent a %s message.", flag.name());
  }
  
  InternalClearAllParameters();
}

/**
 * Waits for a TCP Syn message and set a variable Dut port.
 * @param timeout The amount of time in milliseconds to wait.
 * @param srcIpAddress The destination IP address to match the packet.
 * @param destIpAddress The source IP address to match the packet.
 * @param destPort The TCP destination port to match the packet.
 */
export testfunction WaitForSynAndSetVariableDutPort
( long timeout,
  char srcIpAddress[],
  char destIpAddress[],
  char destPort[]
)
{
  InternalSetExtractedParameter("tcp", "source", kExtractInt64);
  
  write("Entering testfunction WaitForSynAndSetVariableDutPort");
  InternalWaitforTcpMessage(
   timeout,
   srcIpAddress,
   destIpAddress,
   syspar::Wildcard,
   destPort,
   0,
   gAcknowledgement[0],
   0,
   TcpFlagSyn,
   syspar::Wildcard,
   0,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   syspar::Wildcard,
   kFragDefault,
   kIPv4,
   kFalse,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kNotCheck,
   kEquals,
   kEquals,
   kNotCheck,
   kNotCheck,
   kEquals,
   kTrue,
   0,
   kFalse,
   kAnswerExpected
  );
  
  gVariableDutPort = gExtractingParameters[gExtractingParametersCount-1].Value;
}

/**
 * Wait and acknowledge for several TCP data message, until the DUT is not in the established state.
 * @param maxNumberOfSegments Max number of incoming Tcp segment.
 */ 
export WaitAndAcknowledgeForSeveralTcpSegments(int maxNumberOfSegments)
{
  int i;
  long timeout = 180000;
  byte outTcpStateId;
  char data[2];
  strncpy(data, syspar::DefaultData, 1);
  
  for(i = 0; i < maxNumberOfSegments; i++)
  {
    timeout+= 20000;
    gAcknowledgement[0]--;
    // Wait for window probe
    WaitForTcpData(
      timeout,
      syspar::DIface0Ip,
      syspar::Host1Ip,
      syspar::VariableDutPort,
      syspar::Wnp,
      TcpFlagPsh,
      1,
      kGreaterThanOrEqual,
      kFalse
    );
   
    // Break if window prob is not correct or was not received
    if(TestGetVerdictLastTestCase() == 1)
     break;
    
    Stub_GetTcpState(TcpStateIdEstablished);  
    if(TestGetVerdictLastTestCase() == 1)
     break;
    
    // Acknowledeg the zero window
    SendAckMessageWithWindowSize(
      syspar::Host1Ip,
      syspar::DIface0Ip,
      syspar::Wnp,
      syspar::VariableDutPort,
      "0",
      1
    ); 
  }
}

/**
 * Wait for several TCP data message.
 * @param maxNumberOfSegments Max number of incoming Tcp segment.
 */ 
export WaitForSeveralTcpDataSegments(int maxNumberOfSegments)
{
  int i;
  dword timeMs;
  dword timeSinceLastData;
  
  timeSinceLastData = 0;
  for(i = 0; i < maxNumberOfSegments; i++)
  {
    // Acknowledge the zero window
    SendAckMessageWithWindowSize(
      syspar::Host1Ip,
      syspar::DIface0Ip,
      syspar::Wnp,
      syspar::VariableDutPort,
      "0",
      1
    );

    timeMs = timeNow() / 100;
    gAcknowledgement[0]--;
    WaitForTcpPshInterval(
      180000 + timeSinceLastData + 1,
      _max(500, timeSinceLastData + 1),
      syspar::DIface0Ip,
      syspar::Host1Ip,
      syspar::VariableDutPort,
      syspar::Wnp
    );
    timeSinceLastData = timeNow() / 100 - timeMs;

    // Break if prob was not received
    if(TestGetVerdictLastTestCase() == 1)
    break;
  }
}

enum Bool IsVariableDutPort(char port[])
{
  if(strncmp(port, syspar::VariableDutPort, elcount(syspar::VariableDutPort)) == 0)
  {
    return kTrue;
  }
  return kFalse;
}

enum Bool IsVariableTesterPort(char port[])
{
  if(strncmp(port, syspar::VariableTesterPort, elcount(syspar::VariableTesterPort)) == 0)
  {
    return kTrue;
  }
  return kFalse;
}

// Creates a unaccetable seq/ack number depending on 
// given value of number and the lastRecievedWindow
dword CalculateUnacceptableSeqAckNumber(dword number, word lastReceivedWindow)
{
  return number + lastReceivedWindow + 100;
}