/*@@var:*/
variables
{
/*$$CANERATORVARBEGIN*/

  // generated at 2010-11-16 by CANerator version 3.7.8,

  /* constants and variables for ECU state */
  const int kStECUInit=0;
  const int kStECUOnline=1;
  const int kStECUOperational=2;

  /* error codes */
  const DWORD kErrorCOMPartnerOffline = 10;
  const DWORD kErrorTxSendBufferFull  = 0x050002;
  /*****************************************************************/
  // all variables for bus default

  int Ecu61State=kStECUInit;    /* 0=Offline, 1=Online, 2=Operational */

  // name of bus
  char BusName[100];

  // msTimer for bootup
  msTimer TimerEcuBootup61;
  msTimer TimerWaitForReq61;
  msTimer TimerRetryEcuBootup61;
  // msTimer for cyclic PGs
  msTimer TimerEcu61PGNFF01;   /* ecu address 61,  PGN FF01 */
  msTimer TimerEcu61PGNFF00;   /* ecu address 61,  PGN FF00 */

  // cycle time variables for cyclic PGs
  int gCycleTime61PGNFF01=100;
  int gCycleTime61PGNFF00=100;

  // timer to check cyclic if ECU is allowed to go online
  msTimer TimWaitForBootmaster61;  /* timer to wait for bootmaster */

  // flags for bootmaster mechanism
  int gAllowClaimAddressEcu61=1;

  // handle to identify ecus
  long Ecu61Handle=0;    /* ecu handle for ecu nr 61 */

  // global addresses for all ecus of this node
  long Ecu61Address=-1;     /* global address of this ecu */

  // handles to the ecu addresses of all ecus
  long Receiver0Address=0;
  long Receiver61Address=61;

  // variable to change the mask in UpdateReceiverAddresses function
  long gMask0=0x1FF; // full NAME mask
  long gMask61=0x1FF; // full NAME mask

  // global addresses for all ecus of this network
  char Ecu0Name[8];      /* global name of this ecu */
  char Ecu61Name[8];     /* global name of this ecu */

  int gFreeAddrFoundFlag61=0;
  char gWSMemberName[8];
/*$$CANERATORVAREND*/

  const int gPerformaceAccelerator = 1;  // make simulation faster (speedup 1..10)

  /* Constants                                                                                                             */
  /* Init variables                                                                                                        */
  const float kMinCatalystTemperature             = 20.0;  /* Minimum Catalyst Temperature [°C]                            */
  const float kMaxCatalystTemperature             = 250.0; /* Maximum Catalyst Temperature [°C]                            */
  const float kMinTankLevel                       = 10.0;  /* Minimum Tank Level [%]                                       */
  const float kMaxTankLevel                       = 100.0; /* Maximum Tank Level [%]                                       */
  const float kMinUreaPressure                    = 0.0;   /* Minimum Urea Pressure [kPa]                                  */
  const float kMaxUreaPressure                    = 500.0; /* Maximum Urea Pressure [kPa]                                  */
  /* Init variabels for PROB_1_EAS Messages                                                                                */
  const float kInitReductionFluidPressure         = 0.0;   /* Init Urea Pressure [kPa]                                     */
  const float kInitCatalystUpstreamTemperature    = 20.0;  /* Init Cat. Upstream Temperature [°C]                          */					
  const float kInitCatalystDownstreamTemperature  = 20.0;  /* Init Cat. Downstream Temperature [°C]                        */
  /* Init variabels for PROB_2_EAS Messages                                                                                */
  const float kInitReductionFluidTankTemperature  = 20.0;  /* Init Tank Temperature [°C]                                   */
  const float kInitReductionFluidTankLevel        = 100.0; /* Init Tank Level [%]                                          */
  const float kInitActualDosingQuantity           = 0;     /* Init Actual Dosing Quantity in [g/h]                         */
  const int kInitActualTransitionState            = 0;     /* Init Actual Transition State in [-]                          */
  const int kInitActualMachineState               = 0;     /* Init Actual Machine State in [-]                             */
  
  /* Global                                                                                                                */
  /* Global variabels for PROB_1_EAS Messages                                                                              */
  float gReductionFluidPressure         = kInitReductionFluidPressure;        /* Init Urea Pressure [kPa]                  */
  float gCatalystUpstreamTemperature    = kInitCatalystUpstreamTemperature;   /* Init Cat. Upstream Temperature [°C]       */
  float gCatalystDownstreamTemperature  = kInitCatalystDownstreamTemperature; /* Init Cat. Downstream Temperature [°C]     */
  /* Global variabels for PROB_2_EAS Messages                                                                              */
  float gReductionFluidTankTemperature  = kInitReductionFluidTankTemperature; /* Init Tank Temperature [°C]                */
  float gReductionFluidTankLevel        = kInitReductionFluidTankLevel;       /* Init Tank Level [%]                       */
  int   gCatalystTankLevelCritical      = 0;                                  /* Init Tank Level critical status variable  */
  int   gCatalystTankLevelStop          = 0;                                  /* Init Tank Level stop status variable      */
  float gActualDosingQuantity           = kInitActualDosingQuantity;          /* Actual Dosing Quantity in [g/h]           */
  float gActualTransitionState          = kInitActualTransitionState;         /* Actual Transition State in [-]            */
  float gActualMachineState             = kInitActualMachineState;            /* Actual Machine State in [-]               */
  
  /* Global variabels for Receive Messages                                                                                 */
  float gEngineSpeed                    = 0.0; /* Engine Speed [rpm]                                                       */
  float gEngineOilTemperature           = 0.0; /* Engine Oil Temperature [°C]                                              */
  float gEngineCoolantTemperature       = 0.0; /* Engine Coolant Temperature [°C]                                          */
  float gActualEngineTorque             = 0.0; /* Actual Engine Torque [%]                                                 */
  float gAmbientTemperature             = 0.0; /* Ambient Temperature [°C]                                                 */
  float gBarometricPressure             = 0.0; /* Barometric Pressure [kPa]                                                */
  float gRequestedDosingQuantity        = 0.0; /* Requested Dosing Quantity [g/h]                                          */
   
  /* Diagnostics                                                                                                           */  
  BYTE gDTCActive;           /* True, if DTC is  active */
  BYTE gActiveCount;         /* Active entries in DTC active table */
  BYTE gPreviousActiveCount; /* Active entries in DTC previous active table */
  DWORD gDTCActiveTable[10];   /* Table with active DTCs */
  DWORD gDTCPreviousTable[10]; /* Table with previously active DTCs */
  Timer  DM1Timer;             /* Timer for transsmision of DM1 */
  // Constants for diagnostics
  const BYTE kFMI_AboveNormal  = 0;  /* Data valid but above normal operation range */
  const BYTE kFMI_BelowNormal  = 1;  /* Data valid but below normal operation range */
  const BYTE kFMI_DataErratic  = 2;  /* Data erratic, intermittent or incorrect */
  const BYTE kFMI_CauseUnknown = 11; /* Root cause not known */

  /* Timers                                                                                                                */
  const int   kSystemTime      = 100;                  /* System time in [ms]                                              */
  const float kSystemTimeSec   = kSystemTime / 1000.0; /* System time in [sec]                                             */
  msTimer     SystemTimer;                             /* System timer                                                     */
}
/*@@end*/

/*@@startStart:Start:*/
on start
{
/*$$CANERATORSTARTBEGIN*/
  // make names for all ECUs
  J1939MakeName(Ecu0Name,1,1,0,0,0,0,0,1861,2);
  J1939MakeName(Ecu61Name,1,1,0,0,44,0,0,1861,1);

  strncpy(BusName,"default",100);
  // delay sending Address Claim in mode 1
  setTimer(TimerEcuBootup61,10);

/*$$CANERATORSTARTEND*/

  setTimer(SystemTimer, kSystemTime);
  
}
/*@@end*/

/*@@timer:TimerEcuBootup61:*/
/*$$CANERATORBEGIN*/
on timer TimerEcuBootup61
{
  long timeOfReq = 0;
  timeOfReq = J1939TableTime(BusName);
  if ((timeOfReq < (timeNow()-1250000)) || (timeOfReq == 0))
  {
    J1939UpdateTable(BusName);
    setTimer(TimerWaitForReq61,1250);
  }
  else
  {
    timeOfReq = (1250-(((timeNow()-timeOfReq)/100)));
    if (timeOfReq < 0)
      timeOfReq=0;
    setTimer(TimerWaitForReq61,timeOfReq);
  }
}
/*$$CANERATOREND*/
/*@@end*/

/*@@timer:TimerRetryEcuBootup61:*/
/*$$CANERATORBEGIN*/
on timer TimerRetryEcuBootup61
{
  RetryEcu61GoOnline();
}
/*$$CANERATOREND*/
/*@@end*/

/*@@timer:TimerEcu61PGNFF01:*/
/*$$CANERATORBEGIN*/
on timer TimerEcu61PGNFF01
{
  /* try to transmit PGN */
  if(TransmitEcu61PGNFF01() == kErrorTxSendBufferFull)
  {
    /* error handling: send buffer is full (try to send PGN in next cycle) */
    setTimer(TimerEcu61PGNFF01, gCycleTime61PGNFF01);
  }
}

/*$$CANERATOREND*/
/*@@end*/

/*@@timer:TimerEcu61PGNFF00:*/
/*$$CANERATORBEGIN*/
on timer TimerEcu61PGNFF00
{
  /* try to transmit PGN */
  if(TransmitEcu61PGNFF00() == kErrorTxSendBufferFull)
  {
    /* error handling: send buffer is full (try to send PGN in next cycle) */
    setTimer(TimerEcu61PGNFF00, gCycleTime61PGNFF00);
  }
}

/*$$CANERATOREND*/
/*@@end*/

/*@@timer:TimerWaitForReq61:*/
/*$$CANERATORBEGIN*/
on timer TimerWaitForReq61
{
  EcuBootup(61);
}

/*$$CANERATOREND*/
/*@@end*/

/*@@timer:TimWaitForBootmaster61:*/
/*$$CANERATORBEGIN*/
on timer TimWaitForBootmaster61
{
  EcuBootup(61);
}

/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:EcuBootup(int):*/
/*$$CANERATORBEGIN*/
/*-------------------------------------------------------------------------------------
  The function creates a handle for an ECU and starts the Address Claiming procedure.
-------------------------------------------------------------------------------------*/
void EcuBootup(int ecuNumb)
{
  if (ecuNumb == 61)
  {
    if (gAllowClaimAddressEcu61 == 1)
    {
      if (Ecu61Handle)
      {
        if (J1939DestroyECU(Ecu61Handle) == 0)
        {
          Ecu61Handle=0;
          setTimer(TimerEcuBootup61,100);
          return;
        }
      }
      InitEcu61();     /* init name and address of ecu61 */

      // general init function
      Init();          /* use this function to make your own initialisation */

      // get handle for ecu
      if (Ecu61Handle == 0)
        Ecu61Handle = J1939CreateECU(BusName,Ecu61Name);
      if (!Ecu61Handle) {
        write("J1939CreateECU for Ecu failed. Maybe busname or ecu name is not correct.");
        stop();
      }
      else
      {
        // ecu goes online
        if (gFreeAddrFoundFlag61)
        {
          J1939ECUGoOnline(Ecu61Handle, Ecu61Address);
        }
        else
        {
          J1939ECUGoOffline(Ecu61Handle);
        }
      }

    }
  }

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:InitEcu61():*/
/*$$CANERATORBEGIN*/
/*-------------------------------------
  Function initializes data of "EAS".
-------------------------------------*/
void InitEcu61()
{
  long nameId;
  word nameManufacturer;
  byte ecuInstance;
  byte ecuFuncInstance;
  byte ecuFunc;
  byte system;
  byte systemInstance;
  byte industryGroup;
  byte arbitrary;
  char name[8];

  // set ecu offline
  Ecu61State = kStECUInit;

  // init address of this node
  Ecu61Address = Aftertreatment::EAS.NmStationAddress; /* get ecu address */
  // check if this address is already used by another ECU
  if( J1939GetName(BusName,Ecu61Address,name) == 0)
  {
    Ecu61Address = 128;

    // check for next free address
    gFreeAddrFoundFlag61=1;
    while ( J1939GetName(BusName,Ecu61Address,name) == 0)
    {
      Ecu61Address++;
      if (Ecu61Address >= 253)
      {
        gFreeAddrFoundFlag61=0;
        break;
      }
    }
  }
  else
  {
    gFreeAddrFoundFlag61=1;
  }
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:Init():*/
/*$$CANERATORUSERBEGIN*/
/*------------------------------------------
  User dependent Init function:
  Insert your own initialization code here.
------------------------------------------*/
void Init()
{

}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:J1939AppAddrClaimed(long):*///callback
/*$$CANERATORBEGIN*/
/*-------------------------------------------------------------------------
  -- Callback function --

  Callback function is called if a node has claimed address successfully.
-------------------------------------------------------------------------*/
DWORD J1939AppAddrClaimed(long ecuhdl)
{
/*$$USERAREA_J1939APPADDRCLAIMEDBEGIN*/
// insert your application code here
/*$$USERAREA_J1939APPADDRCLAIMEDEND*/

  if(ecuhdl == Ecu61Handle)
  {
    Ecu61State = kStECUOperational;
    Ecu61Address = J1939GetNodeAddr(ecuhdl);
    GoOnline(Ecu61Address);
  }
  return 0;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:GoOnline(long):*/
/*$$CANERATORBEGIN*/
/*-----------------------------------------------------------------------
  Function starts the transmission of the cyclic PGs if node is online.
-----------------------------------------------------------------------*/
void GoOnline(long address)
{
  // pgs to get repetition cycle type from CANdb
  pg Aftertreatment::PROB_1_EAS pROB_1_EAS;
  pg Aftertreatment::PROB_2_EAS pROB_2_EAS;

/*$$USERAREA_GOBEGIN*/
  setTimer( DM1Timer, 0 );
/*$$USERAREA_GOEND*/

  UpdateReceiverAddresses();

  if (address == Ecu61Address)
  {
    if (Ecu61State == kStECUOperational)
    {
      cancelTimer(TimerEcu61PGNFF01);
      setTimer(TimerEcu61PGNFF01,gCycleTime61PGNFF01);
      cancelTimer(TimerEcu61PGNFF00);
      setTimer(TimerEcu61PGNFF00,gCycleTime61PGNFF00);
    }
    return;
  }

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:TransmitEcu61PGNFF01():*/
/*$$CANERATORBEGIN*/
/*----------------------------------------------------
  "EAS" (0x3D) sends global PG "PROB_2_EAS" (0xFF01)
----------------------------------------------------*/
DWORD TransmitEcu61PGNFF01()
{
  pg Aftertreatment::PROB_2_EAS pROB_2_EAS;
  int loop;
  char buffer[8];
  DWORD TxPgn;
  DWORD retVal = 0;
  byte pduf, pdus;

  pduf = pROB_2_EAS.PF;
  pdus = pROB_2_EAS.DA;
  TxPgn = ((pduf << 8) | pdus);

  if ((pROB_2_EAS.Characteristic & 0x00000001) == 1)
  {
    TxPgn |= 0x00010000;
  }

  // get the data of this PG
  GetEcu61PGNFF01Data(pROB_2_EAS);

  for (loop=0;loop < (pROB_2_EAS.dlc); loop++)
  {
    buffer[loop] = pROB_2_EAS.byte(loop);
  }

  retVal = J1939TxReqPG(Ecu61Handle, TxPgn, 0xFF, 6, pROB_2_EAS.dlc, buffer);

  /* return error code (0 = no error) */
  return retVal;
}

/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:TransmitEcu61PGNFF00():*/
/*$$CANERATORBEGIN*/
/*----------------------------------------------------
  "EAS" (0x3D) sends global PG "PROB_1_EAS" (0xFF00)
----------------------------------------------------*/
DWORD TransmitEcu61PGNFF00()
{
  pg Aftertreatment::PROB_1_EAS pROB_1_EAS;
  int loop;
  char buffer[8];
  DWORD TxPgn;
  DWORD retVal = 0;
  byte pduf, pdus;

  pduf = pROB_1_EAS.PF;
  pdus = pROB_1_EAS.DA;
  TxPgn = ((pduf << 8) | pdus);

  if ((pROB_1_EAS.Characteristic & 0x00000001) == 1)
  {
    TxPgn |= 0x00010000;
  }

  // get the data of this PG
  GetEcu61PGNFF00Data(pROB_1_EAS);

  for (loop=0;loop < (pROB_1_EAS.dlc); loop++)
  {
    buffer[loop] = pROB_1_EAS.byte(loop);
  }

  retVal = J1939TxReqPG(Ecu61Handle, TxPgn, 0xFF, 6, pROB_1_EAS.dlc, buffer);

  /* return error code (0 = no error) */
  return retVal;
}

/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:TransmitEcu61To255PGNE8FF():*/
/*$$CANERATORBEGIN*/
/*----------------------------------------------------
  "EAS" (0x3D) sends specific PG "ACKM_EAS" (0xE8FF)
  to destination addres 0xFF
----------------------------------------------------*/
DWORD TransmitEcu61To255PGNE8FF()
{
  pg Aftertreatment::ACKM_EAS aCKM_EAS;
  int loop;
  char buffer[8];
  DWORD TxPgn;
  DWORD retVal = 0;
  byte pduf, pdus;
  int numbOfDest=0;

  pduf = aCKM_EAS.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  if ((aCKM_EAS.Characteristic & 0x00000001) == 1)
  {
    TxPgn |= 0x00010000;
  }

  aCKM_EAS.DA = 0xFF;
  GetEcu61To255PGNE8FFData(aCKM_EAS);

  for (loop=0;loop < (aCKM_EAS.dlc); loop++)
  {
    buffer[loop] = aCKM_EAS.byte(loop);
  }

  /* check if receiver is online */
  if (aCKM_EAS.DA != 0xFE)
  {
    retVal = J1939TxReqPG(Ecu61Handle, TxPgn, aCKM_EAS.DA, 6, aCKM_EAS.dlc, buffer);
  }
  else
  {
    retVal = kErrorCOMPartnerOffline;
  }

  /* return error code (0 = no error) */
  return retVal;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:TransmitEcu61To255PGNEBFF():*/
/*$$CANERATORBEGIN*/
/*----------------------------------------------------
  "EAS" (0x3D) sends specific PG "TPDT_EAS" (0xEBFF)
  to destination addres 0xFF
----------------------------------------------------*/
DWORD TransmitEcu61To255PGNEBFF()
{
  pg Aftertreatment::TPDT_EAS tPDT_EAS;
  int loop;
  char buffer[8];
  DWORD TxPgn;
  DWORD retVal = 0;
  byte pduf, pdus;
  int numbOfDest=0;

  pduf = tPDT_EAS.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  if ((tPDT_EAS.Characteristic & 0x00000001) == 1)
  {
    TxPgn |= 0x00010000;
  }

  tPDT_EAS.DA = 0xFF;
  GetEcu61To255PGNEBFFData(tPDT_EAS);

  for (loop=0;loop < (tPDT_EAS.dlc); loop++)
  {
    buffer[loop] = tPDT_EAS.byte(loop);
  }

  /* check if receiver is online */
  if (tPDT_EAS.DA != 0xFE)
  {
    retVal = J1939TxReqPG(Ecu61Handle, TxPgn, tPDT_EAS.DA, 6, tPDT_EAS.dlc, buffer);
  }
  else
  {
    retVal = kErrorCOMPartnerOffline;
  }

  /* return error code (0 = no error) */
  return retVal;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:TransmitEcu61To255PGNECFF():*/
/*$$CANERATORBEGIN*/
/*----------------------------------------------------
  "EAS" (0x3D) sends specific PG "TPCM_EAS" (0xECFF)
  to destination addres 0xFF
----------------------------------------------------*/
DWORD TransmitEcu61To255PGNECFF()
{
  pg Aftertreatment::TPCM_EAS tPCM_EAS;
  int loop;
  char buffer[8];
  DWORD TxPgn;
  DWORD retVal = 0;
  byte pduf, pdus;
  int numbOfDest=0;

  pduf = tPCM_EAS.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  if ((tPCM_EAS.Characteristic & 0x00000001) == 1)
  {
    TxPgn |= 0x00010000;
  }

  tPCM_EAS.DA = 0xFF;
  GetEcu61To255PGNECFFData(tPCM_EAS);

  for (loop=0;loop < (tPCM_EAS.dlc); loop++)
  {
    buffer[loop] = tPCM_EAS.byte(loop);
  }

  /* check if receiver is online */
  if (tPCM_EAS.DA != 0xFE)
  {
    retVal = J1939TxReqPG(Ecu61Handle, TxPgn, tPCM_EAS.DA, 6, tPCM_EAS.dlc, buffer);
  }
  else
  {
    retVal = kErrorCOMPartnerOffline;
  }

  /* return error code (0 = no error) */
  return retVal;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:TransmitEcu61To255PGNEEFF():*/
/*$$CANERATORBEGIN*/
/*---------------------------------------------------
  "EAS" (0x3D) sends specific PG "ACL_EAS" (0xEEFF)
  to destination addres 0xFF
---------------------------------------------------*/
DWORD TransmitEcu61To255PGNEEFF()
{
  pg Aftertreatment::ACL_EAS aCL_EAS;
  int loop;
  char buffer[8];
  DWORD TxPgn;
  DWORD retVal = 0;
  byte pduf, pdus;
  int numbOfDest=0;

  pduf = aCL_EAS.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  if ((aCL_EAS.Characteristic & 0x00000001) == 1)
  {
    TxPgn |= 0x00010000;
  }

  aCL_EAS.DA = 0xFF;
  GetEcu61To255PGNEEFFData(aCL_EAS);

  for (loop=0;loop < (aCL_EAS.dlc); loop++)
  {
    buffer[loop] = aCL_EAS.byte(loop);
  }

  /* check if receiver is online */
  if (aCL_EAS.DA == 0xFE){
    retVal = kErrorCOMPartnerOffline;
  }
  else{
    Ecu61State = kStECUOperational;
    GoOnline(Ecu61Address);
  }
  /* return error code (0 = no error) */
  return retVal;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:TransmitEcu61PGNFECB():*/
/*$$CANERATORBEGIN*/
/*-------------------------------------------------
  "EAS" (0x3D) sends global PG "DM2_EAS" (0xFECB)
-------------------------------------------------*/
DWORD TransmitEcu61PGNFECB()
{
  pg Aftertreatment::DM2_EAS dM2_EAS;
  int loop;
  char buffer[22];
  DWORD TxPgn;
  DWORD retVal = 0;
  byte pduf, pdus;

  pduf = dM2_EAS.PF;
  pdus = dM2_EAS.DA;
  TxPgn = ((pduf << 8) | pdus);

  if ((dM2_EAS.Characteristic & 0x00000001) == 1)
  {
    TxPgn |= 0x00010000;
  }

  // get the data of this PG
  GetEcu61PGNFECBData(dM2_EAS);

  for (loop=0;loop < (dM2_EAS.dlc); loop++)
  {
    buffer[loop] = dM2_EAS.byte(loop);
  }

  retVal = J1939TxReqPG(Ecu61Handle, TxPgn, 0xFF, 6, dM2_EAS.dlc, buffer);

  /* return error code (0 = no error) */
  return retVal;
}

/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:TransmitEcu61PGNFECA():*/
/*$$CANERATORBEGIN*/
/*-------------------------------------------------
  "EAS" (0x3D) sends global PG "DM1_EAS" (0xFECA)
-------------------------------------------------*/
DWORD TransmitEcu61PGNFECA()
{
  pg Aftertreatment::DM1_EAS dM1_EAS;
  int loop;
  char buffer[22];
  DWORD TxPgn;
  DWORD retVal = 0;
  byte pduf, pdus;

  pduf = dM1_EAS.PF;
  pdus = dM1_EAS.DA;
  TxPgn = ((pduf << 8) | pdus);

  if ((dM1_EAS.Characteristic & 0x00000001) == 1)
  {
    TxPgn |= 0x00010000;
  }

  // get the data of this PG
  GetEcu61PGNFECAData(dM1_EAS);

  for (loop=0;loop < (dM1_EAS.dlc); loop++)
  {
    buffer[loop] = dM1_EAS.byte(loop);
  }

  retVal = J1939TxReqPG(Ecu61Handle, TxPgn, 0xFF, 6, dM1_EAS.dlc, buffer);

  /* return error code (0 = no error) */
  return retVal;
}

/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:GetEcu61To255PGNE8FFData(pg417922877x):*/
/*$$CANERATORUSERBEGIN*/
/*--------------------------------------------------------
  Assign values to the signals of PG "ACKM_EAS" (0xE8FF)
  Note: We are working on the reference of the PG
--------------------------------------------------------*/
void GetEcu61To255PGNE8FFData(pg Aftertreatment::ACKM_EAS aCKM_EAS)
{
  int i=0;
  for (i=0;i<aCKM_EAS.dlc;i++)
  {
    aCKM_EAS.byte(i) = 0xFF;
  }
  /* the signals of PG "ACKM_EAS" */

  /* the multiplexor of this PG */
  // aCKM_EAS.ControlByte = 0;  // signal type = SPECIFIC or unknown in CANdb

  if (aCKM_EAS.ControlByte == 0)
  {
    // aCKM_EAS.AddressAcknowledged = 0;  // signal type = SPECIFIC or unknown in CANdb
  }
  else if (aCKM_EAS.ControlByte == 1)
  {
    // aCKM_EAS.AddressNegativeAcknowledgement = 0;  // signal type = SPECIFIC or unknown in CANdb
  }
  else if (aCKM_EAS.ControlByte == 2)
  {
    // aCKM_EAS.AddressAccessDenied = 0;  // signal type = SPECIFIC or unknown in CANdb
  }
  else if (aCKM_EAS.ControlByte == 3)
  {
    // aCKM_EAS.AddressBusy = 0;  // signal type = SPECIFIC or unknown in CANdb
  }
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:GetEcu61To255PGNEBFFData(pg418119485x):*/
/*$$CANERATORUSERBEGIN*/
/*--------------------------------------------------------
  Assign values to the signals of PG "TPDT_EAS" (0xEBFF)
  Note: We are working on the reference of the PG
--------------------------------------------------------*/
void GetEcu61To255PGNEBFFData(pg Aftertreatment::TPDT_EAS tPDT_EAS)
{
  int i=0;
  for (i=0;i<tPDT_EAS.dlc;i++)
  {
    tPDT_EAS.byte(i) = 0xFF;
  }
  /* the signals of PG "TPDT_EAS" */

  tPDT_EAS.SequenceNumber = 0xFF;
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:GetEcu61To255PGNECFFData(pg418185021x):*/
/*$$CANERATORUSERBEGIN*/
/*--------------------------------------------------------
  Assign values to the signals of PG "TPCM_EAS" (0xECFF)
  Note: We are working on the reference of the PG
--------------------------------------------------------*/
void GetEcu61To255PGNECFFData(pg Aftertreatment::TPCM_EAS tPCM_EAS)
{
  int i=0;
  for (i=0;i<tPCM_EAS.dlc;i++)
  {
    tPCM_EAS.byte(i) = 0xFF;
  }
  /* the signals of PG "TPCM_EAS" */

  /* the multiplexor of this PG */
  // tPCM_EAS.ControlByte = 0;  // signal type = SPECIFIC or unknown in CANdb

  if (tPCM_EAS.ControlByte == 16)
  {
    tPCM_EAS.MaximumNumberOfPackets = 0xFF;
    tPCM_EAS.TotalNumberOfPackets = 0xFF;
    tPCM_EAS.TotalMessageSize = 0xFFFF;
  }
  else if (tPCM_EAS.ControlByte == 17)
  {
    tPCM_EAS.NextPacketNumberToBeSent = 0xFF;
    tPCM_EAS.NumberOfPacketsThatCanBeSent = 0xFF;
  }
  else if (tPCM_EAS.ControlByte == 19)
  {
    tPCM_EAS.TotalNumberOfPacketsEoMA = 0xFF;
    tPCM_EAS.TotalMessageSizeEoMA = 0xFFFF;
  }
  else if (tPCM_EAS.ControlByte == 32)
  {
    tPCM_EAS.TotalMessageSizeBAM = 0xFFFF;
    tPCM_EAS.TotalNumberOfPacketsBAM = 0xFF;
  }
  else if (tPCM_EAS.ControlByte == 255)
  {
    tPCM_EAS.ConnectionAbortReason = 0xFF;
  }
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:GetEcu61To255PGNEEFFData(pg418316093x):*/
/*$$CANERATORUSERBEGIN*/
/*-------------------------------------------------------
  Assign values to the signals of PG "ACL_EAS" (0xEEFF)
  Note: We are working on the reference of the PG
-------------------------------------------------------*/
void GetEcu61To255PGNEEFFData(pg Aftertreatment::ACL_EAS aCL_EAS)
{
  int i=0;
  for (i=0;i<aCL_EAS.dlc;i++)
  {
    aCL_EAS.byte(i) = 0xFF;
  }
  /* the signals of PG "ACL_EAS" */

  // aCL_EAS.ArbitraryAddressCapable = 0;  // signal type = SPECIFIC or unknown in CANdb
  // aCL_EAS.IndustryGroup = 0;  // signal type = SPECIFIC or unknown in CANdb
  // aCL_EAS.VehicleSystemInstance = 0;  // signal type = SPECIFIC or unknown in CANdb
  // aCL_EAS.VehicleSystem = 0;  // signal type = SPECIFIC or unknown in CANdb
  // aCL_EAS.Function = 0;  // signal type = SPECIFIC or unknown in CANdb
  // aCL_EAS.FunctionInstance = 0;  // signal type = SPECIFIC or unknown in CANdb
  // aCL_EAS.ECUInstance = 0;  // signal type = SPECIFIC or unknown in CANdb
  // aCL_EAS.ManufacturerCode = 0;  // signal type = SPECIFIC or unknown in CANdb
  // aCL_EAS.IdentityNumber = 0;  // signal type = SPECIFIC or unknown in CANdb
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:GetEcu61PGNFF01Data(pg419365181x):*/
/*$$CANERATORUSERBEGIN*/
/*----------------------------------------------------------
  Assign values to the signals of PG "PROB_2_EAS" (0xFF01)
  Note: We are working on the reference of the PG
----------------------------------------------------------*/
void GetEcu61PGNFF01Data(pg Aftertreatment::PROB_2_EAS pROB_2_EAS)
{
  int i=0;
  for (i=0;i<pROB_2_EAS.dlc;i++)
  {
    pROB_2_EAS.byte(i) = 0xFF;
  }
  /* signals for PG "PROB_2_EAS" */
  pROB_2_EAS.ActualTransitionState.phys = gActualTransitionState;  // signal type = SPECIFIC or unknown in CANdb
  pROB_2_EAS.ActualMachineState.phys = gActualMachineState;  // signal type = SPECIFIC or unknown in CANdb
  pROB_2_EAS.ActualDosingQuantity.phys = gActualDosingQuantity;  // signal type = SPECIFIC or unknown in CANdb
  pROB_2_EAS.ReductionFluidTankTemperature.phys = gReductionFluidTankTemperature;  // signal type = SPECIFIC or unknown in CANdb
  pROB_2_EAS.ReductionFluidTankLevel.phys = gReductionFluidTankLevel;  // signal type = SPECIFIC or unknown in CANdb
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:GetEcu61PGNFF00Data(pg419364925x):*/
/*$$CANERATORUSERBEGIN*/
/*----------------------------------------------------------
  Assign values to the signals of PG "PROB_1_EAS" (0xFF00)
  Note: We are working on the reference of the PG
----------------------------------------------------------*/
void GetEcu61PGNFF00Data(pg Aftertreatment::PROB_1_EAS pROB_1_EAS)
{
  int i=0;
  for (i=0;i<pROB_1_EAS.dlc;i++)
  {
    pROB_1_EAS.byte(i) = 0xFF;
  }
  /* signals for PG "PROB_1_EAS" */
  pROB_1_EAS.ReductionFluidPressure.phys = gReductionFluidPressure;  // signal type = SPECIFIC or unknown in CANdb
  pROB_1_EAS.CatalystUpstreamTemperature.phys = gCatalystUpstreamTemperature;  // signal type = SPECIFIC or unknown in CANdb
  pROB_1_EAS.CatalystDownstreamTemperature.phys = gCatalystDownstreamTemperature;  // signal type = SPECIFIC or unknown in CANdb
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:GetEcu61PGNFECBData(pg419351357x):*/
/*$$CANERATORUSERBEGIN*/
/*-------------------------------------------------------
  Assign values to the signals of PG "DM2_EAS" (0xFECB)
  Note: We are working on the reference of the PG
-------------------------------------------------------*/
void GetEcu61PGNFECBData(pg Aftertreatment::DM2_EAS dM2_EAS)
{
  DWORD fmi;
  
  /* Reset old data */
  int i = 0;
  for (i = 0; i < dM2_EAS.dlc; i++)
  {
    dM2_EAS.byte(i) = 0xFF;
  }

  dM2_EAS.byte(0) = 0x00;
  dM2_EAS.byte(1) = 0x00;
      
  /* signals for PG "DM2_EAS" */
  gPreviousActiveCount = 0;
  dM2_EAS.DLC  = 1785;
  
  /* Search in table for active DTCs */
  for( i = 0; i < elCount(gDTCPreviousTable); i++ ) 
  {
    if (gDTCPreviousTable[i] != 0) 
    {
      dM2_EAS.byte(2+gPreviousActiveCount*4)   = (gDTCPreviousTable[i]      ) & 0xff;
      dM2_EAS.byte(2+gPreviousActiveCount*4+1) = (gDTCPreviousTable[i] >>  8) & 0xff;
      dM2_EAS.byte(2+gPreviousActiveCount*4+2) = (gDTCPreviousTable[i] >> 16) & 0xff;
      dM2_EAS.byte(2+gPreviousActiveCount*4+3) = (gDTCPreviousTable[i] >> 24) & 0xff;
      gPreviousActiveCount++;

      fmi = (gDTCPreviousTable[i] >> 16) & 0x1f;
      switch(fmi) 
      {
        case kFMI_AboveNormal:
        case kFMI_BelowNormal:
          if (dM2_EAS.AmberWarningLampStatus == 0) 
          {
            dM2_EAS.AmberWarningLampStatus = 0x01;
          }
          break;
        case kFMI_CauseUnknown:
          if (dM2_EAS.MalfunctionIndicatorLampStatus == 0) 
          {
            dM2_EAS.MalfunctionIndicatorLampStatus  = 0x01;
            dM2_EAS.FlashMalfuncIndicatorLamp       = 0x00;
          }
          break;
        default:
          if (dM2_EAS.RedStopLampState == 0) 
          {
            dM2_EAS.RedStopLampState = 0x01;
            dM2_EAS.FlashRedStopLamp = 0x01;
          }
          break;
      }
    }
  }

  /* DTCs found set Data length */
  if (gPreviousActiveCount > 0)
  {
    dM2_EAS.dlc = 2 + gPreviousActiveCount * 4;
  }
  /* No DTCs found set Dummy message */
  else
  {
    dM2_EAS.byte(0)  = 0x00;
    dM2_EAS.byte(1)  = 0x00;
    dM2_EAS.dword(2) = 0xffffffff;
    dM2_EAS.dlc      = 0x06;
  }
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:GetEcu61PGNFECAData(pg419351101x):*/
/*$$CANERATORUSERBEGIN*/
/*-------------------------------------------------------
  Assign values to the signals of PG "DM1_EAS" (0xFECA)
  Note: We are working on the reference of the PG
-------------------------------------------------------*/
void GetEcu61PGNFECAData(pg Aftertreatment::DM1_EAS dM1_EAS)
{
  DWORD fmi;
  
  /* Reset old data */
  int i = 0;
  for (i = 0; i < dM1_EAS.dlc; i++)
  {
    dM1_EAS.byte(i) = 0xFF;
  }

  dM1_EAS.byte(0) = 0x00;
  dM1_EAS.byte(1) = 0x00;
      
  /* signals for PG "DM1_EAS" */
  gActiveCount = 0;
  dM1_EAS.DLC  = 1785;
  
  /* Search in table for active DTCs */
  for( i = 0; i < elCount(gDTCActiveTable); i++ ) 
  {
    if (gDTCActiveTable[i] != 0) 
    {
      dM1_EAS.byte(2+gActiveCount*4)   = (gDTCActiveTable[i]      ) & 0xff;
      dM1_EAS.byte(2+gActiveCount*4+1) = (gDTCActiveTable[i] >>  8) & 0xff;
      dM1_EAS.byte(2+gActiveCount*4+2) = (gDTCActiveTable[i] >> 16) & 0xff;
      dM1_EAS.byte(2+gActiveCount*4+3) = (gDTCActiveTable[i] >> 24) & 0xff;
      gActiveCount++;

      fmi = (gDTCActiveTable[i] >> 16) & 0x1f;
      switch(fmi) 
      {
        case kFMI_AboveNormal:
        case kFMI_BelowNormal:
          if (dM1_EAS.AmberWarningLampStatus == 0) 
          {
            dM1_EAS.AmberWarningLampStatus = 0x01;
          }
          break;
        case kFMI_CauseUnknown:
          if (dM1_EAS.MalfunctionIndicatorLampStatus == 0) 
          {
            dM1_EAS.MalfunctionIndicatorLampStatus  = 0x01;
            dM1_EAS.FlashMalfuncIndicatorLamp       = 0x00;
          }
          break;
        default:
          if (dM1_EAS.RedStopLampState == 0) 
          {
            dM1_EAS.RedStopLampState = 0x01;
            dM1_EAS.FlashRedStopLamp = 0x01;
          }
          break;
      }
    }
  }

  /* DTCs found set Data length */
  if (gActiveCount > 0)
  {
    dM1_EAS.dlc = 2 + gActiveCount * 4;
    if (dM1_EAS.dlc < 8)
      dM1_EAS.dlc = 8;
  }
  /* No DTCs found set Dummy message */
  else
  {
    dM1_EAS.byte(0)  = 0x00;
    dM1_EAS.byte(1)  = 0xFF;
    dM1_EAS.byte(2)  = 0x00;
    dM1_EAS.byte(3)  = 0x00;
    dM1_EAS.byte(4)  = 0x00;
    dM1_EAS.byte(5)  = 0x00;
    dM1_EAS.byte(6)  = 0xFF;
    dM1_EAS.byte(7)  = 0xFF;
    dM1_EAS.dlc      = 0x08;
  }
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:J1939AppTxIndication(long,long,long,long):*///callback
/*$$CANERATORBEGIN*/
/*-----------------------------------------------------------
  -- Callback function --

  Callback function is called if a PG is sent successfully.
-----------------------------------------------------------*/
DWORD J1939AppTxIndication (long ecuhdl,long TxPgn, long src, long dest)
{
  char buffer[8];
  //PGs for default

/*$$USERAREA_J1939TXINDIBEGIN*/
// insert your application code here
/*$$USERAREA_J1939TXINDIEND*/

  if (TxPgn == 0xFF01)    // PROB_2_EAS
  {
    if (ecuhdl == Ecu61Handle)
    {
      cancelTimer(TimerEcu61PGNFF01);
      setTimer(TimerEcu61PGNFF01,gCycleTime61PGNFF01);
    }
  }
  if (TxPgn == 0xFF00)    // PROB_1_EAS
  {
    if (ecuhdl == Ecu61Handle)
    {
      cancelTimer(TimerEcu61PGNFF00);
      setTimer(TimerEcu61PGNFF00,gCycleTime61PGNFF00);
    }
  }
  return 0;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:J1939AppRxIndication(long,long,long,long,long):*///callback
/*$$CANERATORBEGIN*/
/*--------------------------------------------------
  -- Callback function --

  Callback function is called if a PG is received.
--------------------------------------------------*/
DWORD J1939AppRxIndication (long ecuhdl, long source, long dest, long length, long RxPG)
{
  char buffer[1785];
  int loop;
  pg 0x00 dummy = {dlc=1785,dp=0};

/*$$USERAREA_J1939RXINDIBEGIN*/
// insert your application code here
/*$$USERAREA_J1939RXINDIEND*/

  dummy.dlc = length;            // set dlc
  dummy.pgn = RxPG;              // set PGN
  if (RxPG & 0x10000)
  {
    dummy.Characteristic = 0x1;  // set DP=1
  }
  else
  {
    dummy.Characteristic = 0x0;  // set DP=0
  }

  J1939GetRxData(length, buffer);

  // copy received data to pg
  for (loop=0;loop < length; loop++)
  {
    dummy.byte(loop) = buffer[loop];
  }

  // update the addresses of the receivers
  if (RxPG == 0xEE00)
  {
  }

  // ATO1_EMS
  if ((RxPG == 0xF00F) && (ecuhdl == Ecu61Handle) && (source == Receiver0Address) && (dest == 0xFF))
  {
    RxIndFromEcu0To255PGNF00F (ecuhdl, source, dest, length, (pg Aftertreatment::ATO1_EMS)dummy);
  }
  // ET1_EMS
  if ((RxPG == 0xFEEE) && (ecuhdl == Ecu61Handle) && (source == Receiver0Address) && (dest == 0xFF))
  {
    RxIndFromEcu0To255PGNFEEE (ecuhdl, source, dest, length, (pg Aftertreatment::ET1_EMS)dummy);
  }
  // AMB_EMS
  if ((RxPG == 0xFEF5) && (ecuhdl == Ecu61Handle) && (source == Receiver0Address) && (dest == 0xFF))
  {
    RxIndFromEcu0To255PGNFEF5 (ecuhdl, source, dest, length, (pg Aftertreatment::AMB_EMS)dummy);
  }
  // PROA_1_EMS
  if ((RxPG == 0xEF00) && (ecuhdl == Ecu61Handle) && (source == Receiver0Address) && (dest == Receiver61Address))
  {
    RxIndFromEcu0To61PGNEF3D (ecuhdl, source, dest, length, (pg Aftertreatment::PROA_1_EMS)dummy);
  }
  // EEC1_EMS
  if ((RxPG == 0xF004) && (ecuhdl == Ecu61Handle) && (source == Receiver0Address) && (dest == 0xFF))
  {
    RxIndFromEcu0To255PGNF004 (ecuhdl, source, dest, length, (pg Aftertreatment::EEC1_EMS)dummy);
  }
  return 0;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:RxIndFromEcu0To255PGNF00F(long,long,long,long,pg418385664x):*/
/*$$CANERATORUSERBEGIN*/
/*-----------------------------------------------------
  "EAS" (0x3D) receives global PG "ATO1_EMS" (0xF00F)
-----------------------------------------------------*/
void RxIndFromEcu0To255PGNF00F (long ecuhdl, long source, long dest, long length, pg Aftertreatment::ATO1_EMS aTO1_EMS)
{
  // TODO: insert application here

}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:RxIndFromEcu0To255PGNFEEE(long,long,long,long,pg419360256x):*/
/*$$CANERATORUSERBEGIN*/
/*----------------------------------------------------
  "EAS" (0x3D) receives global PG "ET1_EMS" (0xFEEE)
----------------------------------------------------*/
void RxIndFromEcu0To255PGNFEEE (long ecuhdl, long source, long dest, long length, pg Aftertreatment::ET1_EMS eT1_EMS)
{
  // TODO: insert application here

}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:RxIndFromEcu0To255PGNFEF5(long,long,long,long,pg419362048x):*/
/*$$CANERATORUSERBEGIN*/
/*----------------------------------------------------
  "EAS" (0x3D) receives global PG "AMB_EMS" (0xFEF5)
----------------------------------------------------*/
void RxIndFromEcu0To255PGNFEF5 (long ecuhdl, long source, long dest, long length, pg Aftertreatment::AMB_EMS aMB_EMS)
{
  // TODO: insert application here

}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:RxIndFromEcu0To61PGNEF3D(long,long,long,long,pg217005312x):*/
/*$$CANERATORUSERBEGIN*/
/*---------------------------------------------------------
  "EAS" (0x3D) receives specific PG "PROA_1_EMS" (0xEF3D)
  from sender "EMS" (0x0)
---------------------------------------------------------*/
void RxIndFromEcu0To61PGNEF3D (long ecuhdl, long source, long dest, long length, pg Aftertreatment::PROA_1_EMS pROA_1_EMS)
{
  // TODO: insert application here
  gRequestedDosingQuantity = pROA_1_EMS.RequestedUreaQuantity.phys;
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:RxIndFromEcu0To255PGNF004(long,long,long,long,pg217056256x):*/
/*$$CANERATORUSERBEGIN*/
/*-----------------------------------------------------
  "EAS" (0x3D) receives global PG "EEC1_EMS" (0xF004)
-----------------------------------------------------*/
void RxIndFromEcu0To255PGNF004 (long ecuhdl, long source, long dest, long length, pg Aftertreatment::EEC1_EMS eEC1_EMS)
{
  // TODO: insert application here
  gEngineSpeed        = eEC1_EMS.EngSpeed.phys;
  gActualEngineTorque = eEC1_EMS.ActualEngPercentTorque.phys;
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:J1939AppRequestIndication(long,long,long,long,long):*///callback
/*$$CANERATORBEGIN*/
/*----------------------------------------------------------
  -- Callback function --

  Callback function is called if a request PG is received.
----------------------------------------------------------*/
DWORD J1939AppRequestIndication (long ecuhdl, long source, long dest, long page, long ReqPgn)
{
  pg  0xE800x acknPg;
  int broadcastFlag;
  int notAckFlag;
  int loop;
  long mpgn;
  int responseAddr;
  char buffer[8];
  broadcastFlag=0;
  notAckFlag=1;

/*$$USERAREA_J1939REQINDIBEGIN*/
// insert your application code here
/*$$USERAREA_J1939REQINDIEND*/

  // check if requested pg is specific or global
  if (dest == 0xFF)
  {
    responseAddr=0xFF;
    broadcastFlag=1;
  }
  else
  {
    responseAddr=source;
    broadcastFlag=0;
  }

    if (ReqPgn == 0xEE00)
    {
      if (ecuhdl == Ecu61Handle)
      {
        if (dest == 0xFF)
        {
          TransmitEcu61To255PGNEEFF();
          notAckFlag=0;
        }
      }
    }
    if (ReqPgn == 0xE800)
    {
      if (ecuhdl == Ecu61Handle)
      {
        if (dest == 0xFF)
        {
          TransmitEcu61To255PGNE8FF();
          notAckFlag=0;
        }
      }
    }
    if (ReqPgn == 0xEB00)
    {
      if (ecuhdl == Ecu61Handle)
      {
        if (dest == 0xFF)
        {
          TransmitEcu61To255PGNEBFF();
          notAckFlag=0;
        }
      }
    }
    if (ReqPgn == 0xEC00)
    {
      if (ecuhdl == Ecu61Handle)
      {
        if (dest == 0xFF)
        {
          TransmitEcu61To255PGNECFF();
          notAckFlag=0;
        }
      }
    }
    if (ReqPgn == 0xFF01)
    {
      if (ecuhdl == Ecu61Handle)
      {
        TransmitEcu61PGNFF01();
        notAckFlag=0;
      }
    }
    if (ReqPgn == 0xFF00)
    {
      if (ecuhdl == Ecu61Handle)
      {
        TransmitEcu61PGNFF00();
        notAckFlag=0;
      }
    }
    if (ReqPgn == 0xFECB)
    {
      if (ecuhdl == Ecu61Handle)
      {
        TransmitEcu61PGNFECB();
        notAckFlag=0;
      }
    }
    if (ReqPgn == 0xFECA)
    {
      if (ecuhdl == Ecu61Handle)
      {
        TransmitEcu61PGNFECA();
        notAckFlag=0;
      }
    }

  if ((notAckFlag) && (!broadcastFlag))
  {
    // set reserved byte to 0xFF
    for (loop=0;loop < 8; loop++)
    {
      acknPg.byte(loop) = 0xFF;
    }

    acknPg.byte(0)=1;       // not ack
    acknPg.byte(5)=ReqPgn & 0xFF;
    acknPg.byte(6)=(ReqPgn & 0xFF00)>>8;
    acknPg.byte(7)=(ReqPgn & 0xFF0000)>>16;

    for (loop=0;loop < 8; loop++)
    {
      buffer[loop] = acknPg.byte(loop);
    }
    mpgn = ((acknPg.PF <<8) | 0xFF);

    J1939TxReqPG(ecuhdl, mpgn, 0xFF,6,8,buffer);
  }
  return 0;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:J1939AppErrorIndication(long,long,long,long):*///callback
/*$$CANERATORUSERBEGIN*/
/*-------------------------------------------------------------
  -- Callback function --

  Callback function is called if nodelayer detected an error.
-------------------------------------------------------------*/
DWORD J1939AppErrorIndication(long ecuhdl, long errorClass, long errorNumber, long addCode)
{
  write ("ERROR: The CALLBACK function J1939AppErrorIndication received an error....");
  write ("       (caused by node with address %i)",J1939GetNodeAddr(ecuhdl));
  
  if (errorClass==0)   // API error
  {
    write("       API error: ");
    write("       Program will be stopped!");
    stop(); // remove this line if evaluating errors below
    switch(errorNumber)
    {
      case 0x1: // Is not allowed to call this function from a callback
      {
        write("       -> Is not allowed to call this function from a callback");
        break;
      }
      case 0x2: // Invalid Handle
      {
        write("       -> Invalid Handle");
        break;
      }
      case 0x4: // Invalid Parameter
      {
        write("       -> Invalid Parameter");
        break;
      }
      case 0x5: // Request cannot be sent
      {
        write("       -> Request cannot be sent");
        break;
      }
      case 0x6: // Unknown Environment Variable
      {
        write("       -> Unknown Environment Variable");
        break;
      }
      case 0x7: // Wrong Environment Variable Type
      {
        write("       -> Wrong Environment Variable Type");
        break;
      }
      case 0x8: // Parameter exceeds range
      {
        write("       -> Parameter exceeds range");
        break;
      }
      case 0x80: // Internal Error
      {
        write("       -> Internal Error");
        break;
      }
      case 0x100: // General Error
      {
        write("       -> General Error");
        break;
      }
      case 0x201: // Unknown bus name
      {
        write("       -> Unknown bus name");
        break;
      }
      case 0x202: // ECU is offline
      {
        write("       -> ECU is offline");
        break;
      }
      case 0x203: // Invalid address
      {
        write("       -> Invalid address");
        break;
      }
      default:
      {
        write("       -> An error occured, but the error is not handeled in the AppErrorIndication function");
        break;
      }
    }
  }
  else if (errorClass==1)   // timeout errors
  {
    write("       Timeout error: ");
    write("       Program will be stopped!");
    stop(); // remove this line if evaluating errors below
    switch(errorNumber)
    {
      case 0x1: // CTS error - There was no CTS for an RTS
      {
        write("       -> CTS error - There was no CTS for an RTS");
        break;
      }
      case 0x2: // peer to peer data timeout
      {
        write("       -> 	Data received after a timeout for a peer-to-peer connection");
        break;
      }
      case 0x3: // BAM data timeout
      {
        write("       -> Data received in the timeout during a BAM");
        break;
      }
      case 0x4: // An EndOfMessage Acknowledge is missing or was received too late
      {
        write("       -> An EndOfMessage Acknowledge is missing or was received too late");
        break;
      }
      default:
      {
        write("       -> An error occured, but the error is not handeled in the AppErrorIndication function");
        break;
      }
    }
  }
  else if (errorClass==2) // address claiming errors
  {
    write("       Address claiming error: ");
    switch(errorNumber)
    {
      case 0x10: // node detected higher prior node
      {
        SetRetryTimer(ecuhdl);
        break;
      }
      case 0x15: // Initialization error: ECU name was assigned twice
      {
        write("       -> Initialization error: ECU name was assigned twice");
        break;
      }
      case 0x17: // Initialization error: ECU address was assigned twice
      {
        write("       -> Initialization error: ECU address was assigned twice");
        break;
      }
      default:
      {
        write("       -> An error occured, but the error is not handeled in the AppErrorIndication function");
        break;
      }
    }
  }
  else if (errorClass==3) // CAN transmission error
  {
    // not supported in nodelayer version 3.x
  }
  else if (errorClass==4) // system errors
  {
    write("       System error: ");
    switch(errorNumber)
    {
      case 0x30: // 	Exception during protocol selection of BAM or CMDT
      {
        write("       -> 	Exception during protocol selection of BAM or CMDT");
        break;
      }
      case 0x40: // 	Internal data buffer occupied
      {
        write("       -> Internal data buffer occupied");
        break;
      }
      case 0x60: // User is sending a System PG via the CAPL interface 
      {
        write("       -> User is sending a System PG via the CAPL interface");
        break;
      }
      default:
      {
        write("       -> An error occured, but the error is not handeled in the AppErrorIndication function");
        break;
      }
    }
  }
  else if (errorClass==5) // errors at transport protocol
  {
    write("       Error at transport protocol: ");
    switch(errorNumber)
    {
      case 0x71: // A transfer with the transfer protocol was interrupted by the receiver (addCode receives the PGN)
      {
        // addCode contains pgn
        write("       -> A transfer with the transfer protocol was interrupted by the receiver (addCode receives the PGN)");
        break;
      }
      case 0x72: // A transfer with the transfer protocol was interrupted by the sender (addCode receives the PGN)
      {
        // addCode contains pgn
        write("       -> A transfer with the transfer protocol was interrupted by the sender (addCode receives the PGN)");
        break;
      }
      default:
      {
        write("       -> An error occured, but the error is not handeled in the AppErrorIndication function");
        break;
      }
    }
  }

  return 0;
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:J1939AppNmtIndication(long,long,long):*///callback
/*$$CANERATORUSERBEGIN*/
/*---------------------------------------------------------------------------
  -- Callback function --

  Callback function is called if nodelayer detected an Address Claiming PG.
---------------------------------------------------------------------------*/
DWORD J1939AppNmtIndication(LONG busHandle, LONG address, LONG state)
{
  char deviceName[8];
  J1939GetRxData( 8, deviceName );

  UpdateReceiverAddresses();

  switch(state)
  {
    case 0: // ECU begins claiming

      break;
    case 2: // ECU successfully claimed an address
      
      // update the flags for the members of a Working Set
      AllowClaimAddress(deviceName);
      break;
    case 3: // ECU lost its address

      break;
  }
  return 0;
}
/*$$CANERATORUSEREND*/
/*@@end*/

/*@@caplFunc:SendReqFrom61To0ForPGNF00F():*/
/*$$CANERATORBEGIN*/
/*----------------------------------------------------------------
  "EAS" (0x3D) sends a Request for global PG "ATO1_EMS" (0xF00F)
----------------------------------------------------------------*/
void SendReqFrom61To0ForPGNF00F(void)
{
  pg 0xEA00x rqstPGN = {dlc=3};
  int loop;
  char buffer[8];
  word TxPgn;
  byte pduf, pdus;

  pduf = rqstPGN.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  rqstPGN.byte(0) = 0xf;
  rqstPGN.byte(1) = 0xf0;
  rqstPGN.byte(2) = 0x0;

  for (loop=0;loop < (rqstPGN.dlc); loop++)
  {
    buffer[loop] = rqstPGN.byte(loop);
  }

  J1939TxReqPG(Ecu61Handle, TxPgn, 0xFF, 0, rqstPGN.dlc, buffer);

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:SendReqFrom61To0ForPGNFEEE():*/
/*$$CANERATORBEGIN*/
/*---------------------------------------------------------------
  "EAS" (0x3D) sends a Request for global PG "ET1_EMS" (0xFEEE)
---------------------------------------------------------------*/
void SendReqFrom61To0ForPGNFEEE(void)
{
  pg 0xEA00x rqstPGN = {dlc=3};
  int loop;
  char buffer[8];
  word TxPgn;
  byte pduf, pdus;

  pduf = rqstPGN.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  rqstPGN.byte(0) = 0xee;
  rqstPGN.byte(1) = 0xfe;
  rqstPGN.byte(2) = 0x0;

  for (loop=0;loop < (rqstPGN.dlc); loop++)
  {
    buffer[loop] = rqstPGN.byte(loop);
  }

  J1939TxReqPG(Ecu61Handle, TxPgn, 0xFF, 0, rqstPGN.dlc, buffer);

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:SendReqFrom61To0ForPGNFEF5():*/
/*$$CANERATORBEGIN*/
/*---------------------------------------------------------------
  "EAS" (0x3D) sends a Request for global PG "AMB_EMS" (0xFEF5)
---------------------------------------------------------------*/
void SendReqFrom61To0ForPGNFEF5(void)
{
  pg 0xEA00x rqstPGN = {dlc=3};
  int loop;
  char buffer[8];
  word TxPgn;
  byte pduf, pdus;

  pduf = rqstPGN.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  rqstPGN.byte(0) = 0xf5;
  rqstPGN.byte(1) = 0xfe;
  rqstPGN.byte(2) = 0x0;

  for (loop=0;loop < (rqstPGN.dlc); loop++)
  {
    buffer[loop] = rqstPGN.byte(loop);
  }

  J1939TxReqPG(Ecu61Handle, TxPgn, 0xFF, 0, rqstPGN.dlc, buffer);

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:SendReqFrom61To0ForPGNEF3D():*/
/*$$CANERATORBEGIN*/
/*--------------------------------------------------------------------
  "EAS" (0x3D) sends a Request for specific PG "PROA_1_EMS" (0xEF3D)
  to receiver "EMS" (0x0)
--------------------------------------------------------------------*/
void SendReqFrom61To0ForPGNEF3D(void)
{
  pg 0xEA00x rqstPGN = {dlc=3};
  int loop;
  char buffer[8];
  word TxPgn;
  byte pduf, pdus;

  pduf = rqstPGN.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  rqstPGN.byte(0) = 0x0;
  rqstPGN.byte(1) = 0xef;
  rqstPGN.byte(2) = 0x0;

  for (loop=0;loop < (rqstPGN.dlc); loop++)
  {
    buffer[loop] = rqstPGN.byte(loop);
  }

  UpdateReceiverAddresses();
  if (Receiver0Address < 0xFE)
  {
    J1939TxReqPG(Ecu61Handle, TxPgn, Receiver0Address, 0, rqstPGN.dlc, buffer);
  }

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:SendReqFrom61To0ForPGNF004():*/
/*$$CANERATORBEGIN*/
/*----------------------------------------------------------------
  "EAS" (0x3D) sends a Request for global PG "EEC1_EMS" (0xF004)
----------------------------------------------------------------*/
void SendReqFrom61To0ForPGNF004(void)
{
  pg 0xEA00x rqstPGN = {dlc=3};
  int loop;
  char buffer[8];
  word TxPgn;
  byte pduf, pdus;

  pduf = rqstPGN.PF;
  pdus = 0;
  TxPgn = ((pduf << 8) | pdus);

  rqstPGN.byte(0) = 0x4;
  rqstPGN.byte(1) = 0xf0;
  rqstPGN.byte(2) = 0x0;

  for (loop=0;loop < (rqstPGN.dlc); loop++)
  {
    buffer[loop] = rqstPGN.byte(loop);
  }

  J1939TxReqPG(Ecu61Handle, TxPgn, 0xFF, 0, rqstPGN.dlc, buffer);

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:J1939AppCmdAddrIndication(long,long):*///callback
/*$$CANERATORBEGIN*/
/*--------------------------------------------------------------------
  -- Callback function --

  Callback function is called if a commanded address PG is received.
--------------------------------------------------------------------*/
DWORD J1939AppCmdAddrIndication(long ecuhdl,long length)
{
  char buffer[9];

  // get new address
  J1939GetRxData(9, buffer);

/*$$USERAREA_J1939APPCMDADDRINDICATIONBEGIN*/
// insert your application code here
/*$$USERAREA_J1939APPCMDADDRINDICATIONIEND*/

  if (((BYTE)buffer[7]) & 0x80)
  {
    // go online with new address
    J1939ECUGoOnline(ecuhdl, buffer[8]);

    if (ecuhdl == Ecu61Handle)
      Ecu61Address = buffer[8];
  }

  return 0;
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:RetryEcu61GoOnline():*/
/*$$CANERATORBEGIN*/
/*--------------------------------------------------------------------
  Function retries to go online with a address of the address range.
--------------------------------------------------------------------*/
void RetryEcu61GoOnline()
{
  int freeAddressFlag=1;
  char name[8];
  freeAddressFlag=1;
  Ecu61Address = 128;
  // check for next free address
  while ( J1939GetName(BusName,Ecu61Address,name) == 0)
  {
    Ecu61Address++;
    if (Ecu61Address >= 253)
    {
      freeAddressFlag = 0;
      break;
    }
  }
  if (freeAddressFlag)
  {
    J1939ECUGoOnline(Ecu61Handle, Ecu61Address);
  }
  else
  {
    J1939ECUGoOffline(Ecu61Handle);
  }
}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:SetRetryTimer(long):*/
/*$$CANERATORBEGIN*/
/*----------------------------------
  Function starts an update timer.
----------------------------------*/
void SetRetryTimer(long ecuHdl)
{
  if (ecuHdl == Ecu61Handle)
  {
    J1939UpdateTable(BusName);
    setTimer(TimerRetryEcuBootup61,1250);
  }

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:UpdateReceiverAddresses():*/
/*$$CANERATORBEGIN*/
/*-----------------------------------------------------------------------------------------------
  The variables "Receiver<EcuHandle>Address" contain the actual network addresses of the nodes.
  Call this function to update the values of the variables.
-----------------------------------------------------------------------------------------------*/
void UpdateReceiverAddresses()
{
  Receiver0Address = J1939GetAddress(BusName,gMask0,Ecu0Name);
  Receiver61Address = J1939GetAddress(BusName,gMask61,Ecu61Name);

/*$$USERAREA_AftertreatmentUPDATERECADDRBEGIN*/
  // insert your application code here
/*$$USERAREA_AftertreatmentUPDATERECADDREND*/

}
/*$$CANERATOREND*/
/*@@end*/

/*@@caplFunc:AllowClaimAddress(char[]):*/
/*$$CANERATORBEGIN*/
/*------------------------------------------
  Function checks in case of a Working Set
  if the node is allowed to go online.
------------------------------------------*/
void AllowClaimAddress(char ecuName[])
{
  long address;
  int i;
  int isBootMaster;
  int ecuFoundFlag;
  
/*$$USERAREA_AftertreatmentALLOWADCBEGIN*/
  // insert your application code here
/*$$USERAREA_AftertreatmentALLOWADCEND*/

}
/*$$CANERATOREND*/
/*@@end*/

/*@@timer:SystemTimer:*/
on timer SystemTimer
{
  
  CalcCatUpstreamTemperature();
  CalcCatDownstreamTemperature();
  CalcActualDosingQuantity();
  CalcReductionFluidTankLevel();
  CalcReductionFluidPressure();
 
  setTimer(SystemTimer, kSystemTime); 
}
/*@@end*/

/*@@caplFunc:LimitGovernor(float,float,float):*///function
float LimitGovernor (float value, float min, float max)
{
  if (value < min) return min;
  if (value > max) return max;

  return value;
}
/*@@end*/

/*@@timer:DM1Timer:*/
/*
 * Send diagnostic PG DM1 (active diagnostic trouble codes)
 */
on timer DM1Timer
{
  
  TransmitEcu61PGNFECA();

  setTimer( DM1Timer, 1 );

  /*
  if (gActiveCount > 0) {
    gDTCActive = 1;
    setTimer( DM1Timer, 1 );
  }
  else 
  {
    gDTCActive = 0;
  }
  */
}
/*@@end*/

/*@@caplFunc:DtcActivate(dword,dword):*///function
/* Activate a DTC (diagnostic trouble code)          */
/* spn - Suspect Parameter Number                    */
/* fmi - Failure Mode Indentifier                    */
void DtcActivate( DWORD spn, DWORD fmi )
{
  DtcUpdateTable( gDTCActiveTable  , 0, spn, fmi );
  DtcUpdateTable( gDTCPreviousTable, 0, spn, fmi );

  /* send immediately a DM1 message */
  if (gDTCActive == 0) {
    gDTCActive = 1;
  }
  //setTimer( DM1Timer, 0 );
}
/*@@end*/

/*@@caplFunc:DtcDeactivate(dword,dword):*///function
/*---------------------------------------------------*/
/* Deactivate a DTC (diagnostic trouble code)        */
/* spn - Suspect Parameter Number                    */
/* fmi - Failure Mode Indentifier                    */
void DtcDeactivate( DWORD spn, DWORD fmi )
{
  DtcUpdateTable( gDTCActiveTable     , 1, spn, fmi );
}
/*@@end*/

/*@@caplFunc:DtcUpdateTable(dword[],int,dword,dword):*///function
/* Update a DTC table (diagnostic trouble code)      */
/* table  - the table to update                      */
/* remove - 1 = remove DTC, 0 = set DTC              */
/* spn    - Suspect Parameter Number                 */
/* fmi    - Failure Mode Indentifier                 */
void DtcUpdateTable( DWORD table[], int remove, DWORD spn, DWORD fmi )
{
  DWORD oc, i;
  BYTE  found;

  if (remove == 1) 
  {
    // search for SPN and FMI in gDTCActiveTable
    for( i = 0; i < elCount(table); i++ ) 
    {
      if ((table[i] & 0xffffff) == ((spn & 0xffff) | ((spn & 0x70000) << 5) | ((fmi & 0x1f) << 16))) 
      {
        // we found the entry, now we set the entry to 0
        table[i] = 0;
        break;
      }
    }
  }
  else 
  {
    // search for SPN and FMI in gDTCActiveTable
    found = 0;
    for( i = 0; i < elCount(table); i++ ) 
    {
      if ((table[i] & 0xffffff) == ((spn & 0xffff) | ((spn & 0x70000) << 5) | ((fmi & 0x1f) << 16))) 
      {
        // we found the entry, now we increase the occurence counter
        oc = ((table[i] >> 24) & 0x7f);
        oc++;
        table[i] &= 0x80ffffff;
        table[i] |= (oc << 24);
        found = 1;
        break;
      }
    }

    // if SPN and FMI was not found add a new entry to the table
    if (found == 0) 
    {
      for( i = 0; i < elCount(table); i++ ) 
      {
        if (table[i] == 0) 
        {
          oc = 1;
          table[i] = (spn & 0xffff) | ((spn & 0x70000) << 5) | ((fmi & 0x1f) << 16) | ((oc & 0x7f) << 24);
          break;
        }
      }
    }
  }
}
/*@@end*/

/*@@envVar:envEASDownstreamCatalystError:*/
/*
 * Active DTC for Transmission gear signal.
 */
on envVar envEASDownstreamCatalystError
{
  if (getValue(this) == 1) {
    DtcActivate( 520192, kFMI_BelowNormal );
  }
  else {
    DtcDeactivate( 520192, kFMI_BelowNormal );
  }
}
/*@@end*/

/*@@envVar:envEASUpstreamCatalystError:*/
/*
 * Active DTC for Upstream Catalyst Sensor.
 */
on envVar envEASUpstreamCatalystError
{
  if (getValue(this) == 1) 
  {
    DtcActivate( 520193, kFMI_AboveNormal );
  }
  else 
  {
    DtcDeactivate( 520193, kFMI_AboveNormal );
  }
}
/*@@end*/

/*@@envVar:envEASFluidPressureError:*/
/*
 * Active DTC for Transmission gear signal.
 */
on envVar envEASFluidPressureError
{
  if (getValue(this) == 1) {
    DtcActivate( 520195, kFMI_DataErratic );
  }
  else {
    DtcDeactivate( 520195, kFMI_DataErratic );
  }
}
/*@@end*/

/*@@envVar:envEASDosingError:*/
/*
 * Active DTC for Transmission gear signal.
 */
on envVar envEASDosingError
{
  if (getValue(this) == 1) {
    DtcActivate( 520194, kFMI_CauseUnknown );
  }
  else {
    DtcDeactivate( 520194, kFMI_CauseUnknown );
  }
}
/*@@end*/

/*@@caplFunc:CalcCatUpstreamTemperature():*///function
/* Calculate Catalyst Upstream Temperature           */
/* NOTE: SIMULATED VALUES, NO REAL VALUES !          */
void CalcCatUpstreamTemperature ()
{
  /* Calculate new Upstream Temperature value on every timer event          */
  if (gEngineSpeed > 0)
  {
    gCatalystUpstreamTemperature = gCatalystUpstreamTemperature + gPerformaceAccelerator*(gActualEngineTorque - 10) * 0.01;
  }
  /* Limit Upstream Temperature value (min, max)                            */
  gCatalystUpstreamTemperature = LimitGovernor (gCatalystUpstreamTemperature, kMinCatalystTemperature, kMaxCatalystTemperature);  
}
/*@@end*/

/*@@caplFunc:CalcCatDownstreamTemperature():*///function
/* Calculate Catalyst Downstream Temperature         */
/* NOTE: SIMULATED VALUES, NO REAL VALUES !          */
void CalcCatDownstreamTemperature ()
{
  /* Calculate new Downstream Temperature value on every timer event        */
  if (gEngineSpeed > 0)
  {
    gCatalystDownstreamTemperature = gCatalystDownstreamTemperature + gPerformaceAccelerator*(gActualEngineTorque - 10) * 0.009;
  }
  /* Limit Downstream Temperature value (min, max)                          */
  gCatalystDownstreamTemperature = LimitGovernor (gCatalystDownstreamTemperature, kMinCatalystTemperature, kMaxCatalystTemperature);
}
/*@@end*/

/*@@caplFunc:CalcActualDosingQuantity():*///function
/* Calculate Actual Dosing Quantity                  */
/* NOTE: SIMULATED VALUES, NO REAL VALUES !          */
void CalcActualDosingQuantity ()
{
  /* Calculate Actual Dosing Quantity                */  
  if (gCatalystUpstreamTemperature > 150 && gActualMachineState == 1)
  {
    gActualDosingQuantity = gRequestedDosingQuantity;
  }
  else
  {
    gActualDosingQuantity = 0; 
  }
}
/*@@end*/

/*@@caplFunc:CalcReductionFluidTankLevel():*///function
/* Calculate Reduction Fluid Tank Level              */
/* NOTE: SIMULATED VALUES, NO REAL VALUES !          */
void CalcReductionFluidTankLevel ()
{
  /* Calculate Tank Level                                                   */
  gReductionFluidTankLevel = gReductionFluidTankLevel - gPerformaceAccelerator*(gActualDosingQuantity * 1/36000);
  /* Limit Tank Level value (min, max)                                      */
  gReductionFluidTankLevel = LimitGovernor (gReductionFluidTankLevel, kMinTankLevel, kMaxTankLevel);

  if (gReductionFluidTankLevel < 20)
  {
    if (gCatalystTankLevelCritical == 0)
  {
      /* Activate DTC */
    DtcActivate(520196, 1);
    /* Lock DTC     */ 
    gCatalystTankLevelCritical = 1;
  }
      
  if (gReductionFluidTankLevel <= 10)
  {
    if (gCatalystTankLevelStop == 0)// && gCatalystUpstreamTemperature >= 150)
    {
      /* Deactivate DTC */
    DtcDeactivate(520196, 1);
    /* Activate DTC   */
      DtcActivate(520196, 11);
    /* Lock DTC       */ 
      gCatalystTankLevelStop = 1;
    }
     /*else if (gCatalystTankLevelStop == 1)// && gCatalystUpstreamTemperature <=150)
      {
        DtcDeactivate(520196, 11);
      }*/
    gActualDosingQuantity = 0;
    }
  }
}
/*@@end*/

/*@@caplFunc:CalcReductionFluidPressure():*///function
/* Calculate Reduction Fluid Pressure                */
/* NOTE: SIMULATED VALUES, NO REAL VALUES !          */
void CalcReductionFluidPressure ()
{
  /* Calculate Urea Pressure                                                */
  gReductionFluidPressure = gReductionFluidPressure + 4 * gPerformaceAccelerator;
  /* Limit Tank Level value (min, max)                                      */
  gReductionFluidPressure = LimitGovernor (gReductionFluidPressure, kMinUreaPressure, kMaxUreaPressure);

  if (gReductionFluidPressure < 500)
  {
    gActualMachineState = 41;
    gActualTransitionState = 53;
  }
  else
  {
    gActualMachineState = 1;
    gActualTransitionState = 19;
  }
}
/*@@end*/

/*@@key:'r':*/
/* (Re-)Fill Tank */
on key 'r'
{
  /* Reset Tank Level */
  gReductionFluidTankLevel   = kInitReductionFluidTankLevel;
  gCatalystTankLevelCritical = 0;
  gCatalystTankLevelStop     = 0;
  
  /* Deactivate possible DTCs */
  DtcDeactivate(520196, 1);
  DtcDeactivate(520196, 11); 
}
/*@@end*/

