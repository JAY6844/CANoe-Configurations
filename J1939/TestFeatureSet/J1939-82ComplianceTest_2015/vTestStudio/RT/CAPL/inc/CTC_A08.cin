/*@!Encoding:1252*/
includes
{
  #include "CTF_A08.cin"
}

// ==============================================================================================================
export testcase CTC_A08_01_TP_Receive_RTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0801, "RTS/CTS Transport: Successfully receives a valid RTS (content and format)  (DUT as Responder) ");
  CT_DESC("Verify DUT sends a valid TP.CM_CTS when it receives a valid TP.CM_RTS sent specifically to DUT, i.e. the PGN in the TP.CM_RTS is supported, and the total message size & Number of packets reported in the TP.CM_RTS are correct, and DUT is able to handle transport at the time. Verify DUT checks the PGN (including DP and EDP) in the RTS. Verify DUT responds with TP.Conn_Abort if unable to handle transport at the time or other reject reasons ");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send a valid TP.CM_RTS for RTS->CTS and RTS->Abort PGN.");
  CT_STRAT("Check the response's PGN. For RTS->Abort check if DUT aborts.");
  CT_STRAT("Send TP.CM_RTS with DP bit set. Check DP bit in responses PGN.");
  CT_STRAT("Send TP.CM_RTS with EDP bit set. Check EDP bit in responses PGN.");

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.4");

  CT_GetRTSPGIs( pgis );
  CTF_A08_01_TP_Receive_RTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_02_TP_Receive_RTS_Validate_CTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0802, "RTS/CTS Transport: CTS following RTS is valid (content and format)  (DUT as Responder)");
  CT_DESC("Verify DUT sends the TP.CM_CTS within 200 ms (Tr) following TP.CM_RTS. Verify DUT sends TP.CM_CTS with correct PGN, 'Next packet number to be sent' equal to 1, and the 'Number of packets that can be sent' is less than or equal to the smaller of the 'Total number of packets' and 'Maximum number of packets' specified in TP.CM_RTS. Verify DUT sends TP.CM_CTS to specific address (never sent to global address).");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send a valid TP.CM_RTS for RTS->CTS PGNs.");
  CT_STRAT("Check the answering CTS is send to specific address");
  CT_STRAT("Check the parameters (payload) of the CTS");
  

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.3 - Figure 15");
  CT_DOC_21("5.10.3.2");
  CT_DOC_21("5.12.3");

  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_02_TP_Receive_RTS_Validate_CTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_03_TP_Receive_Multiple_RTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0803, "RTS/CTS Transport: Multiple RTS received from same SA for the same PGN within short period (DUT as Responder)");
  CT_DESC("If DUT accepts the transport, verify DUT responds with only one TP.CM_CTS (not to every RTS), and verify DUT does not send TP.Conn_Abort for the other RTS instances.");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send 2 TP.CM_RTS as quick as possible for RTS->CTS PGNs.");
  CT_STRAT("Await the DUT's answer and check for multiple TP.CM_CTS between the first TP.CM_RTS and the first TP.DT of the tester.");

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.3.1");

  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_03_TP_Receive_Multiple_RTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_04_TP_Receive_RTS_Rejection()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0804, "RTS/CTS Transport: Rejects connection request with valid Conn_Abort (content and format) (DUT as Responder)");
  CT_DESC("Verify DUT sends a TP.Conn_Abort in response to the TP.CM_RTS to reject the RTS request. Verify DUT sends the TP.Conn_Abort within 200 ms (Tr) following TP.CM_RTS. Verify DUT sends the TP.Conn_Abort with correct PGN and a valid connection abort reason. Verify DUT sends the TP.Conn_Abort to specific address (never sent to global address). ");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS for all PGN's configured with the RTS->Abort flag.");
  CT_STRAT("Await the DUT's Abort within Tr (200ms)");
  CT_STRAT("Check the PGN in the Abort.");
  CT_STRAT("Check the abort reason to be in the valid abort range");
  CT_STRAT("Check Abort is never send to global address.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.4");

  CT_GetRTSAbortPGIs( pgis );
  CTF_A08_04_TP_Receive_RTS_Rejection(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_05_TP_Receive_RTS_Unsupported()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0805, "RTS/CTS Transport: Receiving an TP.CM_RTS for an unsupported PGN (content and format)  (DUT as Responder)");
  CT_DESC("Verify DUT sends a TP.Conn_Abort when it receives a TP.CM_RTS for a PGN not supported by the DUT");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS for all PGN's configured with the RTS->Abort flag.");
  CT_STRAT("Await the DUT's Abort within Tr (200ms)");
  CT_STRAT("Check the PGN in the Abort.");
  CT_STRAT("Check the abort reason to be in the valid abort range");
  CT_STRAT("Check Abort is never send to global address.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.4");

  CT_GetRTSAbortPGIs( pgis );
  CTF_A08_05_TP_Receive_RTS_Unsupported(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_06_TP_Receive_RTS_Invalid()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0806, "RTS/CTS Transport: Receiving an invalid TP.CM_RTS (content and format) (DUT as Responder) ");
  CT_DESC("Verify DUT sends a TP.Conn_Abort when it receives a TP.CM_RTS with invalid or incorrect content, e.g., data size incorrect for PGN, total message size is outside valid limits (i.e. less than 9, greater than 1785), specified number of packets incorrect for total message size, etc. Verify DUT ignores the TP.CM_RTS and doesn't send a TP.Conn_Abort when the TP.CM_RTS is sent to the global address");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS with invalid number of packets.");
  CT_STRAT("Await the DUT's Abort within Tr (200ms)");
  CT_STRAT("Send TP.CM_RTS with message size <9");
  CT_STRAT("Await the DUT's Abort within Tr (200ms)");
  CT_STRAT("Send TP.CM_RTS with message size >1785");
  CT_STRAT("Await the DUT's Abort within Tr (200ms)");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.4");

  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_06_TP_Receive_RTS_Invalid(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_07_TP_Send_CTS_Numbering()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0807, "RTS/CTS Transport: CTS next packet numbering (DUT as Responder) ");
  CT_DESC("Verify DUT sends only valid values for the 'Next packet number to be sent value' in each TP.CM_CTS, i.e. - same as 'Next packet number to be sent' in the last CTS - greater than 'Next packet number to be sent' in the last CTS and less than the sum of 'Next packet number to be sent' in the last CTS plus 'Number of packets that can be sent' in the last CTS - equal to the sum of 'Next packet number to be sent' plus 'Number of packets that can be sent' in the last CTS");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS");
  CT_STRAT("For all DUT's TP.CM_CTS messages in the TP, check 'Next Packet Number To Be Sent'");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.3.2 - Appendix C");
  CT_DOC_21("5.10.1.3");

  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_07_TP_Send_CTS_Numbering(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A08_08_TP_Send_CTS_Foreign_PGN()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0808, "RTS/CTS Transport: Does not send CTS outside of connection (DUT as Responder) ");
  CT_DESC("Verify DUT does not send TP.CM_CTS for PGNs not in a connection");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("Check DUT sends no TP.CM_CTS for PGNs not in a connection during this TP");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.3.2");

  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_08_TP_Send_CTS_Foreign_PGN(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A08_09_TP_Send_Multiple_CTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0809, "RTS/CTS Transport: Multiple CTS (same SA, DA, PGN) transmitted in short period  (DUT as Responder)");
  CT_DESC("Verify DUT does not send multiple instances of TP.CM_CTS unless one of the following conditions have occurred: - a T1 timeout (750 ms) for missing TP.DT data packets - a T2 timeout (1250 ms) after last TP.CM_CTS - received the last TP.DT packet for previous CTS - sending consecutive 'hold connection' TP.CM_CTS to pause data flow");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("Await the TP.CM_CTS within Tr(200ms)");
  CT_STRAT("Tester does NOT send any TP.DTs");
  CT_STRAT("Afer T2 (1250ms), the DUT may resend the last TP.CM_CTS, to reorder the TP.DTs, or aborts the connection.");
  CT_STRAT("Test aborts the connection, if the DUT doesn't so far.");
  CT_STRAT("");
  CT_STRAT("Send TP.CM_RTS and start TP again.");
  CT_STRAT("Await the TP.CM_CTS within Tr(200ms)");
  CT_STRAT("Tester sends only the first TP.DT and stops sending any further packets.");
  CT_STRAT("Afer T1 (750ms), the DUT may resend the last TP.CM_CTS, to reorder the TP.DTs, or aborts the connection.");
  CT_STRAT("Test aborts the connection, if the DUT doesn't so far.");
  CT_STRAT("");
  CT_STRAT("Send TP.CM_RTS and start TP again.");
  CT_STRAT("Await the TP to be finalized with TP.CM_EndOfMsgAck.");
  CT_STRAT("During the TP the tester detects if the DUT sends unexpected TP.CM_CTS (inclusive. CTS-Hold)");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3.2 - Appendix C1");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_09_TP_Send_Multiple_CTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A08_10_TP_Send_First_CTS_Hold()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x080a, "RTS/CTS Transport: Transmitting first 'hold connection' CTS to pause data flow (DUT as Responder)");
  CT_DESC("Verify DUT uses the correct settings when it sends a 'hold connection' TP.CM_CTS, i.e. correct PGN, 'Number of packets that can be sent' = 0, and all other data field bits set to 1's. Verify DUT sends the 'hold connection' TP.CM_CTS sent within 200 ms (Tr) following the reception of the last TP.DT packet for previous CTS");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("If the test detects a CTS hold during TP, it is checke for its proper content, else the test can't investigate and marks the test as inconclusive.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.3");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.2 - Appendix C1");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_10_TP_Send_First_CTS_Hold(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A08_11_TP_Send_Consecutive_CTS_Hold()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x080b, "RTS/CTS Transport: Transmitting consecutive 'hold connection' CTS to continue to pause data flow (DUT as Responder)");
  CT_DESC("Verify DUT uses the correct settings when it sends a consecutive 'hold connection' TP.CM_CTS, i.e. correct PGN, 'Number of packets that can be sent' = 0, and all other data field bits set to 1's. Verify DUT sends the consecutive 'hold connection' TP.CM_CTS within 500 ms (Th) of last 'hold connection' TP.CM_CTS");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("If the test detects a CTS hold during TP, it is checked for its proper content. Consecutive CTS holds are checked for their time distance to be Th (500ms). If there are no consecutive CTS hold messages are found, the test can't investigate and marks the test as inconclusive.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.3");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.2 - Appendix C1");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_11_TP_Send_Consecutive_CTS_Hold(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A08_12_TP_CTS_after_CTS_Hold()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x080c, "RTS/CTS Transport: CTS following 'hold connection' CTS  (DUT as Responder) ");
  CT_DESC("Verify DUT sends an appropriate TP.CM_CTS within 500 ms (Th) following the last 'hold connection' TP.CM_CTS. Verify the TP.CM_CTS has correct PGN, a valid 'Next packet number to be sent', and a valid 'Number of data packets that can be sent'. A valid 'Next packet number to be sent' value is:  - same as 'Next packet number to be sent' in the last CTS before CTS pause started - greater than 'Next packet number to be sent' in the last CTS and less than the sum of 'Next packet number to be sent' in the last CTS plus 'Number of packets that can be sent' in the last CTS before CTS pause started - equal to the sum of 'Next packet number to be sent' plus 'Number of packets that can be sent' in the last CTS before CTS pause started. A valid 'Next packet number to be sent' value is: - less than or equal to the smaller of the 'Total number of packets' and 'Maximum number of packets' specified in TP.CM_RTS");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("If the test detects a CTS hold during TP, the TP.CM_CTS within the TP are checked for validity and timeout.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.3");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.2 - Appendix C1");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_12_TP_CTS_after_CTS_Hold(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_13_TP_First_DT_Timing()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x080d, "RTS/CTS Transport: Timing of first TP.DT for RTS/CTS following CTS (DUT as Responder) ");
  CT_DESC("Verify DUT behavior when the first TP.DT packet is received within 1250 ms (T2) after the CTS. Verify DUT behavior, e.g., sends a TP.CM_CTS to have packets resent or sends a TP.Conn_Abort, when DUT does not receive a TP.DT within 1250 ms (T2) after the CTS ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("Await the TP.CM_CTS");
  CT_STRAT("Do NOT send the first TP.DT but wait for T2 (1250ms). During this wait the DUT can abort but shall not send any TP.CM_CTS.");
  CT_STRAT("Check if DUT aborts the connection within Tr (200ms) or sends an TP.CM_CTS for resending");
  CT_STRAT("When DUT reorders the packets correctly, test is passed, and TOOL aborts the TP.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.3");
  CT_DOC_21("5.10.2.4 - Appendix C");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_13_TP_First_DT_Timing(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_14_TP_Send_Consecutive_CTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x080e, "RTS/CTS Transport: CTS issued after last Transport Data packet of the previous CTS (DUT as Responder) ");
  CT_DESC("Verify DUT sends an appropriate TP.CM_CTS within 200 ms (Tr) following the reception of the last TP.DT data packet for previous CTS. Verify DUT sends a valid TP.CM_CTS, i.e. correct PGN, 'Next packet number to be sent' is valid, and 'Number of data packets that can be sent' is less than or equal to the smaller of the 'Total number of packets' and 'Maximum number of packets' specified in TP.CM_RTS");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("Check any consecutive up CTS within Tr (200ms) for errors.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.2");
  CT_DOC_21("5.12.3 - Appendix C");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_14_TP_Send_Consecutive_CTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_15_TP_DT_Timing_After_CTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x080f, "RTS/CTS Transport: TP.DT Data Transport timing following CTS (DUT as Responder) ");
  CT_DESC("Verify DUT retransmits the TP.CM_CTS or sends a TP.Conn_Abort when it does not receive a TP.DT within 1250 ms (T2) following the CTS. If DUT does retransmit the TP.CM_CTS when it does not receive a TP.DT within 1250 ms (T2), then verify the DUT sends a TP.Conn_Abort by the third consecutive time it does not receive a TP.DT within 1250 ms (T2) following the CTS");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("Await the TP.CM_CTS");
  CT_STRAT("Send the first 3 TP.DT packets.");
  CT_STRAT("Await the second TP.CM_CTS");
  CT_STRAT("Do not send any TP.DT packets, but await the DUT's reaction during timeout T2 (1250ms). If it sends an TP.CM_CTS, this is an error. If it aborts, its ok.");
  CT_STRAT("If DUT did not abort, then it re-orders the packets with TP.CM_CTS. Check if this CTS is a re-ordering.");
  CT_STRAT("Do not send any TP.DT packets, but await the DUT's reaction during the second T2 timeout (1250ms). If it sends an TP.CM_CTS, this is an error. If it aborts, its ok.");
  CT_STRAT("If DUT did not abort, then it re-orders the packets with TP.CM_CTS. Check if this CTS is a re-ordering.");
  CT_STRAT("Do not send any TP.DT packets, but await the DUT's reaction during the third T2 timeout (1250ms). If it sends an TP.CM_CTS, this is an error. If it aborts, its ok.");
  CT_STRAT("Due this is the third time there is no data, the DUT has to abort within Tr (200ms).");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4 - Appendic C");
  CT_DOC_21("5.10.3.2");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_15_TP_DT_Timing_after_CTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_16_TP_Consecutive_DT_Timing()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0810, "RTS/CTS Transport: Time between consecutive Transport Data Packets for RTS/CTS when the CTS allows more than 1 packet (DUT as Responder) ");
  CT_DESC("Verify DUT successfully receives the RTS/CTS data when the time between consecutive TP.DT packets is less than 200 ms (Tr). Verify DUT behavior, e.g., sends a TP.CM_CTS to have packets resent or sends a TP.Conn_Abort, when the time between consecutive TP.DT packets is longer than 200 ms (Tr) but less than 750 ms (T1). Verify DUT behavior, e.g., sends a TP.CM_CTS to have packets resent or sends a TP.Conn_Abort, when the time between any consecutive TP.DT packets is longer than 750 ms (T1) ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP with a max packet number of 4 TP.DTs per data block.");
  CT_STRAT("Receive the DUT's next TPCM within T2 (1250ms). On abort the test is inconclusive. On TP.CM_CTS, check that it starts ordering 4 packets starting with packet #1.");
  CT_STRAT("Send the first TP.DT packet with sequence #1 within Tr (200ms) after last TP.CM_CTS.");
  CT_STRAT("Check if DUT sends a TPCM within T1 (750ms). On abort the test is inconclusive. On TP.CM_CTS test is fails, due CTS is not expected at this point.");
  CT_STRAT("Send the second TP.DT packet with sequence #2. It's sent within Tr (200ms) and T1 (750ms) after the last TP.DT.");
  CT_STRAT("Check if DUT sends a TPCM within the next T1 (750ms). On abort the test is inconclusive. On TP.CM_CTS test is fails, due CTS is not expected at this point.");
  CT_STRAT("Check if DUT sends a TPCM within the next Tr (200ms). On abort the test is passed. On TP.CM_CTS (resend) check that it starts with packet number <=3 and not more than 4 packets.");
  CT_STRAT("On reorder #1 by TP.CM_CTS, do not send any packets but await DUT reaction within T1 (750ms). On abort the test is passed, On TP.CM_CTS the test fails, due CTS is not expected at this point.");
  CT_STRAT("Check if DUT sends a TPCM within Tr (200ms) (last TP.CM_CTS timed out). On abort the test is passed. On TP.CM_CTS (resend) check that it starts with packet number <=3 and not more than 4 packets.");
  CT_STRAT("On reorder #2 by TP.CM_CTS, do not send any packets but await DUT reaction within T1 (750ms). On abort the test is passed, On TP.CM_CTS the test fails, due CTS is not expected at this point.");
  CT_STRAT("Check if DUT sends an abort within the next Tr (200ms). On abort the test is passed. On TP.CM_CTS (resend) the test fails due resending is not allowed anymore.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.1.3");
  CT_DOC_21("5.10.2.4");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_16_TP_Consecutive_DT_Timing(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_17_TP_DT_Sequential_Order()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0811, "RTS/CTS Transport: Sequential order of Transport Data Packets RTS/CTS (DUT as Responder) ");
  CT_DESC("Verify DUT successfully receives the RTS/CTS data when the TP.DT Data packets for the RTS/CTS are sent in sequential order. Verify behavior, e.g., sends a TP.CM_CTS to have packets resent or sends a TP.Conn_Abort, when TP.DT Data packets for the RTS/CTS are received out of order ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP with a proper TP.DT sequence.");
  CT_STRAT("Check if the TP was properly finalized without errors.");
  CT_STRAT("Send TP.CM_RTS and start a second TP.");
  CT_STRAT("Await the TP.CM_CTS from DUT within Tr (200ms)");
  CT_STRAT("Send TP.DT packets with a sequence error.");
  CT_STRAT("Inspect if the DUT aborted or reordered packets with TP.CM_CTS, within the TP.DT data block.");
  CT_STRAT("If DUT's reaction is not within the data-block, await it's reaction within Tr (200ms) after the data block.");
  CT_STRAT("If DUT aborted the connection, test is passsed.");
  CT_STRAT("If DUT reordered packets, then send them and await the DUT's TP.CM_EndOfMsgAck within Tr (200ms) after the last TP.DT.");
  CT_STRAT("If DUT wrongly finalizes the data-block with TP.CM_EndOfMsgAck, it does not detect the sequence error and test is failed.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.1.2");
  CT_DOC_21("5.10.1.3");
  CT_DOC_21("5.10.1.4");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3.2");
  CT_DOC_21("5.10.3.4");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_17_TP_DT_Sequential_Order(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A08_18_TP_Receive_DT_Data_Size()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0812, "RTS/CTS Transport: Data field size of Transport Data packets for RTS/CTS  (DUT as Responder)");
  CT_DESC("Verify DUT successfully receives the RTS/CTS data when each TP.DT data packets contains 8 bytes. Verify DUT behavior, e.g., sends a TP.CM_CTS to have packets resent or sends a TP.Conn_Abort, when it receives TP.DT data packets with less than 8 bytes");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("Check that DUT sends an abort within Tr (200ms) after it receives a TP.DT with a DLC < 8");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.2.7.2");
  CT_DOC_21("5.10.1.3");
  CT_DOC_21("5.10.4");
  CT_DOC_21("5.10.2.4 - Figure 16");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_18_TP_Receive_DT_Data_Size(gTOOL_Addr, gDUT_Addr, pgis, 0);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_19_TP_Receive_DT_Prios()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0813, "RTS/CTS Transport: Ensure DUT accepts RTS/CTS transport when Priority of TP.DT data packets are not correct value (DUT as Responder) ");
  CT_DESC("Verify DUT receives TP.DT data packets even if the TP.DT messages use a Priority other than 7");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP.");
  CT_STRAT("Await the TP.CM_CTS and send TP.DT's with all possible prios.");
  CT_STRAT("Check if the connection is terminated properly with an TP.CM_EndOfMsgACK.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.4 - Figure 16");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_19_TP_Receive_DT_Prios(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_20_TP_Send_EOM()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0814, "RTS/CTS Transport: Transmit EndOfMsgACK (DUT as Responder) ");
  CT_DESC("Verify DUT sends TP.CM_EndOfMsgACK with correct PGN, Total message size, and Total number of packets. Verify DUT sends TP.CM_EndOfMsgACK only after the last TP.DT data packet Verify DUT sends TP.CM_EndOfMsgACK within 200 ms (Tr) after last TP.DT data packet. If DUT sends 'hold connection' CTS messages after the last TP.DT data packet, then verify DUT sends the TP.CM_EndOfMsgACK within 500 ms (Th) after the last 'hold connection' CTS ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Send TP.CM_RTS and start TP with a proper TP.DT sequence.");
  CT_STRAT("Check TP.CM_EndOfMsgACK was sent within Tr (200ms) after the last TP.DT and not before.");
  CT_STRAT("Check TP.CM_EndOfMsgACK for proper PGN.");
  // CT_STRAT("Check TP.CM_EndOfMsgACK was sent after Th (500ms) when DUT holds the connection after the last TP.DT"); // ignored silently ;-) Problem: What if dut holds, and reorders etc... hold before eom is exotic -> KIS.
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.3 - Appendix C1");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_20_TP_Send_EOM(gTOOL_Addr, gDUT_Addr, pgis, 0);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_21_TP_Receive_Abort()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0815, "RTS/CTS Transport: Connect Abort issued by Originator (DUT as Responder)");
  CT_DESC("Verify DUT does not apply or use any received data when it receives a TP.Conn_Abort from the Originator at any time between the initial TP.CM_CTS and the final TP.CM_EndOfMsgACK. Verify DUT ignores any associated TP.DT Data packets following Abort Verify DUT checks PGN (including DP and EDP) and address of the TP.Conn_Abort Monitor DUT messages for at least 750 ms (T1) after the abort message to verify the DUT does not send a TP.CM_CTS (due to T1 timeout) when abort results in Originator sending some, but not all, of the TP.DT data packets for the last CTS. Monitor DUT messages for at least 1250 ms (T2) after the abort message to verify the DUT does not resend the TP.CM_CTS or a TP.CM_Abort (due to T2 timeout) when abort results in Originator not sending any TP.DT data packets for the last CTS. Monitor DUT messages for at least 500 ms (Th) after the abort message to verify DUT does not send another TP.CM_CTS when abort issued while DUT sending 'hold connection' CTS messages ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "1) Send TP.CM_RTS for 20 byte.");
  CT_STRAT("Tester aborts directly before sending the last TP.DT. Checks that DUT does not send any TP.CM messages to the tester within T2 (1250ms)");
  
  CT_STRAT("2) Send TP.CM_RTS for 20 byte.");
  CT_STRAT("Tester sends an abort with another PGN (including DP end EDP), directly before sending the last TP.DT. DUT shall ignore it and finalize the TP with TP.CM_EndOfMsgACK within Tr (200ms) after last TP.DT.");
  
  CT_STRAT("3) Send TP.CM_RTS for 20 byte.");
  CT_STRAT("Tester sends an abort to the global address, directly before sending the last TP.DT. DUT shall ignore it and finalize the TP with TP.CM_EndOfMsgACK within Tr (200ms) after last TP.DT.");
  
  CT_STRAT("4) Send TP.CM_RTS for 20 byte.");
  CT_STRAT("Tester sends the first two TP.DT and aborts the connection. Check that DUT does not send any TP.CM messages to the tester within T1 (750ms)");
  
  CT_STRAT("5) Send TP.CM_RTS for 20 byte.");
  CT_STRAT("Tester send no data packages, but aborts immediately. Check that DUT does not send any TP.CM messages to the tester within T2 (1250ms)");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.4");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_21_TP_Receive_Abort(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_22_TP_Send_Abort()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0816, "RTS/CTS Transport: Connect Abort issued by Responder (DUT as Responder)");
  CT_DESC("Verify DUT sends the TP.Conn_Abort with the correct PGN and a valid connection abort reason. Verify DUT sends the TP.Conn_Abort to specific address (never sent to global address). Verify DUT ignores any Transport Data packets following Abort ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "Tester behaves within TP the DUT to abort. Then it checks the abort's reason, the DA and the PGN.");
  CT_STRAT("Reason 1: Already in one or more connections: Not testable.");
  CT_STRAT("Reason 2: System ressource problem: Not testable.");
  CT_STRAT("Reason 3: Timeout: Send RTS and after receiving CTS, send first TP.DT ans stop. After DUT aborted with timeout, send the missing TP.DTs and check if DUT does react on them.");
  CT_STRAT("Reason 4: CTS within connection: Not testable in this TP-direction.");
  CT_STRAT("Reason 5: Max retransmit: Not testable in this TP-direction.");
  CT_STRAT("Reason 6: Unexpected Data Transfer packet: Not testable due sematics is not cleared.");
  CT_STRAT("Reason 7: Bad sequence: Send RTS, await CTS and send a bad TP.DT sequence.");
  CT_STRAT("Reason 8: Duplicate sequence: Send RTS, await CTS and send a duplicate TP.DT packet.");
  CT_STRAT("Reason 9: Total msg size > 1785: Send an RTS with a byte size of > 1785 bytes.");
  CT_STRAT("Reason 10-249: SAE range. Not directly testable, but if DUT uses any of this abort code in the other checks, the test fails with a hint to the reserved SAE range.");
  CT_STRAT("Reason 250: Not listed. Not testable.");
  CT_STRAT("Reason 251-255: J1939-71 - Vehicle Application Layer. Not testable.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.4");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_22_TP_Send_Abort(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_23_TP_Simultaneous_Different_Originators()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0817, "RTS/CTS Transport: Simultaneous RTS/ CTS with different Originators (DUT as Responder) ");
  CT_DESC("Verify ability of DUT to successfully manage simultaneous RTS/CTS transports with different originators. Verify DUT uses/evaluates Destination Address to differentiate TP.CM and TP.DT messages ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5.1");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_23_TP_Simultaneous_Different_Originators(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_24_TP_Simultaneous_RTSCTS_BAM()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0818, "TP Transport: Simultaneous RTS/CTS and BAMs with same Originator (DUT as Responder)");
  CT_DESC("Verify ability of DUT to successfully manage simultaneous RTS/CTS and BAM transports with same originator. Verify DUT uses/evaluates Destination Address to distinguish TP.DT for RTS/CTS and BAM ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5.1");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_24_TP_Simultaneous_RTSCTS_BAM(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_25_TP_Simultaneous_Same_Originator()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0819, "RTS/CTS Transport: Another RTS from same Originator for different PGN (DUT as Responder) ");
  CT_DESC("Verify DUT sends TP.Conn_Abort (reject request) for an additional RTS from an Originator for different PGN while another RTS/CTS is open with same Originator ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT supports RTS/CTS TP.");
  
  // describe the strategy...
  CT_STRAT(1, "");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5");
  
  CT_GetRTSCTSPGIs( pgis );
  CTF_A08_25_TP_Simultaneous_Same_Originator(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A08_26_TP_Connection_Limit()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x081a, "RTS/CTS Transport: RTS received when ECU at TP Connection Limit (DUT as Responder) ");
  CT_DESC("Verify DUT sends TP.Conn_Abort (rejects the request) for an additional RTS when DUT is unable to handle another transport");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "%");
  
  // describe the strategy...
  CT_STRAT(1, "Test can not be done using the active strategy, due it's unclear how to produce a limit on the DUT. Test will be inconclusive.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5");
  
  CTF_A08_26_TP_Connection_Limit(1);
  
  // end the testcase.
  CT_END();
}

