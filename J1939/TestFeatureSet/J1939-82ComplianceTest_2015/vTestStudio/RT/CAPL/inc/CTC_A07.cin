/*@!Encoding:1252*/
includes
{
  #include "CTF_A07.cin"
}

// ==============================================================================================================
export testcase CTC_A07_01_TP_Init()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0701, "TP.CM_RTS message is transmitted before starting the associated TP.DT data transfer ");
  CT_DESC("Verify DUT sends a TP.CM_RTS message to initiate an RTS/CTS transport connection prior to sending any associated TP.DT data packets ");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable non cyclic PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.1.3");
  CT_DOC_21("5.10.2.2");
  CT_DOC_21("5.10.3.1");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_01_TP_Init(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A07_02_TP_RTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0702, "TP.CM_RTS message is valid (content and format)  (DUT as Originator) ");
  CT_DESC("Verify the TP.CM_RTS message sent by the DUT has correct content for PGN, ‘Total message size’, ‘Total number of packets’ & ‘max packets’ and these parameters are of correct size and format. Verify the ‘Total message size’ matches the overall message size. Verify the ‘Total number of packets’ matches the actual number of TP.DT packets. Verify the DUT sends the TP.CM_RTS message to a specific Address (i.e., TP.CM_RTS message should never be sent to the Global Address - FF 16). Verify the DUT does not send a value less than 1 in the ‘max packets’ parameter. Verify the TP.CM_RTS message data bytes match what is actually sent with the corresponding TP.DT data packets from the DUT ");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable non cyclic PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.3 - Figure 15");
  CT_DOC_21("5.10.3.1");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_02_TP_RTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A07_03_TP_CTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0703, "Behavior to CTS response to RTS (content and format)  (DUT as Originator)");
  CT_DESC("Verify DUT transmits the appropriate TP.DT data packets after it receives a valid first TP.CM_CTS message (e.g., ‘Next packet number to be sent’ is '1') within 1250 ms (T3) following TP.CM_RTS. Verify DUT inspects the PGN (including DP and EDP) in TP.CM_CTS. Verify the DUT does not send TP.DT data packets until the associated TP.CM_CTS message has been received. Verify DUT does not send TP.Conn_Abort if a TP.CM_CTS is not received within 1250 ms (T3) following the TP.CM_RTS (i.e. connection was never established). Verify DUT transmits a TP.Conn_Abort when the TP.CM_CTS message’s 'Number of packets that can be sent' is greater than the smallest value of either 'Total number of packets' or 'Maximum number of packets' sent in the TP.CM_RTS. Verify DUT transmits a TP.Conn_Abort when the TP.CM_CTS following the TP.CM_RTS contains 'Next packet number to be sent' with any value other than '1' ");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.2.3");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3 - Figure 15");
  CT_DOC_21("5.10.3.2");
  CT_DOC_21("5.10.5.1 - Figure C1");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  
  CTF_A07_03_TP_CTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A07_04_TP_RTS_Abort()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0704, "Response to TP.Conn_Abort  for its RTS (DUT as Originator) ");
  CT_DESC("Verify DUT terminates or stops the RTS/CTS transport connection when it receives the TP.Conn_Abort with the correct PGN from the  responder of the RTS/CTS transport connection. ");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");
  CT_STRAT("Wait for RTS of the DUT, and send an abort.");
  CT_STRAT("DUT has to stop sending any subsequent data packages.");

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.3.4");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  
  CTF_A07_04_TP_RTS_Abort(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A07_05_TP_Multiple_CTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0705, "Behavior to CTS message following  last TP.DT data packet for previous CTS message (DUT as Originator) ");
  CT_DESC("Verify DUT transmits the appropriate TP.DT messages when a valid TP.CM_CTS message is received within 1250 ms (T3)after sending the last TP.DT data packet for the last received TP.CM_CTS message. Verify DUT transmits a TP.Conn_Abort if it does not receive a CTS within 1250 ms (T3) following last TP.DT data packet indicated by the last received TP.CM_CTS message. Verify DUT inspects the PGN (including DP and EDP) in the TP.CM_CTS. Verify DUT transmits a TP.Conn_Abort when the TP.CM_CTS message's 'Number of packets that can be sent' is greater than the smallest value of either 'Total number of packets' or 'Maximum number of packets' which was sent in the TP.CM_RTS. ");

  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");
  CT_STRAT("Testnode sends requests and awaits RTS.");
  CT_STRAT("Testnode sends CTS' for one data package.");
  CT_STRAT("Testnode sends subsequent wrong CTS' where DUT shall answer with abort.");

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.2 - Appendix C");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  
  CTF_A07_05_TP_Multiple_CTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A07_06_TP_CTS_Retransmission()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0706, "Behavior to next packet numbering in CTS message following the last Transport Data Packet for previous CTS message (non-‘hold connection’ TP.CM_CTS message) (DUT as Originator) ");
  CT_DESC("Verify DUT transmits the appropriate TP.DT data packets when 'Next packet number to be sent' parameter in the last TP.CM_CTS message… - is the same as 'Next packet number to be sent' in the previous TP.CM_CTS message (data retransmission) - is within the range of packets in previous TP.CM_CTS message (partial data retransmission) - equals the sum of 'Next packet number to be sent' plus 'Number of packets that can be sent' in last TP.CM_CTS message Verify DUT transmits a TP.Conn_Abort when 'Next packet number to be sent' in TP.CM_CTS message: - is less than the 'Next packet number to be sent' in previous TP.CM_CTS - is greater than the sum of 'Next packet number to be sent' plus 'Number of packets that can be sent' in last TP.CM_CTS message ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");
  CT_STRAT("Testnode sends requests and awaits RTS.");
  CT_STRAT("Testnode sends CTS for two data package.");
  CT_STRAT("Testnode sends CTS for a retransmission of both packages (partial).");
  CT_STRAT("Testnode sends CTS for a retransmission of second package.");
  CT_STRAT("Testnode starts request again and checks for an invalid retransmission.");

  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4 - Appendix C");
  CT_DOC_21("5.10.3.2");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_06_TP_CTS_Retransmission(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A07_07_TP_CTS_Single_Hold()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0707, "Ensure DUT correctly handles first 'hold connection' TP.CM_CTS message immediately following last TP.DT data packet indicated in previous TP.CM_CTS message (DUT as Originator) ");
  CT_DESC("Verify DUT pauses data flow when it receives a 'hold connection' TP.CM_CTS message (request to momentarily stop data flow).  In other words, TP.CM_CTS message containing 'Number of packets that can be sent' parameter set to ‘0’. Verify DUT inspects the PGN (including DP and EDP) in the TP.CM_CTS message. ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");
  CT_STRAT("Testnode sends requests and awaits RTS.");
  CT_STRAT("Testnode sends first CTS for one data package and awaits it from the DUT.");
  CT_STRAT("Testnode sends a hold connection CTS to momentarily stop the sending for some time.");
  CT_STRAT("Testnode sends a CTS to finalize the transmission.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.3");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.2 - Appendix C1");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_07_TP_CTS_Single_Hold(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A07_08_TP_CTS_Consequtive_Hold()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0708, "Ensure DUT correctly handles consecutive 'hold connection' TP.CM_CTS messages (DUT as Originator) ");
  CT_DESC("Verify DUT continues to pause data flow when it receives another 'hold connection' TP.CM_CTS messages within 500 ms (Th) following the previous 'hold connection' TP.CM_CTS message. Verify DUT continues to pause data flow when it receives another 'hold connection' TP.CM_CTS messages after 500 ms (Th) has expired but before 1050 ms (T4) has expired following the previous 'hold connection' CTS. Verify DUT transmits a TP.Conn_Abort if it does not receive any TP.CM_CTS messages within 1050 ms (T4) following previous ‘hold connection’ TP.CM_CTS message. Verify DUT inspects the PGN (including DP and EDP) in the TP.CM_CTS . ");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");
  CT_STRAT("Testnode sends request and awaits RTS.");
  CT_STRAT("Testnode sends first CTS for one data package.");
  CT_STRAT("Testnode holds connection for some times.");
  CT_STRAT("Testnode continues transport with a CTS that was sent just before a timeout of (T4).");
  CT_STRAT("Testnode repeats the behaviour above but the continuing CTS was sent too late (T4). DUT shall abort transport due to a timeout.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.3");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.2 - Figure C1");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_08_TP_CTS_Consecutive_Hold(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}

// ==============================================================================================================
export testcase CTC_A07_09_TP_CTS_Data_After_Hold()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0709, "CTS following 'hold connection' CTS  (DUT as Originator)");
  CT_DESC("Verify DUT sends the appropriate packets in TP.DT when it receives a valid CTS within 1050 ms (T4) following the previous 'hold connection' CTS. Verify DUT sends the appropriate packets in TP.DT when 'Next packet number to be sent' in CTS: - is the same as 'Next packet number to be sent' in last CTS before CTS pause started - is within the range of packets in last CTS before CTS pause started - equals the sum of 'Next packet number to be sent' plus 'Number of packets that can be sent' in last CTS just before CTS pause started. Verify DUT sends a TP.Conn_Abort when 'Next packet number to be sent' in CTS: - is less than the 'Next packet number to be sent' in last CTS before CTS pause started - is one or more greater than the sum of 'Next packet number to be sent' plus 'Number of packets that can be sent' in last CTS before CTS pause started ");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the configured non cyclic requestable PGN's with DLC>8 by TP.");
  CT_STRAT("Testnode sends request and awaits RTS.");
  CT_STRAT("Testnode sends first CTS for one data package.");
  CT_STRAT("Testnode holds connection and continues in different ways.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.3.2 - Appendix C");
  CT_DOC_21("5.10.2.4");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_09_TP_CTS_Data_After_Hold(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A07_10_TP_Multiple_CTS()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x070a, "Ensure DUT correctly handles multiple Clear to Send messages (for same RTS/CTS transport connection) received in a short time period  (DUT as Originator) ");
  CT_DESC("Verify DUT transmits a TP.Conn_Abort after it receives a second TP.CM_CTS for the same RTS/CTS connection within 750 ms (T1) of a previous TP.CM_CTS when the second TP.CM_CTS is not part of normal transport protocol procedure.  In other words the second TP.CM_CTS message is  … -  not the expected  TP.CM_CTS message that should follow the last TP.DT data packet for the previous TP.CM_CTS message. -  not the result of a 750 ms (T1) timeout (which occurs due to missing TP.DT data packet).  Verify DUT transmits a TP.Conn_Abort after it receives a second TP.CM_CTS for the same RTS/CTS connection within 1250 ms (T2) of a previous TP.CM_CTS when the second TP.CM_CTS is not part of normal transport protocol procedure.  In other words the second TP.CM_CTS is  …   -  not the expected TP.CM_CTS message which should follow the last TP.DT data packet associated with the first TP.CM_CTS message.   -  not the result of a 1250 ms (T2) time out (due to no TP.DT data packet following the last TP.CM_CTS).   -  not the result of a 750 ms (T1) time out (due to missing TP.DT data packet). ");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Order first packet with CTS and disturb second CTS for the rest of packets with a wrong CTS within T1 and T2.");
  CT_STRAT("DUT has to abort this behaviour.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.3.2");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_10_TP_Multiple_CTS(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A07_11_TP_CTS_Outside()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x070b, "Ensure DUT ignores a Clear to Send outside of an RTS/CTS transport connection (DUT as Originator)");
  CT_DESC("Ensure DUT ignores a Clear to Send outside of an RTS/CTS transport connection ");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Send a normal RTS/CTS TP to verify the CTS works inside the TP.");
  CT_STRAT("After that check if the DUT ignores CTS' outside the TP.");
  CT_STRAT("Finally do a normal TP again to verify that the outstanding CTS did not disturb subsequent TPs.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.3.2");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_11_TP_CTS_Outside(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A07_12_TP_First_DT()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x070c, "Timing of first Transport Data Packets for RTS/CTS following CTS  (DUT as Originator) ");
  CT_DESC("Verify DUT sends the first TP.DT data packet within 200 ms (Tr) after receiving the CTS ");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Send a normal RTS/CTS TP to inspect the time between CTS and first DT.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.3");
  CT_DOC_21("5.10.2.4 - Figure C1");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_12_TP_First_DT(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A07_13_TP_Requested_DTs()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x070d, "Only sends TP.DT Data Packets cleared by CTS (DUT as Originator)");
  CT_DESC("Verify DUT only sends the TP.DT data packets beginning with the packet specified by 'Next packet number to be sent' and continuing through the number of packets specified in 'Number of packets that can be sent' in the last CTS ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Order a single packet with CTS.");
  CT_STRAT("Order the rest of the packets and check for the proper DT's are sent.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.1.3");
  CT_DOC_21("5.10.4");

  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_13_TP_Requested_DTs(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A07_14_TP_Data_Content()
{
  // give title and description for this testcase
  CT_BEGIN(0x070e, "Ensure DUT transmits Transport Data Packets for RTS/CTS transport connection which have correct data content ");
  CT_DESC("Verify first data byte is Sequence Number in each TP.DT data packet for the RTS/CTS transport connection. Verify remaining 7 bytes of each TP.DT data packet for the RTS/CTS transport connection contain the correct data for the packet. ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured fixed PGN with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request the fixed pgn and check the content against the given configured data.");
  CT_STRAT("Check the DT packets first byte to be a sequence of 1 to n.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.1.3");
  CT_DOC_21("5.10.4");

  CTF_A07_14_TP_Data_Content(gTOOL_Addr, gDUT_Addr);
  
  // end the testcase.
  CT_END();
}


// ==============================================================================================================
export testcase CTC_A07_15_TP_DT_Sequence()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x070f, "Ensure DUT sends Transport Data Packets for RTS/CTS transport connection in sequential order  (DUT as Originator) ");
  CT_DESC("Verify DUT sends the TP.DT data packets for the RTS/CTS transport connection in ascending sequential order (beginning with Sequence Number = ‘1’, and counting up).");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request pgns and check for the sequence numbers within the DT packets.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.1.2");
  CT_DOC_21("5.10.1.3");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_15_TP_DT_Sequence(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}




// ==============================================================================================================
export testcase CTC_A07_16_TP_DT_Timeout()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0710, "Time between consecutive Transport Data Packets for RTS/CTS when CTS allows more than 1 packet (DUT as Originator)");
  CT_DESC("Verify DUT sends each consecutive TP.DT data packet for a CTS no more than 200 ms (Tr) after the previous TP.DT data packet");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request pgns and check for the sequence numbers within the DT packets.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.1.3");
  CT_DOC_21("5.10.2.4");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_16_TP_DT_Timeout(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_17_TP_DT_DLC()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0711, "Ensure DUT transmits all Transport Data Packets with an 8-byte data field  (DUT as Originator)");
  CT_DESC("Verify DUT transmits all TP.DT data packets for an RTS/CTS transport connection with a Data Length Code of 8 bytes");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request pgns and check the DT's DLC to be 8.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.2.7.2");
  CT_DOC_21("5.10.1.3");
  CT_DOC_21("5.10.4");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_17_TP_DT_DLC(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_18_TP_DT_Padding()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0712, "Unused bytes of Last Transport Data Packets for RTS/CTS filled with 0xFF (DUT as Originator)");
  CT_DESC("Verify last TP.DT data packet for RTS/CTS is sent with an 8 byte data field and the unused bytes of that packet are filled with 0xFF");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request pgns and check the padding bytes of the last TP.DT.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.2.7.2");
  CT_DOC_21("5.10.1.3");
  CT_DOC_21("5.10.4");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_18_TP_DT_Padding(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_19_TP_DT_Prio()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0713, "Priority of Data Transfer messages for RTS/CTS (DUT as Originator)");
  CT_DESC("Verify DUT sends each TP.DT message for RTS/CTS using a priority of 7.");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Request pgns and check the prio of the TP.DT's to be 7.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.4 - Figure 16");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_19_TP_DT_Prio(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_20_TP_EOM_P01_Normal()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071401, "Ensure DUT receives TP.CM_EndOfMsgACK message and acts appropriately (DUT as Originator); and Ensure DUT  T4 timing following the last ‘hold connection’ message. ");
  CT_DESC("Verify DUT behavior when it receives TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. Verify DUT sends a TP.Conn_Abort when it does not receive TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. If Responder transmits any 'hold connection' TP.CM_CTS messages after the final TP.DT data packet, verify DUT sends a TP.Conn_Abort if it does not receive a TP.CM_EndOfMsgACK message within 1050 ms (T4) following the last 'hold connection' TP.CM_CTS message. Verify DUT ignores a TP.CM_EndOfMsgACK message when it is received prior to the final TP.DT data packet. Verify DUT inspects PGN (including DP and EDP) in the TP.CM_EndOfMsgACK.");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Check the normal transport.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.3 - Appendix C1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_20_EOM_P01_Normal(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_20_TP_EOM_P02_Abort_Missing_EOM()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071402, "Ensure DUT receives TP.CM_EndOfMsgACK message and acts appropriately (DUT as Originator); and Ensure DUT  T4 timing following the last ‘hold connection’ message. ");
  CT_DESC("Verify DUT behavior when it receives TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. Verify DUT sends a TP.Conn_Abort when it does not receive TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. If Responder transmits any 'hold connection' TP.CM_CTS messages after the final TP.DT data packet, verify DUT sends a TP.Conn_Abort if it does not receive a TP.CM_EndOfMsgACK message within 1050 ms (T4) following the last 'hold connection' TP.CM_CTS message. Verify DUT ignores a TP.CM_EndOfMsgACK message when it is received prior to the final TP.DT data packet. Verify DUT inspects PGN (including DP and EDP) in the TP.CM_EndOfMsgACK.");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(1, "Check if DUT aborts missing EOM");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.3 - Appendix C1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_20_EOM_P02_Abort_Missing_EOM(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_20_TP_EOM_P03_DP()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071403, "Ensure DUT receives TP.CM_EndOfMsgACK message and acts appropriately (DUT as Originator); and Ensure DUT  T4 timing following the last ‘hold connection’ message. ");
  CT_DESC("Verify DUT behavior when it receives TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. Verify DUT sends a TP.Conn_Abort when it does not receive TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. If Responder transmits any 'hold connection' TP.CM_CTS messages after the final TP.DT data packet, verify DUT sends a TP.Conn_Abort if it does not receive a TP.CM_EndOfMsgACK message within 1050 ms (T4) following the last 'hold connection' TP.CM_CTS message. Verify DUT ignores a TP.CM_EndOfMsgACK message when it is received prior to the final TP.DT data packet. Verify DUT inspects PGN (including DP and EDP) in the TP.CM_EndOfMsgACK.");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Check if DUT ignores DP in EOM - it should ABORT due in the case above this is checked it does");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.3 - Appendix C1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_20_EOM_P03_DP(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_20_TP_EOM_P04_EDP()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071404, "Ensure DUT receives TP.CM_EndOfMsgACK message and acts appropriately (DUT as Originator); and Ensure DUT  T4 timing following the last ‘hold connection’ message. ");
  CT_DESC("Verify DUT behavior when it receives TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. Verify DUT sends a TP.Conn_Abort when it does not receive TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. If Responder transmits any 'hold connection' TP.CM_CTS messages after the final TP.DT data packet, verify DUT sends a TP.Conn_Abort if it does not receive a TP.CM_EndOfMsgACK message within 1050 ms (T4) following the last 'hold connection' TP.CM_CTS message. Verify DUT ignores a TP.CM_EndOfMsgACK message when it is received prior to the final TP.DT data packet. Verify DUT inspects PGN (including DP and EDP) in the TP.CM_EndOfMsgACK.");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Check if DUT ignores EDP in EOM - it should ABORT due in the case above this is checked it does");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.3 - Appendix C1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_20_EOM_P04_EDP(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_20_TP_EOM_P05_CTS_Hold()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071405, "Ensure DUT receives TP.CM_EndOfMsgACK message and acts appropriately (DUT as Originator); and Ensure DUT  T4 timing following the last ‘hold connection’ message. ");
  CT_DESC("Verify DUT behavior when it receives TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. Verify DUT sends a TP.Conn_Abort when it does not receive TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. If Responder transmits any 'hold connection' TP.CM_CTS messages after the final TP.DT data packet, verify DUT sends a TP.Conn_Abort if it does not receive a TP.CM_EndOfMsgACK message within 1050 ms (T4) following the last 'hold connection' TP.CM_CTS message. Verify DUT ignores a TP.CM_EndOfMsgACK message when it is received prior to the final TP.DT data packet. Verify DUT inspects PGN (including DP and EDP) in the TP.CM_EndOfMsgACK.");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Check if DUT does respect a CTS hold just before EOM");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.3 - Appendix C1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_20_EOM_P05_CTS_Hold(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}



// ==============================================================================================================
export testcase CTC_A07_20_TP_EOM_P06_Ignore_Extra_EOM()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071406, "Ensure DUT receives TP.CM_EndOfMsgACK message and acts appropriately (DUT as Originator); and Ensure DUT  T4 timing following the last ‘hold connection’ message. ");
  CT_DESC("Verify DUT behavior when it receives TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. Verify DUT sends a TP.Conn_Abort when it does not receive TP.CM_EndOfMsgACK message within 1250 ms (T3) following the final TP.DT data packet. If Responder transmits any 'hold connection' TP.CM_CTS messages after the final TP.DT data packet, verify DUT sends a TP.Conn_Abort if it does not receive a TP.CM_EndOfMsgACK message within 1050 ms (T4) following the last 'hold connection' TP.CM_CTS message. Verify DUT ignores a TP.CM_EndOfMsgACK message when it is received prior to the final TP.DT data packet. Verify DUT inspects PGN (including DP and EDP) in the TP.CM_EndOfMsgACK.");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Check if DUT does ignore EOM's sent in between every possible situation within the transport.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.4");
  CT_DOC_21("5.10.3");
  CT_DOC_21("5.10.3.3 - Appendix C1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_20_EOM_P06_Ignore_Extra_EOM(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}




// ==============================================================================================================
export testcase CTC_A07_21_TP_Originator_Abort()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0715, "RTS/CTS Transport: Ensure DUT properly issues a RTS/CTS Connection Abort (DUT as Originator)");
  CT_DESC("Verify DUT transmits a TP.Conn_Abort for the correct PGN containing a valid ‘Connection Abort Reason’ parameter and sends it to the correct Destination Address (must be a specific address; cannot be sent to the Global Address FF16). Verify DUT does not send a TP.Conn_Abort if it does not receive a TP.CM_CTS for the DUT’s first TP.CM_RTS prior to 1250 ms (T3) expiring (i.e. connection never established). ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Create situation where the DUT shall abort with reason 3,4 or 5.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3.4");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_21_TP_Originator_Abort(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}





// ==============================================================================================================
export testcase CTC_A07_22_TP_Behaviour_After_Receiver_Abort()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0716, "RTS/CTS Transport: Ensure DUT receives Connection Abort which is issued by RTS/CTS Receiver after DUT’s initial Clear to Send  (also see Row 4) (DUT as Originator)");
  CT_DESC("Verify DUT’s behavior when it receives a TP.Conn_Abort message after the first TP.CM_CTS message (in response to the first TP.CM_RTS message) and before the TP.CM_EndOfMsgACK message. Verify DUT inspects the PGN (including DP and EDP) in the TP.Conn_Abort. Verify DUT stops transmitting TP.DT data packets within 50 ms following the TP.Conn_Abort message Verify DUT transmits no more than 32 TP.DT data packets following the TP.Conn_Abort ");
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Start request, await the first TP.DT and abort the TP. Inspect the behaviour within 50ms after aborting.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.2.2");
  CT_DOC_21("5.10.2.4");
  CT_DOC_21("5.10.3.4");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_22_TP_Behaviour_After_Receiver_Abort(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}





// ==============================================================================================================
export testcase CTC_A07_23_TP_Singularity()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0717, "RTS/CTS Transport: Ensure DUT doesn’t attempt to create two RTS/CTS transport connections with a single Controller Application  (DUT as Originator) ");
  CT_DESC("Verify DUT does not send a TP.CM_RTS message to the same Responder (based on Destination Address) for any PGN while the DUT currently has another RTS/CTS transport connection open with same Responder. ");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Start request, await the first TP.DT and immediately send a second request.");
  CT_STRAT("After the first request was answered completely, check that DUT didn't send TP.CM_RTS within the running transport.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_23_TP_Singularity(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}





// ==============================================================================================================
export testcase CTC_A07_24_TP_Simultaneous_TX()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0718, "RTS/CTS Transport: Ensure the DUT can support multiple RTS/CTS transport connections with different Responders (DUT as Originator) ");
  CT_DESC("Verify DUT can support simultaneous RTS/CTS transport connections with different Responders  (based on Source Address and Destination Address combination).");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Start one request from TOOL (TP1) and immediately another request from a third node (TP2).");
  CT_STRAT("Await TP1 ended and check the start of TP2 lies in between TP1.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5.1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_24_TP_Simultaneous_TX(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}





// ==============================================================================================================
export testcase CTC_A07_25_TP_Simultaneous_TX_RX()
{
  struct gPGAttrs reqPgis[long];
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x0719, "RTS/CTS Transport: Simultaneous RTS/CTS As Originator and Responder (DUT as Originator) ");
  CT_DESC("Verify ability of DUT to support simultaneous RTS/CTS transports with different ECUs where DUT is Originator in one RTS/CTS and DUT is Responder in the other RTS/CTS");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Start one request from TOOL (TP1) and immediately start an RTS from a third node (TP2) the DUT has to repond to.");
  CT_STRAT("Await TP1 ended and check the start of TP2 lies in between TP1.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5.1");
  
  CT_GetReqPGIs(reqPgis, gNonCyclic, gDLCx);
  CT_GetRTSCTSPGIs(reqPgis, pgis);
  CTF_A07_25_TP_Simultaneous_TX_RX(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}





// ==============================================================================================================
export testcase CTC_A07_26_TP_Simultaneous_TX_BAM()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071a, "RTS/CTS Transport: Simultaneous RTS/CTS And BAM with DUT as Originator of each Transport (DUT as Originator) ");
  CT_DESC("Verify ability of DUT to support simultaneous RTS/CTS and BAM transports where the DUT is the Originator of both the RTS/CTS and the BAM transports ");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Start one request from TOOL (TP1) and immediately a global request from a third node (TP2).");
  CT_STRAT("Await TP1 ended and check the start of TP2 lies in between TP1.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5.1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_26_TP_Simultaneous_TX_BAM(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}





// ==============================================================================================================
export testcase CTC_A07_27_TP_Simultaneous_TX_RX_BAM()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071b, "RTS/CTS Transport: Simultaneous RTS/CTS And BAM As RTS/CTS Originator and BAM Responder (DUT as Originator) ");
  CT_DESC("Verify ability of DUT to support simultaneous RTS/CTS and BAM transports where the DUT is the Originator of the RTS/CTS transport and DUT is the Responder of the BAM transport ");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond with TP to the configured requestable PGNs with DLC>8.");
  
  // describe the strategy...
  CT_STRAT(-1, "Start one request from TOOL (TP1) and immediately start an Commanded Address from a third node (TP2).");
  CT_STRAT("TP1 will be interrupted due the DUT changes its address. A change back within TR is nearly impossible.");
  CT_STRAT("So await the the reaction of the Commanded Address (DUT receives BAM) and use this as end of the TP1.");
  CT_STRAT("Check that the BAM init lies within the start of TP1 and the moment where the DUT changed its address.");
  CT_STRAT("Also reset the DUT's address by using another Commanded Address.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "5.10.5.1");
  
  CT_GetReqPGIs(pgis, gNonCyclic, gDLCx);
  CTF_A07_27_TP_Simultaneous_TX_RX_BAM(gTOOL_Addr, gDUT_Addr, pgis);
  
  // end the testcase.
  CT_END();
}





// ==============================================================================================================
export testcase CTC_A07_28_TP_Component_ID_Format()
{
  struct gPGAttrs pgis[long];
  
  // give title and description for this testcase
  CT_BEGIN(0x071c, "CTS/RTS Transport: Ensure the ability to send the Component ID PGN for more than one device.");
  CT_DESC("Verify DUT formatting of Controller Application Identity for each iteration of the applicable PGN received from a source address.");  
  
  // describe the preconditions of the test.
  CT_PRECOND(1, "DUT can respond to the request of the Component ID PGN.");
  
  // describe the strategy...
  CT_STRAT(-1, "Request the Component ID PGN from the DUT.");
  CT_STRAT("Check the response contains 4 asterisk-delimiter bytes within the responding payload.");
  
  // note the reference to documents / specifications
  CT_DOC_21(1, "Different locations");
  
  CTF_A07_28_TP_Component_ID_Format(gTOOL_Addr, gDUT_Addr);
  
  // end the testcase.
  CT_END();
}
