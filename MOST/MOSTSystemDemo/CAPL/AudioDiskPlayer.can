/*@!Encoding:1252*/
includes
{
  #include "MostDefs.cin"
  #include "FCatDefs.cin"
}

//
// Simulation of a MOST AudioDiskPlayer FBlock (with disc changer capability)
//
variables
{
  // Application phase
  const byte kAppOff      = 0; // no power; no communication
  const byte kAppOn       = 1; // power on
  const byte kAppShutdown = 2; // power on; shutdown started
  byte  gAppPhase = kAppOff;


  // Property: TimePosition
  mstimer tTimePosition;
  const dword kTimePositionCycle = 1000; // update cycle for time position


  // Property: MediaInfo
  // virtual magazine
  const long kMediaInfoSize = 6;  // maximum number of CDs of the changer
  // media info will be derived from gAudioDiskInfoAudioTime[] 
  // as soon as the magazine is loaded
  word  gMediaInfoMediaType[kMediaInfoSize];
  word  gMediaInfoMediaFilesystem[kMediaInfoSize];
  word  gMediaInfoFirstTrack[kMediaInfoSize];
  word  gMediaInfoLastTrack[kMediaInfoSize];
  dword gMediaInfoPlayTime[kMediaInfoSize];
  // MediaTitles are fix for simulation
  char  gMediaInfoMediaTitle[kMediaInfoSize][50] = {
    "Pink Floyd - The Wall",
    "Beethoven - 9. Symphonie",
    "Metallica - Reload",
    "Depeche Mode  - Violator",
    "Badesalz - Diwodaso",
    "Mike Oldfield - Tubular Bells"};


  // Property: AudioDiskInfo
  // virtual CDs
  const long kAudioDiskInfoSize = 10; // maximum number of titles on a CD
  // title length of virtual CDs in ms
  dword gAudioDiskInfoAudioTime[kMediaInfoSize][kAudioDiskInfoSize] = {
    { 10000,  9000, 12000,  9000,  8000,     0,     0,     0,     0,     0 },
    { 15000, 14000, 13000, 12000,     0,     0,     0,     0,     0,     0 },
    {     0,     0,     0,     0,     0,     0,     0,     0,     0,     0 },
    { 13000, 11000,  5000, 10000, 19000,  9000,     0,     0,     0,     0 },
    {     0,     0,     0,     0,     0,     0,     0,     0,     0,     0 },
    {  8000,     0,     0,     0,     0,     0,     0,     0,     0,     0 }};
  char  gAudioDiskInfoAudioTitle[kMediaInfoSize][kAudioDiskInfoSize][50] = {
    { "Another Brick in the Wall", "Goodbye blue Sky", "The thin Ice", "Empty Spaces", "Don't leave me now", "", "", "", "", "" },
    { "First Movement", "Second Movement", "Third Movement", "Fourth Movement", "", "", "", "", "", "" },
    { "Fuel", "The Memory Remains", "Low Man's Lyric", "Attitude", "", "", "", "", "", "" },
    { "World In My Eyes", "Sweetest Perfection", "Personal Jesus", "Halo", "Waiting For The Night", "Enjoy The Silence", "", "", "", "" },
    { "In Der Waschaalaach", "Verirrt", "Hessi James", "Alles Wie Vorher", "", "", "", "", "", "" },
    { "Part One", "Part Two", "", "", "", "", "", "", "", "" }};


  // Method: Allocate / DeAllocate
  long    gAllocState = 0; // 0: no allocation; 1: allocating; 2: allocated; 3: deallocating
  mostAMSMessage AudioDiskPlayer.Allocate.Result gMsgAllocateRes; // store allocation parameters here
  mostAMSMessage AudioDiskPlayer.DeAllocate.Result gMsgDeAllocateRes;

  mostAMSMessage AudioDiskPlayer.AllocateLabel.ResultAck gMsgAllocateLabelRes; // store allocation parameters here

  const long kLabelWidth = 4;

  // Property: PeakLevel
  msTimer tPeakLevel;
  const long kPeakLevelCycle = 300; // in ms

  long gSpeedGrade;
}


on mostAMSMessage AudioDiskPlayer.SourceActivity.StartResult
{
  mostAMSMessage AudioDiskPlayer.SourceActivity.Result msgRes;
  byte disc, bFail;
  word track;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 2))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // this player has one source only
  if(this.SourceNr != 0x01)
  {
    mostSendError_CodeByteByte(this, kErrParamNotAvailable, 1, this.SourceNr);
    return;
  }

  if(this.Activity > 2)
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 2, this.Activity);
    return;
  }
  
  // source not allocated
  if(gAllocState != 2)
  {
    // since no channels allocated, no source can be activated
    mostSendError_CodeByteByte(this, kErrParamNotAvailable, 1, this.SourceNr);
    return;
  }

  bFail = 0;
  switch(this.Activity)
  {
    case 0: // Off
    {
      @sysvar::CDC::ADP_DeckStatus = 1;
      break;
    }
    case 1: // Pause
    {
      @sysvar::CDC::ADP_DeckStatus = 2;
      break;
    }
    case 2: // On
    {
      // start playing
      disc = @sysvar::CDC::ADP_ActiveDisk;
      track = @sysvar::CDC::ADP_TrackPosition;
      if(!IsTrackPositionValid(disc, track))
      {
        // track number not available -> search next disc
        disc = NextDiscNumber();
        track = 1;
        if(disc == 0)
          bFail = 1;
      }

      if(!bFail)
      {
        // start playback
        @sysvar::CDC::ADP_DeckStatus = 0;
      }
      break;
    }
  }

  if(bFail)
  {
    mostSendError_CodeByteByte(this, kErrParamNotAvailable, 1, this.SourceNr);
    return;
  }
  else
  {
    // this is just a simulation; send result immediately
    msgRes.DA = this.SA;
    msgRes.InstanceId = this.InstanceId;
    msgRes.SourceNr = this.SourceNr;
    msgRes.Activity = this.Activity;
    output(msgRes);
  }

  //}}} --- end application section -------------
}


on mostAMSMessage AudioDiskPlayer.Allocate.StartResult
{
  long chn[4];
  long i;

  //{{{ --- begin default code ------------------

  if(!CheckValidReception(this))
    return;
  if(!CheckMsgLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // this player has one source only
  if(this.SourceNr != 0x01)
  {
    mostSendError_CodeByteByte(this, kErrParamNotAvailable, 1, this.SourceNr);
    return;
  }

  if(gAllocState != 0)
  {
    // allocation already in progress
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // store address of initiator
  gMsgAllocateRes.DA = this.SA;

  // call synchronous channel allocation service
  // OnMostSyncAllocResult() will be invoked on completion or timeout
  if((kMost25 == gSpeedGrade) && (0 != mostSyncAlloc(4)))
  {
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // state: allocating
  gAllocState = 1;

  if (kMost25 != gSpeedGrade)
  {
    // simulate allocation of 4 channels
    for (i = 0; i < elcount(chn); ++i)
    {
      chn[i] = i;
    }

    OnMostSyncAllocResult(1, 4, chn);
  }


  //}}} --- end application section -------------
}

on preStart
{
  // configure CAPL node as application node (don't receive spy messages...)
  mostApplicationNode();

  // configure FBlock AudioDiskPlayer
  ConfigureFBlock();

}


long CheckNormalOperation()
{
  // Description:
  //   Checks if FBlock is able to process commands
  // Return:
  //   0: failed; 1: Ok

  //{{{ --- begin application section -----------

  return (kAppOff != gAppPhase);

  //}}} --- end application section -------------

}


on mostAMSMessage AudioDiskPlayer.TrackPosition.Get
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(0 == @sysvar::CDC::ADP_ActiveDisk)
  {
    // no disk in drive
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_TrackPosition(this.SA);

  //}}} --- end default code --------------------
}


on mostAMSMessage AudioDiskPlayer.TrackPosition.Set
{
  byte disc;
  word newtrack;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 2))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  newtrack = this.Track;
  disc = @sysvar::CDC::ADP_ActiveDisk;

  // verify track
  if(!IsTrackPositionValid(disc, newtrack))
  {
    mostSendError_CodeByteWord(this, kErrParamWrong, 1, newtrack);
    return;
  }

  // set TrackPosition
  @sysvar::CDC::ADP_TrackPosition = newtrack;

  if(@sysvar::CDC::ADP_DeckStatus == 0) // play
  {
    // start playback
    PlaybackStartTrack(disc, newtrack);
  }

  //}}} --- end application section -------------
}


on mostAMSMessage AudioDiskPlayer.TrackPosition.SetGet
{
  byte disc;
  word newtrack;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 2))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  newtrack = this.Track;
  disc = @sysvar::CDC::ADP_ActiveDisk;

  // verify track
  if(!IsTrackPositionValid(disc, newtrack))
  {
    mostSendError_CodeByteWord(this, kErrParamWrong, 1, newtrack);
    return;
  }

  // set TrackPosition
  @sysvar::CDC::ADP_TrackPosition = newtrack;

  if(@sysvar::CDC::ADP_DeckStatus == 0) // play
  {
    // start playback
    PlaybackStartTrack(disc, newtrack);
  }

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_TrackPosition(this.SA);

  //}}} --- end default code --------------------
}


on mostAMSMessage AudioDiskPlayer.TrackPosition.Increment
{
  byte disc;
  word newtrack;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  disc = @sysvar::CDC::ADP_ActiveDisk;
  if(!IsDiscValid(disc))
  {
    // no disk in drive
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // next track
  newtrack = @sysvar::CDC::ADP_TrackPosition;
  newtrack += this.NSteps;
    
  // verify track
  if(newtrack > gMediaInfoLastTrack[disc-1])
    newtrack = gMediaInfoLastTrack[disc-1];

  // set TrackPosition
  @sysvar::CDC::ADP_TrackPosition = newtrack;

  if(@sysvar::CDC::ADP_DeckStatus == 0) // play
  {
    // start playback
    PlaybackStartTrack(disc, newtrack);
  }

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_TrackPosition(this.SA);

  //}}} --- end default code --------------------
}


on mostAMSMessage AudioDiskPlayer.TrackPosition.Decrement
{
  byte disc;
  word newtrack;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  disc = @sysvar::CDC::ADP_ActiveDisk;
  if(!IsDiscValid(disc))
  {
    // no disk in drive
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // next track
  newtrack = @sysvar::CDC::ADP_TrackPosition;
  newtrack -= this.NSteps;
  
  // verify track
  if(newtrack < gMediaInfoFirstTrack[disc-1])
    newtrack = gMediaInfoFirstTrack[disc-1];

  // set TrackPosition
  @sysvar::CDC::ADP_TrackPosition = newtrack;

  if(@sysvar::CDC::ADP_DeckStatus == 0) // play
  {
    // start playback
    PlaybackStartTrack(disc, newtrack);
  }

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_TrackPosition(this.SA);

  //}}} --- end default code --------------------
}


long SendStatus_TrackPosition(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)

  //{{{ --- begin default code ------------------

  mostAMSMessage AudioDiskPlayer.TrackPosition.Status msg;
  
  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // assemble status message
  msg.Track = @sysvar::CDC::ADP_TrackPosition;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------

}


on mostAMSMessage AudioDiskPlayer.DeAllocate.StartResult
{
  long label;
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // this player has one source only
  if(this.SourceNr != 0x01)
  {
    mostSendError_CodeByteByte(this, kErrParamNotAvailable, 1, this.SourceNr);
    return;
  }

  if(gAllocState != 2)
  {
    // nothing allocated
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // call synchronous channel allocation service
  // OnMostSyncDeallocResult() will be invoked on completion or timeout
  if((kMost25 == gSpeedGrade) && (0 != mostSyncDealloc(gMsgAllocateRes.byte(2))))
  {
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // stop playing
  PlaybackStop();

  // state: deallocating
  gAllocState = 3;

  // store address of initiator
  gMsgDeAllocateRes.DA = this.SA;

  if(kMost50 == gSpeedGrade || kMost150 == gSpeedGrade)
  {
    label = gMsgAllocateLabelRes.byte(2);
    if(!isSimulated())
    {
      MostSetSyncAudio(MostGetChannel(), label, 4, 0, 0);
    }
    OnMostSyncDeallocResult(1, label); 
  }

  //}}} --- end application section -------------
}


on mostAMSMessage AudioDiskPlayer.DeckEvent.Get
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  // reply status
  SendStatus_DeckEvent(this.SA);

  //}}} --- end default code --------------------
}


long SendStatus_DeckEvent(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)
  
  //{{{ --- begin default code ------------------
  mostAMSMessage AudioDiskPlayer.DeckEvent.Status msg;

  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // assemble status message
  msg.DeckEvent =  @sysvar::CDC::ADP_DeckEvent;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------
}


long SendStatus_MediaEvent(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)
  
  //{{{ --- begin default code ------------------
  mostAMSMessage AudioDiskPlayer.MediaEvent.Status msg;

  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // assemble status message
  msg.MediaEvent = @sysvar::CDC::ADP_MediaEvent;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------

}


on mostAMSMessage AudioDiskPlayer.MediaEvent.Get
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  // reply status
  SendStatus_MediaEvent(this.SA);

  //}}} --- end default code --------------------
}


long SendStatus_MediaInfo(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)
  
  //{{{ --- begin default code ------------------
  mostAMSMessage AudioDiskPlayer.MediaInfo.Status msg = { DLC = 1000 };

  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------

 
  //{{{ --- begin application section -----------

  // assemble status message
  FillMediaInfoStatusMsg(msg);
    
  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------
  
  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------
}


long SendStatus_ActiveDisk(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)

  //{{{ --- begin default code ------------------

  mostAMSMessage AudioDiskPlayer.ActiveDisk.Status msg;

  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------

  //{{{ --- begin application section -----------

  // assemble status message
  msg.MagazinPos = @sysvar::CDC::ADP_ActiveDisk;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // send message
  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------
}


long SendStatus_MagazineStatus(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)
  
  //{{{ --- begin default code ------------------
  mostAMSMessage AudioDiskPlayer.MagazineStatus.Status msg;

  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // assemble status message
  msg.MagazineStatus = @sysvar::CDC::ADP_MagazineStatus;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------
}


long SendStatus_Random(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)

  //{{{ --- begin default code ------------------

  mostAMSMessage AudioDiskPlayer.Random.Status msg;

  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // assemble status message
  msg.RandomState = @sysvar::CDC::ADP_Random;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------

}

long SendStatus_Scan(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)

  //{{{ --- begin default code ------------------

  mostAMSMessage AudioDiskPlayer.Scan.Status msg;
  
  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // assemble status message
  msg.ScanState = @sysvar::CDC::ADP_Scan;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------
}

on start
{
  // display InstId in panel
  @sysvar::CDC::ADP_InstId = mostApGetInstId();

  // Property: MagazineStatus

  // simulate loaded magazine
  @sysvar::CDC::ADP_MagazineStatus = 0x01;
}


on sysvar CDC::ADP_MagazineStatus
{
  long numbytes;
  byte buffer[500];

  //{{{ --- begin application section -----------
 
  // simulate actions when magazine status changes

  switch(@sysvar::CDC::ADP_MagazineStatus)
  {
    case 0x01:
    {
      // magazine loaded

      // calculate media info from simulated discs
      MediaInfoCalculate();

      // update property MediaInfo
      SendStatus_MediaInfo(kAsNtfDestAdr);

      // update property ActiveDisk
      @sysvar::CDC::ADP_ActiveDisk = NextDiscNumber();

      // update property MediaEvent
      @sysvar::CDC::ADP_MediaEvent = 0; // Normal Operation

      // update property DeckStatus
      @sysvar::CDC::ADP_DeckStatus = 1; // Stop

      break;
    }
    default:
    { 
      // magazine not loaded
      PlaybackStop();

      // calculate media info from simulated discs
      MediaInfoCalculate();

      // update property MediaInfo
      SendStatus_MediaInfo(kAsNtfDestAdr);

      // stop current track
      canceltimer(tTimePosition); 

      // update property ActiveDisk
      @sysvar::CDC::ADP_ActiveDisk = 0;

      // update property MediaEvent
      @sysvar::CDC::ADP_MediaEvent = 6; // Disk not available

      break;
    }
  }

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // send status message to all notification clients
  SendStatus_MagazineStatus(kAsNtfDestAdr);

  //}}} --- end default code --------------------
}


on sysvar CDC::ADP_Random
{
  //{{{ --- begin default code ------------------

  // send status message to all notification clients
  SendStatus_Random(kAsNtfDestAdr);

  //}}} --- end default code --------------------
}


on sysvar CDC::ADP_Scan
{
  //{{{ --- begin default code ------------------

  // send status message to all notification clients
  SendStatus_Scan(kAsNtfDestAdr);

  //}}} --- end default code --------------------
}


long IsDiscValid(long disc)
{
  // Description:
  //   Checks if disc is available.
  // Parameter:
  //   disc   disc number
  // Return:
  //   0: failed; 1: Ok

  if(!IsMagazineLoaded())
    return 0;

  if((disc > 0) && (disc <= kMediaInfoSize))
  {
    // is there a disc at the current magazine position
    if(gMediaInfoMediaType[disc-1] != 0)
      return 1;
  }
  return 0;
}


long NextDiscNumber ()
{
  // Description:
  //   Returns the next disc number.
  //   Wraps around if kMediaInfoSize is reached.
  // Return: 
  //   Disc number or 0 if there is no disc/magazine inserted.

  long current, next;

  if(!IsMagazineLoaded())
    return 0; // magazine not loaded

  current = @sysvar::CDC::ADP_ActiveDisk;
  if(current >= kMediaInfoSize)
    current = 0;
  next = current+1;
  while(next != current)
  {
    if(gMediaInfoMediaType[next-1] != 0)
      break;
    next++;
    if(next > kMediaInfoSize) // wrap around
    {
      if(current == 0)
      {
        next = 0;
        break;
      }
      next = 1;
    }
  }

  if(next == current)
    return 0; // no disk found

  return next;
}


on mostAMSMessage AudioDiskPlayer.ActiveDisk.SetGet
{

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(!IsMagazineLoaded())
  {
    // no magazine
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // verify position
  if((this.MagazinPos == 0) || (this.MagazinPos > kMediaInfoSize))
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.MagazinPos);
    return;
  }

  // verify CD is inserted
  if(!IsDiscValid(this.MagazinPos))
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.MagazinPos);
    return;
  }

  // set property
  @sysvar::CDC::ADP_ActiveDisk = this.MagazinPos;

  // start playback
  if(@sysvar::CDC::ADP_DeckStatus == 0) // play
    PlaybackStartTrack(this.MagazinPos, 1);

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_ActiveDisk(this.SA);

  //}}} --- end default code --------------------
}


on mostAMSMessage AudioDiskPlayer.ActiveDisk.Set
{

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(!IsMagazineLoaded())
  {
    // no magazine
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // verify position
  if((this.MagazinPos == 0) || (this.MagazinPos > kMediaInfoSize))
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.MagazinPos);
    return;
  }

  // verify CD is inserted
  if(!IsDiscValid(this.MagazinPos))
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.MagazinPos);
    return;
  }

  // set property
  @sysvar::CDC::ADP_ActiveDisk = this.MagazinPos;

  // start playback
  if(@sysvar::CDC::ADP_DeckStatus == 0) // play
    PlaybackStartTrack(this.MagazinPos, 1);

  //}}} --- end application section -------------
}


long IsMagazineLoaded()
{
  // Description:
  //   Checks if magazine is loaded.
  // Return:
  //   0: failed; 1: Ok

  if(1 != @sysvar::CDC::ADP_MagazineStatus)
    return 0;
  return 1;
}


on mostAMSMessage AudioDiskPlayer.ActiveDisk.Get
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  // reply status
  SendStatus_ActiveDisk(this.SA);

  //}}} --- end default code --------------------
}


on mostAMSMessage AudioDiskPlayer.ActiveDisk.Increment
{
  byte currdisc, nextdisc;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(!IsMagazineLoaded())
  {
    // no magazine
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // check if current disc is valid
  currdisc = @sysvar::CDC::ADP_ActiveDisk;
  if(IsDiscValid(currdisc))
  {  
    // next disc
    nextdisc = currdisc + this.NSteps;

    if(!IsDiscValid(nextdisc))
    {
      nextdisc = NextDiscNumber();    // skip ahead to next valid disc
      if(!IsDiscValid(nextdisc))
        nextdisc = currdisc; // set a valid value
    }
      
  }
  else
  {
    nextdisc = 1;
    if(!IsDiscValid(nextdisc))
      nextdisc = 0; // set a valid value
  }
  
  // set property
  @sysvar::CDC::ADP_ActiveDisk = nextdisc;

  // start playback
  if(@sysvar::CDC::ADP_DeckStatus == 0) // play
    PlaybackStartTrack(nextdisc, 1);

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_ActiveDisk(this.SA);
  
  //}}} --- end default code --------------------

}


on mostAMSMessage AudioDiskPlayer.ActiveDisk.Decrement
{
  byte currdisc, nextdisc;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(!IsMagazineLoaded())
  {
    // no magazine
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // check if current disc is valid
  currdisc = @sysvar::CDC::ADP_ActiveDisk;
  if(IsDiscValid(currdisc))
  {  
    // next disc
    nextdisc = currdisc - this.NSteps;

    if(!IsDiscValid(nextdisc))
      nextdisc = currdisc; // set a valid value
  }
  else
  {
    nextdisc = 1;
    if(!IsDiscValid(nextdisc))
      nextdisc = 0; // set a valid value
  }

  // set property
  @sysvar::CDC::ADP_ActiveDisk = nextdisc;

  // start playback
  if(@sysvar::CDC::ADP_DeckStatus == 0) // play
    PlaybackStartTrack(nextdisc, 1);

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_ActiveDisk(this.SA);

  //}}} --- end default code --------------------

}

on sysvar CDC::ADP_ActiveDisk
{
  byte disc;

  //{{{ --- begin application section -----------

  disc = @sysvar::CDC::ADP_ActiveDisk;
  if(IsDiscValid(disc))
  {
    @sysvar::CDC::ADP_TrackPosition = gMediaInfoFirstTrack[disc-1];
  }
  
  TimePositionSetTrack(0);

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // send status message to all notification clients
  SendStatus_ActiveDisk(kAsNtfDestAdr);

  //}}} --- end default code --------------------
}

on sysvar CDC::ADP_DeckEvent
{
  //{{{ --- begin default code ------------------

  // send status message to all notification clients
  SendStatus_DeckEvent(kAsNtfDestAdr);

  //}}} --- end default code --------------------
}

on sysvar CDC::ADP_MediaEvent
{
  //{{{ --- begin default code ------------------

  // send status message to all notification clients
  SendStatus_MediaEvent(kAsNtfDestAdr);

  //}}} --- end default code --------------------
}

on sysvar CDC::ADP_TrackPosition
{
  //{{{ --- begin application section -----------

  if(!IsTrackPositionValid(@sysvar::CDC::ADP_ActiveDisk, @sysvar::CDC::ADP_TrackPosition))
  {
    // error: track doesn't exist
    PlaybackStop();
  }

  // start new track at position 0
  TimePositionSetTrack(0);

  //}}} --- end application section -------------

  //{{{ --- begin default code ------------------

  // send status message to all notification clients
  SendStatus_TrackPosition(kAsNtfDestAdr);

  //}}} --- end default code --------------------
}

OnMostNetState(long oldstate, long newstate)
{
  //{{{ --- begin application section -----------

  if(newstate == kNetStatePowerOff)
  {
    AppExit();
  }
  else if((newstate == kNetStateConfigOk) && (kMost25 == gSpeedGrade))
  {
    // read NDR register for SrcDelay parameter
    mostReadReg(mostGetChannel(), 1, 0x8F, 1);
  }


  // Property: Deckstatus
  if((oldstate == kNetStateConfigOk) && (newstate <= kNetStateConfigNotOk))
  {
    PlaybackStop();
  }

  //}}} --- end application section -------------
}

OnMostReg()
{
  //{{{ --- begin application section -----------

  // Method: Allocate
  long res;
  res = mostRegGetByteAbs(1, 0x8F);
  if(res >= 0)
  {
    // store node delay for SrcDelay parameter
    gMsgAllocateRes.SrcDelay = res;
  }

  //}}} --- end application section -------------
}

OnMostApInstID()
{
  // reconfigure FBlock
  ConfigureFBlock();

  // display InstId in panel
  @sysvar::CDC::ADP_InstId = mostApGetInstId();
}

on sysvar CDC::ADP_TimePosition_Track
{
  //{{{ --- begin default code ------------------

  // send status message to all notification clients
  SendStatus_TimePosition(kAsNtfDestAdr);

  //}}} --- end default code --------------------
}


long SendStatus_TimePosition(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)

  //{{{ --- begin default code ------------------

  mostAMSMessage AudioDiskPlayer.TimePosition.Status msg;
  
  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();


  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // assemble status message
  msg.PosX = 0;
  mostParamSet(msg, "Data.DiskTime", @sysvar::CDC::ADP_TimePosition_Disk);
  mostParamSet(msg, "Data.TrackTime", @sysvar::CDC::ADP_TimePosition_Track);
  mostParamSet(msg, "Data.TitleTime", @sysvar::CDC::ADP_TimePosition_Title);

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // send message

  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------
}

on mostAMSMessage AudioDiskPlayer.TimePosition.Get
{
  mostAMSmessage AudioDiskPlayer.TimePosition.Status msg;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 2))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  msg.InstanceId = mostApGetInstID();

  switch(this.PosX)
  {
  case 0: // send DiskTime, TrackTime and TitleTime
    {
      SendStatus_TimePosition(this.SA);
      break;
    }
  case 1: // send DiskTime
    {
      msg.DLC = 6;
      msg.PosX = 1;
      mostParamSet(msg, "Data.DiskTime", @sysvar::CDC::ADP_TimePosition_Disk);
      mostAsNtfOutput(this.SA, msg);
      break;
    }
  case 2: // send TrackTime
    {
      msg.DLC = 6;
      msg.PosX = 2;
      mostParamSet(msg, "Data.TrackTime", @sysvar::CDC::ADP_TimePosition_Track);
      mostAsNtfOutput(this.SA, msg);
      break;
    }
  case 3: // send TitleTime
    {
      msg.DLC = 6;
      msg.PosX = 3;
      mostParamSet(msg, "Data.TitleTime", @sysvar::CDC::ADP_TimePosition_Title);
      mostAsNtfOutput(this.SA, msg);
      break;
    }
  default:
    {
      mostSendError_CodeByteWord(this, kErrParamWrong, 1, this.Pos);
    }
  }

  //}}} --- end application section -------------
}

void MediaInfoCalculate()
{
  // Description:
  //   Fills the gMediaInfo arrays by analyzing gAudioDiskInfoAudioTime[]

  word disc, title;
  dword playtime;

  if(IsMagazineLoaded())
  {
    // check all discs
    for(disc = 0; disc < kMediaInfoSize; ++disc)
    {
      // is disc inserted?
      if(gAudioDiskInfoAudioTime[disc][0] > 0)
      {
        gMediaInfoMediaType[disc] = 1;
        gMediaInfoMediaFilesystem[disc] = 1;
        gMediaInfoFirstTrack[disc] = 1;
        
        // find last track and get play time
        playtime = 0;
        title = 0;
        while((title < kAudioDiskInfoSize) && (gAudioDiskInfoAudioTime[disc][title] != 0))
        {
          // summarize play time
          playtime = playtime + gAudioDiskInfoAudioTime[disc][title];
          // next title
          title++;
        }
        gMediaInfoLastTrack[disc] = title;
        gMediaInfoPlayTime[disc] = playtime;
      }
      else
      {
        // no disc present
        gMediaInfoMediaType[disc] = 0;
        gMediaInfoMediaFilesystem[disc] = 0;
        gMediaInfoFirstTrack[disc] = 0;
        gMediaInfoLastTrack[disc] = 0;
        gMediaInfoPlayTime[disc] = 0;
      }
    }
  }
  else
  {
    // no magazine -> no media info
    for(disc = 0; disc < kMediaInfoSize; ++disc)
    {
      gMediaInfoMediaType[disc] = 0;
      gMediaInfoMediaFilesystem[disc] = 0;
      gMediaInfoFirstTrack[disc] = 0;
      gMediaInfoLastTrack[disc] = 0;
      gMediaInfoPlayTime[disc] = 0;
    }
  }
}

on timer tTimePosition
{
  //{{{ --- begin application section -----------

  // Property: TimePosition

  dword currenttracktime, tracktime;
  long disc, track, newtrack;

  currenttracktime = @sysvar::CDC::ADP_TimePosition_Track;
  disc = @sysvar::CDC::ADP_ActiveDisk;
  track = @sysvar::CDC::ADP_TrackPosition;

  if(!IsTrackPositionValid(disc, track))
  {
    // error: playing an invalid track
    PlaybackStop();
  }
  else
  {
    // track complete?
    tracktime = gAudioDiskInfoAudioTime[disc-1][track-1]; // length of track
    if((currenttracktime + kTimePositionCycle) > tracktime)
    {
      
      // automatically play next track
      if(@sysvar::CDC::ADP_Random == 0x02) // random track on disc
      {
        // get random track
        newtrack = random(gMediaInfoLastTrack[disc-1]) + 1;
      }
      else
      {
        // next track
        newtrack = track+1;
        if(newtrack > gMediaInfoLastTrack[disc-1])
        {
          // load next disc
          disc = NextDiscNumber();
          newtrack = 1; 
        }
      }
      
      PlaybackStartTrack(disc, newtrack);
    }
    else
    {
      canceltimer(tTimePosition);
      settimer(tTimePosition, kTimePositionCycle);
      TimePositionSetTrack(currenttracktime + kTimePositionCycle);
    }
  }

  //}}} --- end application section -------------
}

on mostAMSMessage AudioDiskPlayer.MagazineStatus.Get
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  // reply status
  SendStatus_MagazineStatus(this.SA);

  //}}} --- end default code --------------------
}

long IsTrackPositionValid(long disc, long track)
{
  // Description:
  //   Checks if track is available.
  // Parameter:
  //   disc   disc number
  //   track  track number
  // Return:
  //   0: failed; 1: Ok

  if(!IsDiscValid(disc))
    return 0;
  
  if((track > 0) && (track <= kAudioDiskInfoSize))
  {
    if(gAudioDiskInfoAudioTime[disc-1][track-1] != 0)
      return 1;
  }
  return 0;
}

void PlaybackStartTrack(long disc, long track)
{
  // Description:
  //   Starts playback of a track.

  // stop current track
  canceltimer(tTimePosition);
  
  if(IsTrackPositionValid(disc, track))
  {
    // set DeckStatus
    @sysvar::CDC::ADP_DeckStatus = 0; // play

    // set internal state of device
    @sysvar::CDC::ADP_Mode = 0;

    // set ActiveDisk
    @sysvar::CDC::ADP_ActiveDisk = disc;

    // set TrackPosition
    @sysvar::CDC::ADP_TrackPosition = track;

    // set TimePosition
    TimePositionSetTrack(@sysvar::CDC::ADP_TimePosition_Track);

    // set play timer
    settimer(tTimePosition, kTimePositionCycle);

    // set peak level timer
    cancelTimer(tPeakLevel);
    setTimer(tPeakLevel, 100);
  
    if ((kMost25 != gSpeedGrade) || (isSimulated()))
    {
      // don't call HW commands for MOST 150 or in simulated mode
      return;
    }

    // demute line in
    // params: channel, device (0: line in; 1: line out), mode (0: demute; 1: mute)
    MostSetSyncMute(MostGetChannel(), 0, 0);
  }
  else
  {
    // set DeckStatus
    @sysvar::CDC::ADP_DeckStatus = 1; // stop

    // set internal state of device
    @sysvar::CDC::ADP_Mode = 1;

    // invalid track
    // set ActiveDisk
    if(!IsDiscValid(disc))
      disc = 0;
    @sysvar::CDC::ADP_ActiveDisk = disc;

    // set TrackPosition
    @sysvar::CDC::ADP_TrackPosition = 0;

    // set TimePosition
    TimePositionSetTrack(0);

    if ((kMost25 != gSpeedGrade) || (isSimulated()))
    {
      // don't call HW commands for MOST 150 or in simulated mode
      return;
    }

    // cancel routing of line in
    // params: channel, device (0: line in; 1: line out), mode (0: demute; 1: mute)
    MostSetSyncMute(MostGetChannel(), 0, 1);
  }
}

void PlaybackStop()
{
  // Description:
  //   Stops playback of a track.

  // stop play timer
  canceltimer(tTimePosition);

  // stop peak level timer
  ResetPeakLevel();

  // set DeckStatus
  @sysvar::CDC::ADP_DeckStatus = 1; // stop

  // set TrackPosition
  @sysvar::CDC::ADP_TrackPosition = 1;

  // set TimePosition
  TimePositionSetTrack(0);

  if ((kMost25 != gSpeedGrade) || (isSimulated()))
  {
    // don't call HW commands for MOST 150 or in simulated mode
    return;
  }

  // mute line in
  // params: channel, device (0: line in; 1: line out), mode (0: demute; 1: mute)
  mostSetSyncMute(mostGetChannel(), 0, 1);
}

void PlaybackPause ()
{
  // Description:
  //   Pauses playback of a track.

  // stop play timer
  canceltimer(tTimePosition);

  // stop peak level timer
  ResetPeakLevel();

  // set DeckStatus
  @sysvar::CDC::ADP_DeckStatus = 2; // pause

  if ((kMost25 != gSpeedGrade) || (isSimulated()))
  {
    // don't call HW commands for MOST 150 or in simulated mode
    return;
  }

  // demute line in
  // params: channel, device (0: line in; 1: line out), mode (0: demute; 1: mute)
  mostSetSyncMute(mostGetChannel(), 0, 1);
}

void TimePositionSetTrack(dword tracktime)
{
  // Description:
  //   Sets the track time of property TimePosition
  //   DiskTime and TitleTime will be calculated from TrackTime
  //   and the title play times.

  dword disctime;
  byte disc, i;
  word track;

  // disk time calculation
  disc = @sysvar::CDC::ADP_ActiveDisk;
  track = @sysvar::CDC::ADP_TrackPosition;
  disctime = 0;
  if(IsTrackPositionValid(disc, track))
  {
    for(i = 1; i < track; ++i)
      disctime = disctime + gAudioDiskInfoAudioTime[disc-1][i-1];
    disctime = disctime + tracktime;
  }

  // set disk time
  @sysvar::CDC::ADP_TimePosition_Disk = disctime;

  // set title time; same as track time here
  @sysvar::CDC::ADP_TimePosition_Title = tracktime;

  // set track time
  @sysvar::CDC::ADP_TimePosition_Track = tracktime;
}

void RoutingEngineSet(long channels[])
{
  // Description:
  //   Routes line-in of the interface hardware onto 4 synchronous channels.
  //   Prerequisit: Channel numbers are stored in gMsgAllocateRes

  if ((kMost25 != gSpeedGrade) || (isSimulated()))
  {
    // don't call HW commands for MOST 150 or in simulated mode
    return;
  }

  // route line in
  // params: channel, syncchannels, device (0: line in; 1: line out), mode (0: mute; 1: on)
  mostSetSyncAudio(mostGetChannel(), channels, 0, 1); 

  // volume
  // params: channel, device (0: line in; 1: line out), volume (0...255 = 100%)
  mostSetSyncVolume(mostGetChannel(), 0, 255);
}

void RoutingEngineReset()
{
  // Description:
  //   Resets the line-in routing of the interface hardware.

  long chn[4];
  chn[0] = gMsgAllocateRes.byte(2);
  chn[1] = gMsgAllocateRes.byte(3);
  chn[2] = gMsgAllocateRes.byte(4);
  chn[3] = gMsgAllocateRes.byte(5);

  if ((kMost25 != gSpeedGrade) || (isSimulated()))
  {
    // don't call HW commands for MOST 150 or in simulated mode
    return;
  }

  // mute line in
  // params: channel, syncchannels, device (0: line in; 1: line out), mode (0: mute; 1: on)
  mostSetSyncAudio(mostGetChannel(), chn, 0, 0); 
}

on mostAMSMessage AudioDiskPlayer.MediaInfo.Get
{
  mostAMSmessage AudioDiskPlayer.MediaInfo.Status msg = { DLC = 1000} ;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 2))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // semantic checks
  if((this.PosX > kMediaInfoSize) || (this.PosY > 6))
  {
    mostSendError_CodeByteWord(this, kErrParamWrong, 1, this.Pos);
    return;
  }

  // fill message
  mostPrepareReport(this, msg);
  msg.Pos = this.Pos;
  FillMediaInfoStatusMsg(msg);
  
  // reply status
  mostAsNtfOutput(this.SA, msg);

  //}}} --- end application section -------------
}

on sysvar CDC::ADP_DeckStatus
{
 //{{{ --- begin application section -----------

  switch(@sysvar::CDC::ADP_DeckStatus)
  {
  case 0: // Play
    PlaybackStartTrack(@sysvar::CDC::ADP_ActiveDisk, @sysvar::CDC::ADP_TrackPosition);
    break;
  case 1: // Stop
    PlaybackStop();
    break;
  case 2: // Pause
    PlaybackPause();
    break;
  case 3: // Load
    @sysvar::CDC::ADP_MagazineStatus = 1;
    break;
  case 4: // Unload
    @sysvar::CDC::ADP_MagazineStatus = 0;
    PlaybackStop();
    break;
  default:
    // ignore
    break;
  }

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // HINT: Calling Notification Service to inform all notified clients
  SendStatus_DeckStatus(kAsNtfDestAdr);

  //}}} --- end default code --------------------

}

long SendStatus_DeckStatus(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)

  //{{{ --- begin default code ------------------
  mostAMSMessage AudioDiskPlayer.DeckStatus.Status msg;

  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // assemble status message
  msg.DeckStatus = @sysvar::CDC::ADP_DeckStatus;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // send message
  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------
}


on mostAMSMessage AudioDiskPlayer.DeckStatus.Get
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  // reply status
  SendStatus_DeckStatus(this.SA);

  //}}} --- end default code --------------------
}


on mostAMSMessage AudioDiskPlayer.DeckStatus.Set
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(this.DeckStatus > 0x04) // AudioDiskPlayer.DeckStatus.Status.DeckStatus::Unload)
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.DeckStatus);
    return;
  }

  // any changes?
  if(this.DeckStatus == @sysvar::CDC::ADP_DeckStatus)
    return;

  // load magazine?
  if(this.DeckStatus != 0x03) // AudioDiskPlayer.DeckStatus.Status.DeckStatus::Load)
  {
    // verify player can play
    if(!IsTrackPositionValid(@sysvar::CDC::ADP_ActiveDisk, @sysvar::CDC::ADP_TrackPosition))
    {
      mostSendError_Code(this, kErrNotAvailable);
      return;
    }
  }
  else
  {
    // magazine already loaded?
    if(IsMagazineLoaded())
    {
      return;
    }
  }

  // set property
  @sysvar::CDC::ADP_DeckStatus = this.DeckStatus;

  // set internal state of device
  @sysvar::CDC::ADP_Mode = this.DeckStatus;

  if(this.DeckStatus == 0x00) // AudioDiskPlayer.DeckStatus.Status.DeckStatus::Play)
  {
    cancelTimer(tPeakLevel);
    setTimer(tPeakLevel, 100);
  }
  else
  {
    ResetPeakLevel();
  }

  //}}} --- end application section -------------
}


on mostAMSMessage AudioDiskPlayer.DeckStatus.SetGet
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(this.DeckStatus > 0x04) // AudioDiskPlayer.DeckStatus.Status.DeckStatus::Unload)
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.DeckStatus);
    return;
  }

  // load magazine?
  if(this.DeckStatus != 0x03) // AudioDiskPlayer.DeckStatus.Status.DeckStatus::Load)
  {
    // verify player can play
    if(!IsTrackPositionValid(@sysvar::CDC::ADP_ActiveDisk, @sysvar::CDC::ADP_TrackPosition))
    {
      mostSendError_Code(this, kErrNotAvailable);
      return;
    }
  }
  
  // set property
  @sysvar::CDC::ADP_DeckStatus = this.DeckStatus;

  // set internal state of device
  @sysvar::CDC::ADP_Mode = this.DeckStatus;

  if(this.DeckStatus == 0x00) // AudioDiskPlayer.DeckStatus.Status.DeckStatus::Play)
  {
    cancelTimer(tPeakLevel);
    setTimer(tPeakLevel, 100);
  }
  else
  {
    ResetPeakLevel();
  }

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_DeckStatus(this.SA);

  //}}} --- end default code --------------------
}

OnMostAllocTable()
{
  //{{{ --- begin application section -----------

  byte buffer[60];
  int i;
  byte bNoChannels;
  bNoChannels = 1;

  if( kMost25 == gSpeedGrade)
  {
    if(mostGetAllocTable(mostGetChannel(), buffer, 60) == 0)
    {
      for(i=0; i<elcount(buffer); ++i)
      {
        // mask msb, since this signalizes channel usage
        if( (buffer[i] & 0x7F) != 0x70)
        {
          bNoChannels = 0;
          break;
        }      
      }
    }
  }
  else
  {
    if(MostAllocTableGetSize(mostGetChannel()) > 0)
      bNoChannels = 0;
  }

  

  if(bNoChannels)
  {
    // channels have to be re-allocated
    gAllocState = 0;
  }

  //}}} --- end application section -------------
}

on timer tPeakLevel
{
  int x,y;

  //{{{ --- begin application section -----------

  if(!CheckNormalOperation()) 
    return;

  x = random(127);
  y = random(127);

  @sysvar::CDC::ADP_PeakLevel_Left = x/2;
  @sysvar::CDC::ADP_PeakLevel_Right = y/2;

  // send notification
  SendStatus_PeakLevel(kAsNtfDestAdr);

  canceltimer(tPeakLevel);
  setTimer(tPeakLevel, kPeakLevelCycle);

  //}}} --- end application section -------------
}

long SendStatus_PeakLevel(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)

  //{{{ --- begin default code ------------------

  mostAMSMessage AudioDiskPlayer.PeakLevel.Status msg;
  
  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------

  //{{{ --- begin application section -----------

  msg.LevelLeft  = @sysvar::CDC::ADP_PeakLevel_Left;
  msg.LevelRight = @sysvar::CDC::ADP_PeakLevel_Right;

  mostAsNtfOutput(destAdr, msg);
  return 0;

  //{{{ --- end application section -------------
}

ResetPeakLevel ()
{
  cancelTimer(tPeakLevel);
  @sysvar::CDC::ADP_PeakLevel_Left = 0;
  @sysvar::CDC::ADP_PeakLevel_Right = 0;
}

FillMediaInfoStatusMsg(mostAmsMessage AudioDiskPlayer.MediaInfo.Status msg)
{
  // Fill MediaInfo.Status() message dependent on posx and posy
  // posx   =   posy =  0  --> Fill all available records with disk info
  // posx != 0, posy =  0  --> Fill dedicated record with disk info
  // posy != 0, posy != 0  --> Fill dedicated record field with disk info

  byte i;

  // remove data behind Pos parameter; deletes all array elements
  msg.DLC = 2;

  // check posx, posy
  if((msg.PosX > kMediaInfoSize) || (msg.PosY > 6))
    return;


  if(msg.PosX == 0)
  {
    // set size of array
    mostParamSet(msg, "Data", kMediaInfoSize);
  }
  // copy data
  for(i = 1; i <= kMediaInfoSize; ++i)
  {
    if((i == msg.PosX) || (msg.PosX == 0))
    {
      if((msg.PosY == 1) || (msg.PosY == 0))
      {
        if(gMediaInfoPlayTime[i-1] == 0)
          mostParamSetString(msg, "Data.Record[].MediaTitle", i, "");
        else
          mostParamSetString(msg, "Data.Record[].MediaTitle", i, gMediaInfoMediaTitle[i-1]);
      }

      if((msg.PosY == 2) || (msg.PosY == 0))
      {
        mostParamSet(msg, "Data.Record[].MediaType", i, gMediaInfoMediaType[i-1]);
      }

      if((msg.PosY == 3) || (msg.PosY == 0))
      {
        mostParamSet(msg, "Data.Record[].MediaFilesystem", i, gMediaInfoMediaFilesystem[i-1]);
      }

      if((msg.PosY == 4) || (msg.PosY == 0))
      {
        mostParamSet(msg, "Data.Record[].FirstTrack", i, gMediaInfoFirstTrack[i-1]);
      }

      if((msg.PosY == 5) || (msg.PosY == 0))
      {
        mostParamSet(msg, "Data.Record[].LastTrack", i, gMediaInfoLastTrack[i-1]);
      }

      if((msg.PosY == 6) || (msg.PosY == 0))
      {
        mostParamSet(msg, "Data.Record[].PlayTime", i, gMediaInfoPlayTime[i-1]);
      }
    }
  }
}

void ConfigureFBlock()
{
  // Configures the FBlock.
  // Therefore functions are registered at CANoe's Function and 
  // Notification Service.

  long oldInstId = -1; // static variable
  long newInstId;

  newInstId = mostApGetInstId();

  if(newInstId < 0)
  {
    newInstId = -1;
  }

  if(oldInstId != -1)
  {
    // disable Notification Service
    mostAsNtfDisableEx(kFB_ADP, oldInstId);
    // disable Function Service
    mostAsFsDisableEx(kFB_ADP, oldInstId);
  }

  if(newInstId != -1)
  {
    // enable Notification Service
    mostAsNtfEnable();
    // enable Function Service
    mostAsFsEnable();

    // Enable all functions and all operations defined in the function catalog
    // for the FBlock. Additionally, functions of type 'property' will be registered
    // at the Notification Service if a corresponding CAPL function for sending 
    // the status message is defined.
    mostAsFsFunctionEnable(kFctAllInFCat, kOpTFAllInFCat, "SendStatus_");
  }
  oldInstId = newInstId;

  gSpeedGrade = mostGetSpeedGrade(mostGetChannel());
}

on mostAMSMessage AudioDiskPlayer.PeakLevel.Get
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  // reply status
  SendStatus_PeakLevel(this.SA);

  //}}} --- end default code --------------------
}

void AppInit()
{
  // Called on first start of the application.
  
  if(gAppPhase == kAppOn)
    return;

  // application has started now
  gAppPhase = kAppOn;
}

void AppExit()
{
  // Called on final exit of the application.

  if(gAppPhase == kAppOff)
    return;

  // power off
  gAppPhase = kAppOff;

  // reset state machine
  if(gAllocState == 2)
    RoutingEngineReset();
  gAllocState = 0;
}

void AppShutdown()
{
  // Called for a regular shut down of the application.
  
  if(gAppPhase == kAppShutdown)
    return;
  
  // application is in shutdown mode now
  gAppPhase = kAppShutdown;

}

OnMostNetOn()
{
  AppInit();
}

OnMostSyncAllocResult(long allocResult, long numChannels, long channels[])
{
  // result of allocation process
  
  long i;

  if(allocResult == 0x01) // alloc grant
  {
    // fill result msg
    gMsgAllocateRes.SourceNr = 0x01;
    for(i = 0; i < 4; ++i)
      gMsgAllocateRes.byte(2+i) = channels[i];
    gMsgAllocateRes.DLC = 6;
    gMsgAllocateRes.InstanceId = mostApGetInstID();
    output(gMsgAllocateRes);

    // state is now 'allocated'
    gAllocState = 2;

    // programm routing engine
    RoutingEngineSet(channels);
  }
  else
  {
    // fill and send error message
    if(gAppPhase != kAppOff)
      mostSendError_Code(gMsgAllocateRes, kErrProcessing);
  }
}

OnMostSyncDeallocResult(long deallocResult, long label)
{
  // result of deallocation process

  if(deallocResult == 0x01) // alloc grant
  {
    // fill result msg
    gMsgDeAllocateRes.SourceNr = 0x01;
    gMsgDeAllocateRes.DLC = 1;
    gMsgDeAllocateRes.InstanceId = mostApGetInstID();
    output(gMsgDeAllocateRes);

    // state is now 'not allocated'
    gAllocState = 0;

    // programm routing engine
    RoutingEngineReset();
  }
  else
  {
    // fill and send error message
    if(gAppPhase != kAppOff)
      mostSendError_Code(gMsgAllocateRes, kErrProcessing);
  }
}

on sysvar CDC::Button_Eject
{
  // unload magazine

  if(@this)
    return;

  @sysvar::CDC::ADP_MagazineStatus = 0;
}

on mostAMSMessage AudioDiskPlayer.AudioDiskInfo.Get
{
  mostAMSmessage AudioDiskPlayer.AudioDiskInfo.Status msg = { DLC = 500} ;
  byte disc;

  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 2))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  // semantic checks
  disc = @sysvar::CDC::ADP_ActiveDisk;
  if(this.PosX > NumberOfTracks(disc))
  {
    mostSendError_CodeByteWord(this, kErrParamWrong, 1, this.Pos);
    return;
  }

  if((this.PosX > kAudioDiskInfoSize) || (this.PosY > 4))
  {
    mostSendError_CodeByteWord(this, kErrParamWrong, 1, this.Pos);
    return;
  }

  // fill message
  mostPrepareReport(this, msg);
  msg.Pos = this.Pos;
  FillAudioDiskInfoStatusMsg(msg);
  
  // reply status
  mostAsNtfOutput(this.SA, msg);

  //}}} --- end application section -------------
}

long SendStatus_AudioDiskInfo(long destAdr)
{
  // Description:
  //   The SendStatus function is used for 
  //   - the Notification Service
  //     (status message on Notification.Set(SetFunction)
  //     and spontaneos property change)
  //   - for replies on OpType Get, SetGet, Inc, Dec
  // Parameter:
  //   destAdr  Target device(s)
  //     destadr==kAsNtfDestAdr: to all notification clients
  //     destadr!=kAsNtfDestAdr: to destAdr
  // Return:
  //   0: Ok; -1: Failed (property currently not available...)
  
  //{{{ --- begin default code ------------------
  mostAMSMessage AudioDiskPlayer.AudioDiskInfo.Status msg;

  if(!CheckNormalOperation())
    return -1;
  msg.InstanceId = mostApGetInstID();

  //}}} --- end default code --------------------

 
  //{{{ --- begin application section -----------

  // assemble status message
  msg.Pos = 0;
  FillAudioDiskInfoStatusMsg(msg);
    
  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------
  
  mostAsNtfOutput(destAdr, msg);
  return 0;

  //}}} --- end default code --------------------
}

FillAudioDiskInfoStatusMsg(mostAmsMessage AudioDiskPlayer.AudioDiskInfo.Status msg)
{
  // Fill AudioDiskInfo.Status() message dependent on posx and posy in msg
  // posx   =   posy =  0  --> Fill all available records with disk info
  // posx != 0, posy =  0  --> Fill dedicated record with disk info
  // posy != 0, posy != 0  --> Fill dedicated record field with disk info

  byte i, disc, tracks;
  char bufferFilename[50];
  
  // remove data behind Pos parameter; deletes all array elements
  msg.DLC = 2;

  // check posx, posy
  disc = @sysvar::CDC::ADP_ActiveDisk;
  tracks = NumberOfTracks(disc);
  if((msg.PosX > tracks) || (msg.PosY > 4))
    return;

  if(msg.PosX == 0)
  {
    // set size of array
    mostParamSet(msg, "Data", tracks);
  }

  // copy data
  for(i = 1; i <= tracks; ++i)
  {
    if((i == msg.PosX) || (msg.PosX == 0))
    {
      if((msg.PosY == 1) || (msg.PosY == 0))
      {
        mostParamSetString(msg, "Data.Record[].AudioTitle", i, gAudioDiskInfoAudioTitle[disc-1][i-1]);
      }

      if((msg.PosY == 2) || (msg.PosY == 0))
      {
        mostParamSet(msg, "Data.Record[].AudioTime", i, gAudioDiskInfoAudioTime[disc-1][i-1]);
      }

      if((msg.PosY == 3) || (msg.PosY == 0))
      {
        mostParamSet(msg, "Data.Record[].TrackNo", i, i);
      }

      if((msg.PosY == 4) || (msg.PosY == 0))
      {
        snprintf(bufferFilename, elcount(bufferFilename), "Track%02d.mp3", i);
        mostParamSetString(msg, "Data.Record[].AudioFilename", i, bufferFilename);
      }
    }
  }
}

long NumberOfTracks(long disc)
{
  // Returns number of tracks on the current disc.

  long i;

  if(!IsDiscValid(disc))
    return 0;

  i = 0;
  while(gAudioDiskInfoAudioTime[disc-1][i] > 0)
  {
    ++i;
  }

  return i;
}

on mostAMSMessage AudioDiskPlayer.Random.Set
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(this.RandomState > 4)
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.RandomState);
    return;
  }

  // set property
  @sysvar::CDC::ADP_Random = this.RandomState;

  //}}} --- end application section -------------}
}

on mostAMSMessage AudioDiskPlayer.Random.SetGet
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(this.RandomState > 4)
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.RandomState);
    return;
  }

  // set property
  @sysvar::CDC::ADP_Random = this.RandomState;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_Random(this.SA);

  //}}} --- end default code --------------------
}

on mostAMSMessage AudioDiskPlayer.Random.Get
{
  //{{{ --- begin default code ------------------
  
  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  // reply status
  SendStatus_Random(this.SA);

  //}}} --- end default code --------------------
}

on mostAMSMessage AudioDiskPlayer.Scan.Set
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(this.ScanState > 4)
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.ScanState);
    return;
  }

  // set property
  @sysvar::CDC::ADP_Scan = this.ScanState;

  //}}} --- end application section -------------}
}

on mostAMSMessage AudioDiskPlayer.Scan.SetGet
{
  //{{{ --- begin default code ------------------

  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 1))
    return;

  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------

  if(this.ScanState > 4)
  {
    mostSendError_CodeByteByte(this, kErrParamWrong, 1, this.ScanState);
    return;
  }

  // set property
  @sysvar::CDC::ADP_Scan = this.ScanState;

  //}}} --- end application section -------------


  //{{{ --- begin default code ------------------

  // reply status
  SendStatus_Scan(this.SA);

  //}}} --- end default code --------------------
}

on mostAMSMessage AudioDiskPlayer.Scan.Get
{
  //{{{ --- begin default code ------------------
  
  if(!CheckNormalOperation())
    return;
  if(!CheckValidReceptionAndLength(this, 0))
    return;

  // reply status
  SendStatus_Scan(this.SA);

  //}}} --- end default code --------------------
}

OnMostTxLight(long mode)
{
  if(mode == 0)
  {
    AppExit();
  }
  else
  {
    AppInit();
  }
}

on mostAMSMessage AudioDiskPlayer.AllocateLabel.StartResultAck
{
  long i;

  //{{{ --- begin default code ------------------

  if(!CheckValidReception(this))
    return;
  if(!CheckMsgLength(this, 3))
    return;
  //}}} --- end default code --------------------


  //{{{ --- begin application section -----------
  // this player has one source only
  if(this.SourceNr != 0x01)
  {
    mostSendError_CodeByteByte(this, kErrParamNotAvailable, 1, this.SourceNr);
    return;
  }

  if(gAllocState != 0)
  {
    // allocation already in progress
    mostSendError_Code(this, kErrNotAvailable);
    return;
  }

  // store address of initiator
  gMsgAllocateLabelRes.DA = this.SA;
  gMsgAllocateLabelRes.senderHandle = this.senderHandle;
 
  // state: allocating
  gAllocState = 1;


  // call synchronous channel allocation service
  // OnMostSyncAudio() will be invoked on completion or timeout
  if((kMost150 == gSpeedGrade) && !isSimulated())
  {
    MostSetSyncAudio(MostGetChannel(), 1, kLabelWidth, 0, 1);     // 2nd param "label" is NOT used.
  }
  else
  {
    OnMostSyncAudio(339, 0, 1);       // Simulate allocation on label 339
  }
 


  //}}} --- end application section -------------
}

OnMostSyncAudio (long label, long device, long mode)
{
    if(kMost25 == gSpeedGrade || mode == 0)
      return;

    // state is now 'allocated'
    gAllocState = 2;

    // fill result msg
    gMsgAllocateLabelRes.SourceNr = 0x01;
    gMsgAllocateLabelRes.InstanceId = mostApGetInstID();

    gMsgAllocateLabelRes.ConnectionLabel = label;
    gMsgAllocateLabelRes.BlockWidth = kLabelWidth;
    output(gMsgAllocateLabelRes);
}

