/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct MapData payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitMapDataPacket();
//  if (packetHandle!=0) {
//    if (API_SetMapDataParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{
  //#include "ASNV_Template_BaseDatatypes.cin"  // If warning "Duplicate #include, ignoring this include" appears, please remove the ASNV_Template_BaseDatatypes.cin include from your other *.cin files in the project.
}
variables
{
    struct MapDataDescriptiveName {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[64];
        INT  stringLength;
    };
    
    struct MapDataNodeReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct MapDataPosition3D {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lat;  // INTEGER, -900000000..900000001;
        LONG lon;  // INTEGER, -1799999999..1800000001;
        struct OPT_LONG_ASN elevation;  // INTEGER, OPTIONAL, -4096..61439;
    };
    
    struct MapDataRegulatorySpeedLimit {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT type;  // ENUMERATED, unknown(0), maxSpeedInSchoolZone(1), maxSpeedInSchoolZoneWhenChildrenArePresent(2), maxSpeedInConstructionZone(3), vehicleMinSpeed(4), vehicleMaxSpeed(5), vehicleNightMaxSpeed(6), truckMinSpeed(7), truckMaxSpeed(8), truckNightMaxSpeed(9), vehiclesWithTrailersMinSpeed(10), vehiclesWithTrailersMaxSpeed(11), vehiclesWithTrailersNightMaxSpeed(12);
        WORD speed;  // INTEGER, 0..8191;
    };
    
    struct MapDataSpeedLimitList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MapDataRegulatorySpeedLimit arrayValue[9];  // SEQUENCE;
    };
    
    struct MapDataPosition_LL_24B {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT lon;  // INTEGER, -2048..2047;
        INT lat;  // INTEGER, -2048..2047;
    };
    
    struct MapDataPosition_LL_28B {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT lon;  // INTEGER, -8192..8191;
        INT lat;  // INTEGER, -8192..8191;
    };
    
    struct MapDataPosition_LL_32B {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT lon;  // INTEGER, -32768..32767;
        INT lat;  // INTEGER, -32768..32767;
    };
    
    struct MapDataPosition_LL_36B {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -131072..131071;
        LONG lat;  // INTEGER, -131072..131071;
    };
    
    struct MapDataPosition_LL_44B {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -2097152..2097151;
        LONG lat;  // INTEGER, -2097152..2097151;
    };
    
    struct MapDataPosition_LL_48B {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -8388608..8388607;
        LONG lat;  // INTEGER, -8388608..8388607;
    };
    
    struct MapDataPosition_LLmD_64b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -1799999999..1800000001;
        LONG lat;  // INTEGER, -900000000..900000001;
    };
    
    struct MapDataPositionOffsetLL {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MapDataPosition_LL_24B position_LL1;  // SEQUENCE;
        struct MapDataPosition_LL_28B position_LL2;  // SEQUENCE;
        struct MapDataPosition_LL_32B position_LL3;  // SEQUENCE;
        struct MapDataPosition_LL_36B position_LL4;  // SEQUENCE;
        struct MapDataPosition_LL_44B position_LL5;  // SEQUENCE;
        struct MapDataPosition_LL_48B position_LL6;  // SEQUENCE;
        struct MapDataPosition_LLmD_64b position_LatLon;  // SEQUENCE;
    };
    
    struct MapDataVerticalOffset {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT offset1;  // INTEGER, -64..63;
        INT offset2;  // INTEGER, -128..127;
        INT offset3;  // INTEGER, -256..255;
        INT offset4;  // INTEGER, -512..511;
        INT offset5;  // INTEGER, -1024..1023;
        INT offset6;  // INTEGER, -2048..2047;
        LONG elevation;  // INTEGER, -4096..61439;
    };
    
    struct MapDataPositionOffsetLLV {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MapDataPositionOffsetLL offsetLL;  // CHOICE;
        struct MapDataVerticalOffset offsetV;  // CHOICE, OPTIONAL;
    };
    
    struct MapDataRoadPoint {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MapDataPositionOffsetLLV posOffset;  // SEQUENCE;
    };
    
    struct MapDataPointList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MapDataRoadPoint arrayValue[31];  // SEQUENCE;
    };
    
    struct MapDataMovement {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MapDataNodeReferenceID remoteIntersection;  // SEQUENCE;
        struct OPT_BYTE_ASN phaseId;  // INTEGER, OPTIONAL, 0..255;
    };
    
    struct MapDataMovementList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MapDataMovement arrayValue[32];  // SEQUENCE;
    };
    
    struct MapDataLaneSharing {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[11];
        INT  stringLength;
    };
    
    struct MapDataLaneAttributes_Vehicle {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[9];
        INT  stringLength;
    };
    
    struct MapDataLaneAttributes_Crosswalk {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MapDataLaneAttributes_Bike {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MapDataLaneAttributes_Sidewalk {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MapDataLaneAttributes_Barrier {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MapDataLaneAttributes_Striping {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MapDataLaneAttributes_TrackedVehicle {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MapDataLaneAttributes_Parking {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MapDataLaneTypeAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MapDataLaneAttributes_Vehicle vehicle;  // BITSTRING;
        struct MapDataLaneAttributes_Crosswalk crosswalk;  // BITSTRING;
        struct MapDataLaneAttributes_Bike bikeLane;  // BITSTRING;
        struct MapDataLaneAttributes_Sidewalk sidewalk;  // BITSTRING;
        struct MapDataLaneAttributes_Barrier median;  // BITSTRING;
        struct MapDataLaneAttributes_Striping striping;  // BITSTRING;
        struct MapDataLaneAttributes_TrackedVehicle trackedVehicle;  // BITSTRING;
        struct MapDataLaneAttributes_Parking parking;  // BITSTRING;
    };
    
    struct MapDataLaneAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MapDataLaneSharing shareWith;  // BITSTRING, OPTIONAL;
        struct MapDataLaneTypeAttributes laneType;  // CHOICE;
    };
    
    struct MapDataAllowedManeuvers {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[13];
        INT  stringLength;
    };
    
    struct MapDataConnectingLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE lane;  // INTEGER, 0..255;
        struct MapDataAllowedManeuvers maneuver;  // BITSTRING, OPTIONAL;
    };
    
    struct MapDataConnection {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MapDataNodeReferenceID remoteIntersection;  // SEQUENCE;
        struct MapDataConnectingLane connectingLane;  // SEQUENCE, OPTIONAL;
        struct OPT_BYTE_ASN phaseId;  // INTEGER, OPTIONAL, 0..255;
    };
    
    struct MapDataConnectsToList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MapDataConnection arrayValue[8];  // SEQUENCE;
    };
    
    struct MapDataLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE laneID;  // INTEGER, 0..255;
        struct MapDataLaneAttributes laneAttributes;  // SEQUENCE, OPTIONAL;
        struct MapDataAllowedManeuvers maneuvers;  // BITSTRING, OPTIONAL;
        struct MapDataConnectsToList connectsTo;  // SEQUENCEOF, OPTIONAL;
        struct MapDataSpeedLimitList speedLimits;  // SEQUENCEOF, OPTIONAL;
        struct MapDataPointList points;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MapDataLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MapDataLane arrayValue[32];  // SEQUENCE;
    };
    
    struct MapDataLink {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MapDataDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct MapDataNodeReferenceID upstreamNodeId;  // SEQUENCE;
        struct MapDataSpeedLimitList speedLimits;  // SEQUENCEOF, OPTIONAL;
        WORD laneWidth;  // INTEGER, 0..32767;
        struct MapDataPointList points;  // SEQUENCEOF, OPTIONAL;
        struct MapDataMovementList movements;  // SEQUENCEOF, OPTIONAL;
        struct MapDataLaneList lanes;  // SEQUENCEOF;
    };
    
    struct MapDataLinkList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MapDataLink arrayValue[32];  // SEQUENCE;
    };
    
    struct MapDataNode {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MapDataDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct MapDataNodeReferenceID id;  // SEQUENCE;
        struct MapDataPosition3D refPos;  // SEQUENCE;
        struct MapDataLinkList inLinks;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MapDataNodeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MapDataNode arrayValue[32];  // SEQUENCE;
    };
    
    struct MapDataMAPFrame {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE msgCnt;  // INTEGER, 0..127;
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        struct MapDataNodeList nodes;  // SEQUENCEOF;
    };
    
    struct MapData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE frameType;  // INTEGER, 0..15, mapFrame(1);
        struct MapDataMAPFrame mapFrame;  // SEQUENCE;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitMapDataPacket()
{
  return C2xInitPacket("MapData"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitMapDataPacket(struct MapData msgStruct)
{
  long pktHandle;

  pktHandle = API_InitMapDataPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetMapDataParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitMapDataPacket(struct MapData msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("MapData", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetMapDataParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetMapDataNodeReferenceIDParams(LONG packetHandle, struct MapDataNodeReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "MapData", newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataNodeReferenceIDParams(LONG packetHandle, struct MapDataNodeReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MapData", newPath, value.region.value);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.id);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPosition3DParams(LONG packetHandle, struct MapDataPosition3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.elevation.isValidFlag==1)
  {
    value.elevation.value = C2xGetTokenInt(packetHandle, "MapData", newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int SetMapDataPosition3DParams(LONG packetHandle, struct MapDataPosition3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lat);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lon);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  if(value.elevation.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MapData", newPath, value.elevation.value);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  return result;
}

int GetMapDataRegulatorySpeedLimitParams(LONG packetHandle, struct MapDataRegulatorySpeedLimit value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  value.type = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataRegulatorySpeedLimitParams(LONG packetHandle, struct MapDataRegulatorySpeedLimit value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.type);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.speed);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataSpeedLimitListParams(LONG packetHandle, struct MapDataSpeedLimitList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MapData", oldPath);
  if((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMapDataRegulatorySpeedLimitParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMapDataSpeedLimitListParams(LONG packetHandle, struct MapDataSpeedLimitList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MapData", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMapDataRegulatorySpeedLimitParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int GetMapDataPosition_LL_24BParams(LONG packetHandle, struct MapDataPosition_LL_24B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataPosition_LL_24BParams(LONG packetHandle, struct MapDataPosition_LL_24B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lon);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lat);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPosition_LL_28BParams(LONG packetHandle, struct MapDataPosition_LL_28B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataPosition_LL_28BParams(LONG packetHandle, struct MapDataPosition_LL_28B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lon);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lat);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPosition_LL_32BParams(LONG packetHandle, struct MapDataPosition_LL_32B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataPosition_LL_32BParams(LONG packetHandle, struct MapDataPosition_LL_32B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lon);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lat);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPosition_LL_36BParams(LONG packetHandle, struct MapDataPosition_LL_36B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataPosition_LL_36BParams(LONG packetHandle, struct MapDataPosition_LL_36B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lon);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lat);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPosition_LL_44BParams(LONG packetHandle, struct MapDataPosition_LL_44B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataPosition_LL_44BParams(LONG packetHandle, struct MapDataPosition_LL_44B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lon);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lat);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPosition_LL_48BParams(LONG packetHandle, struct MapDataPosition_LL_48B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataPosition_LL_48BParams(LONG packetHandle, struct MapDataPosition_LL_48B value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lon);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lat);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPosition_LLmD_64bParams(LONG packetHandle, struct MapDataPosition_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataPosition_LLmD_64bParams(LONG packetHandle, struct MapDataPosition_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lon);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lat);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPositionOffsetLLParams(LONG packetHandle, struct MapDataPositionOffsetLL value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MapData", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL1");
      GetMapDataPosition_LL_24BParams(packetHandle, value.position_LL1, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL2");
      GetMapDataPosition_LL_28BParams(packetHandle, value.position_LL2, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL3");
      GetMapDataPosition_LL_32BParams(packetHandle, value.position_LL3, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL4");
      GetMapDataPosition_LL_36BParams(packetHandle, value.position_LL4, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL5");
      GetMapDataPosition_LL_44BParams(packetHandle, value.position_LL5, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL6");
      GetMapDataPosition_LL_48BParams(packetHandle, value.position_LL6, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LatLon");
      GetMapDataPosition_LLmD_64bParams(packetHandle, value.position_LatLon, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMapDataPositionOffsetLLParams(LONG packetHandle, struct MapDataPositionOffsetLL value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL1");
      SetMapDataPosition_LL_24BParams(packetHandle, value.position_LL1, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL2");
      SetMapDataPosition_LL_28BParams(packetHandle, value.position_LL2, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL3");
      SetMapDataPosition_LL_32BParams(packetHandle, value.position_LL3, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL4");
      SetMapDataPosition_LL_36BParams(packetHandle, value.position_LL4, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL5");
      SetMapDataPosition_LL_44BParams(packetHandle, value.position_LL5, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LL6");
      SetMapDataPosition_LL_48BParams(packetHandle, value.position_LL6, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "position_LatLon");
      SetMapDataPosition_LLmD_64bParams(packetHandle, value.position_LatLon, newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMapDataVerticalOffsetParams(LONG packetHandle, struct MapDataVerticalOffset value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MapData", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset1");
      value.offset1 = C2xGetTokenInt(packetHandle, "MapData", newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset2");
      value.offset2 = C2xGetTokenInt(packetHandle, "MapData", newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset3");
      value.offset3 = C2xGetTokenInt(packetHandle, "MapData", newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset4");
      value.offset4 = C2xGetTokenInt(packetHandle, "MapData", newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset5");
      value.offset5 = C2xGetTokenInt(packetHandle, "MapData", newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset6");
      value.offset6 = C2xGetTokenInt(packetHandle, "MapData", newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
      value.elevation = C2xGetTokenInt(packetHandle, "MapData", newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMapDataVerticalOffsetParams(LONG packetHandle, struct MapDataVerticalOffset value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset1");
      C2xSetTokenInt(packetHandle, "MapData", newPath, value.offset1);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset2");
      C2xSetTokenInt(packetHandle, "MapData", newPath, value.offset2);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset3");
      C2xSetTokenInt(packetHandle, "MapData", newPath, value.offset3);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset4");
      C2xSetTokenInt(packetHandle, "MapData", newPath, value.offset4);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset5");
      C2xSetTokenInt(packetHandle, "MapData", newPath, value.offset5);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset6");
      C2xSetTokenInt(packetHandle, "MapData", newPath, value.offset6);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
      C2xSetTokenInt(packetHandle, "MapData", newPath, value.elevation);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMapDataPositionOffsetLLVParams(LONG packetHandle, struct MapDataPositionOffsetLLV value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetLL");
  GetMapDataPositionOffsetLLParams(packetHandle, value.offsetLL, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetV");
  value.offsetV.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.offsetV.isValidFlag==1)
  {
    GetMapDataVerticalOffsetParams(packetHandle, value.offsetV, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int SetMapDataPositionOffsetLLVParams(LONG packetHandle, struct MapDataPositionOffsetLLV value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetLL");
  SetMapDataPositionOffsetLLParams(packetHandle, value.offsetLL, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetV");
  if(value.offsetV.isValidFlag==1)
  {
    SetMapDataVerticalOffsetParams(packetHandle, value.offsetV, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  return result;
}

int GetMapDataRoadPointParams(LONG packetHandle, struct MapDataRoadPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posOffset");
  GetMapDataPositionOffsetLLVParams(packetHandle, value.posOffset, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataRoadPointParams(LONG packetHandle, struct MapDataRoadPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posOffset");
  SetMapDataPositionOffsetLLVParams(packetHandle, value.posOffset, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataPointListParams(LONG packetHandle, struct MapDataPointList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MapData", oldPath);
  if((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMapDataRoadPointParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMapDataPointListParams(LONG packetHandle, struct MapDataPointList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MapData", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMapDataRoadPointParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int GetMapDataMovementParams(LONG packetHandle, struct MapDataMovement value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  GetMapDataNodeReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "phaseId");
  value.phaseId.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.phaseId.isValidFlag==1)
  {
    value.phaseId.value = C2xGetTokenInt(packetHandle, "MapData", newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int SetMapDataMovementParams(LONG packetHandle, struct MapDataMovement value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  SetMapDataNodeReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "phaseId");
  if(value.phaseId.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MapData", newPath, value.phaseId.value);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  return result;
}

int GetMapDataMovementListParams(LONG packetHandle, struct MapDataMovementList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MapData", oldPath);
  if((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMapDataMovementParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMapDataMovementListParams(LONG packetHandle, struct MapDataMovementList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MapData", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMapDataMovementParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int GetMapDataLaneTypeAttributesParams(LONG packetHandle, struct MapDataLaneTypeAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MapData", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicle");
      value.vehicle.isValidFlag = 1;
      value.vehicle.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
      if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.vehicle.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.vehicle.string[j] = '0';
          }
          else
          {
            value.vehicle.string[j] = '1';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crosswalk");
      value.crosswalk.isValidFlag = 1;
      value.crosswalk.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
      if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.crosswalk.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.crosswalk.string[j] = '0';
          }
          else
          {
            value.crosswalk.string[j] = '1';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "bikeLane");
      value.bikeLane.isValidFlag = 1;
      value.bikeLane.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
      if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.bikeLane.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.bikeLane.string[j] = '0';
          }
          else
          {
            value.bikeLane.string[j] = '1';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sidewalk");
      value.sidewalk.isValidFlag = 1;
      value.sidewalk.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
      if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.sidewalk.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.sidewalk.string[j] = '0';
          }
          else
          {
            value.sidewalk.string[j] = '1';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "median");
      value.median.isValidFlag = 1;
      value.median.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
      if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.median.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.median.string[j] = '0';
          }
          else
          {
            value.median.string[j] = '1';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "striping");
      value.striping.isValidFlag = 1;
      value.striping.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
      if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.striping.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.striping.string[j] = '0';
          }
          else
          {
            value.striping.string[j] = '1';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trackedVehicle");
      value.trackedVehicle.isValidFlag = 1;
      value.trackedVehicle.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
      if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.trackedVehicle.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.trackedVehicle.string[j] = '0';
          }
          else
          {
            value.trackedVehicle.string[j] = '1';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "parking");
      value.parking.isValidFlag = 1;
      value.parking.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
      if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.parking.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.parking.string[j] = '0';
          }
          else
          {
            value.parking.string[j] = '1';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMapDataLaneTypeAttributesParams(LONG packetHandle, struct MapDataLaneTypeAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicle");
      for(j=0; j<value.vehicle.stringLength; j++)
      {
        if(value.vehicle.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crosswalk");
      for(j=0; j<value.crosswalk.stringLength; j++)
      {
        if(value.crosswalk.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "bikeLane");
      for(j=0; j<value.bikeLane.stringLength; j++)
      {
        if(value.bikeLane.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sidewalk");
      for(j=0; j<value.sidewalk.stringLength; j++)
      {
        if(value.sidewalk.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "median");
      for(j=0; j<value.median.stringLength; j++)
      {
        if(value.median.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "striping");
      for(j=0; j<value.striping.stringLength; j++)
      {
        if(value.striping.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trackedVehicle");
      for(j=0; j<value.trackedVehicle.stringLength; j++)
      {
        if(value.trackedVehicle.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "parking");
      for(j=0; j<value.parking.stringLength; j++)
      {
        if(value.parking.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMapDataLaneAttributesParams(LONG packetHandle, struct MapDataLaneAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "shareWith");
  value.shareWith.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.shareWith.isValidFlag==1)
  {
    value.shareWith.isValidFlag = 1;
    value.shareWith.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
    if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
    {
      if(value.shareWith.stringLength > 0)
      {
        for(j=0; j<value.shareWith.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.shareWith.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 1)
          {
            value.shareWith.string[j] = '1';
          }

          if(value.shareWith.stringLength == 1)
          {
            value.shareWith.string[1] = '0';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.shareWith.stringLength+1; k > -1; k--)
        {
          if(value.shareWith.string[k] == '1')
          {
            value.shareWith.string[k] = '0';
          }
        }
      }
    }

  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneType");
  GetMapDataLaneTypeAttributesParams(packetHandle, value.laneType, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataLaneAttributesParams(LONG packetHandle, struct MapDataLaneAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "shareWith");
  if(value.shareWith.isValidFlag==1)
  {
      for(j=0; j<value.shareWith.stringLength; j++)
      {
        if(value.shareWith.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneType");
  SetMapDataLaneTypeAttributesParams(packetHandle, value.laneType, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataConnectingLaneParams(LONG packetHandle, struct MapDataConnectingLane value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
  value.lane = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuver");
  value.maneuver.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.maneuver.isValidFlag==1)
  {
    value.maneuver.isValidFlag = 1;
    value.maneuver.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
    if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
    {
      if(value.maneuver.stringLength > 0)
      {
        for(j=0; j<value.maneuver.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.maneuver.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 1)
          {
            value.maneuver.string[j] = '1';
          }

          if(value.maneuver.stringLength == 1)
          {
            value.maneuver.string[1] = '0';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.maneuver.stringLength+1; k > -1; k--)
        {
          if(value.maneuver.string[k] == '1')
          {
            value.maneuver.string[k] = '0';
          }
        }
      }
    }

  }
  return result;
}

int SetMapDataConnectingLaneParams(LONG packetHandle, struct MapDataConnectingLane value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.lane);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuver");
  if(value.maneuver.isValidFlag==1)
  {
      for(j=0; j<value.maneuver.stringLength; j++)
      {
        if(value.maneuver.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  return result;
}

int GetMapDataConnectionParams(LONG packetHandle, struct MapDataConnection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  GetMapDataNodeReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectingLane");
  value.connectingLane.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.connectingLane.isValidFlag==1)
  {
    GetMapDataConnectingLaneParams(packetHandle, value.connectingLane, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "phaseId");
  value.phaseId.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.phaseId.isValidFlag==1)
  {
    value.phaseId.value = C2xGetTokenInt(packetHandle, "MapData", newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int SetMapDataConnectionParams(LONG packetHandle, struct MapDataConnection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  SetMapDataNodeReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectingLane");
  if(value.connectingLane.isValidFlag==1)
  {
    SetMapDataConnectingLaneParams(packetHandle, value.connectingLane, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "phaseId");
  if(value.phaseId.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MapData", newPath, value.phaseId.value);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  return result;
}

int GetMapDataConnectsToListParams(LONG packetHandle, struct MapDataConnectsToList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MapData", oldPath);
  if((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMapDataConnectionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMapDataConnectsToListParams(LONG packetHandle, struct MapDataConnectsToList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MapData", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMapDataConnectionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int GetMapDataLaneParams(LONG packetHandle, struct MapDataLane value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  value.laneID = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAttributes");
  value.laneAttributes.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.laneAttributes.isValidFlag==1)
  {
    GetMapDataLaneAttributesParams(packetHandle, value.laneAttributes, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuvers");
  value.maneuvers.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.maneuvers.isValidFlag==1)
  {
    value.maneuvers.isValidFlag = 1;
    value.maneuvers.stringLength = C2xGetTokenLengthBit(packetHandle, "MapData", newPath);
    if ((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
    {
      if(value.maneuvers.stringLength > 0)
      {
        for(j=0; j<value.maneuvers.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 0)
          {
            value.maneuvers.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "MapData", newPath, j) == 1)
          {
            value.maneuvers.string[j] = '1';
          }

          if(value.maneuvers.stringLength == 1)
          {
            value.maneuvers.string[1] = '0';
          }
          result = CheckLastError("MapData", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.maneuvers.stringLength+1; k > -1; k--)
        {
          if(value.maneuvers.string[k] == '1')
          {
            value.maneuvers.string[k] = '0';
          }
        }
      }
    }

  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectsTo");
  value.connectsTo.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.connectsTo.isValidFlag==1)
  {
    GetMapDataConnectsToListParams(packetHandle, value.connectsTo, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  value.speedLimits.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.speedLimits.isValidFlag==1)
  {
    GetMapDataSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "points");
  value.points.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.points.isValidFlag==1)
  {
    GetMapDataPointListParams(packetHandle, value.points, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int SetMapDataLaneParams(LONG packetHandle, struct MapDataLane value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.laneID);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAttributes");
  if(value.laneAttributes.isValidFlag==1)
  {
    SetMapDataLaneAttributesParams(packetHandle, value.laneAttributes, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuvers");
  if(value.maneuvers.isValidFlag==1)
  {
      for(j=0; j<value.maneuvers.stringLength; j++)
      {
        if(value.maneuvers.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MapData", newPath, j, 1);
        }
        result = CheckLastError("MapData", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectsTo");
  if(value.connectsTo.isValidFlag==1)
  {
    SetMapDataConnectsToListParams(packetHandle, value.connectsTo, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  if(value.speedLimits.isValidFlag==1)
  {
    SetMapDataSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "points");
  if(value.points.isValidFlag==1)
  {
    SetMapDataPointListParams(packetHandle, value.points, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  return result;
}

int GetMapDataLaneListParams(LONG packetHandle, struct MapDataLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MapData", oldPath);
  if((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMapDataLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMapDataLaneListParams(LONG packetHandle, struct MapDataLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MapData", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMapDataLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int GetMapDataLinkParams(LONG packetHandle, struct MapDataLink value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "MapData", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "upstreamNodeId");
  GetMapDataNodeReferenceIDParams(packetHandle, value.upstreamNodeId, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  value.speedLimits.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.speedLimits.isValidFlag==1)
  {
    GetMapDataSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  value.laneWidth = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "points");
  value.points.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.points.isValidFlag==1)
  {
    GetMapDataPointListParams(packetHandle, value.points, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "movements");
  value.movements.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.movements.isValidFlag==1)
  {
    GetMapDataMovementListParams(packetHandle, value.movements, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lanes");
  GetMapDataLaneListParams(packetHandle, value.lanes, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataLinkParams(LONG packetHandle, struct MapDataLink value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MapData", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "upstreamNodeId");
  SetMapDataNodeReferenceIDParams(packetHandle, value.upstreamNodeId, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  if(value.speedLimits.isValidFlag==1)
  {
    SetMapDataSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.laneWidth);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "points");
  if(value.points.isValidFlag==1)
  {
    SetMapDataPointListParams(packetHandle, value.points, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "movements");
  if(value.movements.isValidFlag==1)
  {
    SetMapDataMovementListParams(packetHandle, value.movements, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lanes");
  SetMapDataLaneListParams(packetHandle, value.lanes, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int GetMapDataLinkListParams(LONG packetHandle, struct MapDataLinkList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MapData", oldPath);
  if((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMapDataLinkParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMapDataLinkListParams(LONG packetHandle, struct MapDataLinkList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MapData", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMapDataLinkParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int GetMapDataNodeParams(LONG packetHandle, struct MapDataNode value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "MapData", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetMapDataNodeReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPos");
  GetMapDataPosition3DParams(packetHandle, value.refPos, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "inLinks");
  value.inLinks.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.inLinks.isValidFlag==1)
  {
    GetMapDataLinkListParams(packetHandle, value.inLinks, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int SetMapDataNodeParams(LONG packetHandle, struct MapDataNode value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MapData", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetMapDataNodeReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPos");
  SetMapDataPosition3DParams(packetHandle, value.refPos, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "inLinks");
  if(value.inLinks.isValidFlag==1)
  {
    SetMapDataLinkListParams(packetHandle, value.inLinks, newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  return result;
}

int GetMapDataNodeListParams(LONG packetHandle, struct MapDataNodeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MapData", oldPath);
  if((result = CheckLastError("MapData", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMapDataNodeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MapData", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMapDataNodeListParams(LONG packetHandle, struct MapDataNodeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MapData", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMapDataNodeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  return result;
}

int GetMapDataMAPFrameParams(LONG packetHandle, struct MapDataMAPFrame value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCnt");
  value.msgCnt = C2xGetTokenInt(packetHandle, "MapData", newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "MapData", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "MapData", newPath);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
  GetMapDataNodeListParams(packetHandle, value.nodes, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int SetMapDataMAPFrameParams(LONG packetHandle, struct MapDataMAPFrame value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCnt");
  C2xSetTokenInt(packetHandle, "MapData", newPath, value.msgCnt);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MapData", newPath, value.timeStamp.value);
    result = CheckLastError("MapData", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MapData", newPath) )
    {
      C2xRemoveToken(packetHandle, "MapData", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
  SetMapDataNodeListParams(packetHandle, value.nodes, newPath);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int API_GetMapDataParams(LONG packetHandle, struct MapData value)
{
  int result;
  result = 0;

  value.frameType = C2xGetTokenInt(packetHandle, "MapData", "frameType");
  result = CheckLastError("MapData", gkFuncRefGet, result);

  value.mapFrame.isValidFlag = 1;
  GetMapDataMAPFrameParams(packetHandle, value.mapFrame, "mapFrame");
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

int API_SetMapDataParams(LONG packetHandle, struct MapData value)
{
  int result;
  result = 0;

  C2xSetTokenInt(packetHandle, "MapData", "frameType", value.frameType);
  result = CheckLastError("MapData", gkFuncRefGet, result);

  SetMapDataMAPFrameParams(packetHandle, value.mapFrame, "mapFrame");
  result = CheckLastError("MapData", gkFuncRefGet, result);

  return result;
}

