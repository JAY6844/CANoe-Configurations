/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct MAP payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitMAPPacket();
//  if (packetHandle!=0) {
//    if (API_SetMAPParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    const int sizeMAPDSRC_NodeXY = 20;                      // Original size is 63, but compilation time is very high with this value. Recommended val is 20
                                                            // Path in MAP: map.intersections.DSRC_IntersectionGeometry.laneSet.DSRC_GenericLane.nodeList.nodes                                                       
  
    const int sizeMAPDSRC_GenericLane = 40;                 // Original size is 255, but compilation time is very high with this value. Recommended val is 40
                                                            // Path in MAP: map.intersections.DSRC_IntersectionGeometry.laneSet
  
    const int sizeMAPDSRC_IntersectionGeometry = 4;         // Original size is 32, but compilation time is very high with this value. Recommended val is 4
                                                            // Path in MAP: map.intersections.DSRC_IntersectionGeometry
  
    const int sizeMAPDSRC_RestrictionClassAssignment = 10;  // Original size is 254, but compilation time is very high with this value. Recommended val is 10
                                                            // Path in MAP: map.restrictionList.DSRC_RestrictionClassAssignment
  
    struct MAPDescriptiveName {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[64];
        INT  stringLength;
    };
    
    struct MAPIntersectionReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct MAP_AddGrpB_LatitudeDMS2 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT d;  // INTEGER, -90..90;
        BYTE m;  // INTEGER, 0..59;
        WORD s;  // INTEGER, 0..5999;
    };
    
    struct MAP_AddGrpB_LongitudeDMS2 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT d;  // INTEGER, -180..180;
        BYTE m;  // INTEGER, 0..59;
        WORD s;  // INTEGER, 0..5999;
    };
    
    struct MAP_AddGrpB_Position3D_addGrpB {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAP_AddGrpB_LatitudeDMS2 latitude;  // SEQUENCE;
        struct MAP_AddGrpB_LongitudeDMS2 longitude;  // SEQUENCE;
        INT elevation;  // INTEGER, -32768..32767;
    };
    
    struct MAP_AddGrpC_Altitude {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG value;  // INTEGER, -100000..800001;
        INT confidence;  // ENUMERATED, alt_000_01(0), alt_000_02(1), alt_000_05(2), alt_000_10(3), alt_000_20(4), alt_000_50(5), alt_001_00(6), alt_002_00(7), alt_005_00(8), alt_010_00(9), alt_020_00(10), alt_050_00(11), alt_100_00(12), alt_200_00(13), outOfRange(14), unavailable(15);
    };
    
    struct MAP_AddGrpC_Position3D_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAP_AddGrpC_Altitude altitude;  // SEQUENCE;
    };
    
    struct MAPREG_EXT_ID_AND_TYPE_Position3D {
        struct MAP_AddGrpB_Position3D_addGrpB addGrpB;  // SEQUENCE;
        struct MAP_AddGrpC_Position3D_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct MAPRegionalExtensionPosition3D {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_Position3D regExtValue;  // TABLE;
    };
    
    struct MAP_Position3D_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionPosition3D arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPPosition3D {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lat;  // INTEGER, -900000000..900000001;
        LONG lon;  // INTEGER, -1799999999..1800000001;
        struct OPT_LONG_ASN elevation;  // INTEGER, OPTIONAL, -4096..61439;
        struct MAP_Position3D_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPRegulatorySpeedLimit {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT type;  // ENUMERATED, unknown(0), maxSpeedInSchoolZone(1), maxSpeedInSchoolZoneWhenChildrenArePresent(2), maxSpeedInConstructionZone(3), vehicleMinSpeed(4), vehicleMaxSpeed(5), vehicleNightMaxSpeed(6), truckMinSpeed(7), truckMaxSpeed(8), truckNightMaxSpeed(9), vehiclesWithTrailersMinSpeed(10), vehiclesWithTrailersMaxSpeed(11), vehiclesWithTrailersNightMaxSpeed(12);
        WORD speed;  // INTEGER, 0..8191;
    };
    
    struct MAPSpeedLimitList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegulatorySpeedLimit arrayValue[9];  // SEQUENCE;
    };
    
    struct MAPLaneDirection {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
    };
    
    struct MAPLaneSharing {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[11];
        INT  stringLength;
    };
    
    struct MAPLaneAttributes_Vehicle {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[9];
        INT  stringLength;
    };
    
    struct MAPLaneAttributes_Crosswalk {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPLaneAttributes_Bike {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPLaneAttributes_Sidewalk {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPLaneAttributes_Barrier {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPLaneAttributes_Striping {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPLaneAttributes_TrackedVehicle {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPLaneAttributes_Parking {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct MAPLaneTypeAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MAPLaneAttributes_Vehicle vehicle;  // BITSTRING;
        struct MAPLaneAttributes_Crosswalk crosswalk;  // BITSTRING;
        struct MAPLaneAttributes_Bike bikeLane;  // BITSTRING;
        struct MAPLaneAttributes_Sidewalk sidewalk;  // BITSTRING;
        struct MAPLaneAttributes_Barrier median;  // BITSTRING;
        struct MAPLaneAttributes_Striping striping;  // BITSTRING;
        struct MAPLaneAttributes_TrackedVehicle trackedVehicle;  // BITSTRING;
        struct MAPLaneAttributes_Parking parking;  // BITSTRING;
    };
    
    struct MAPREG_EXT_ID_AND_TYPE_Empty {
    };
    
    struct MAPRegionalExtensionLaneAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct MAPLaneAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPLaneDirection directionalUse;  // BITSTRING;
        struct MAPLaneSharing sharedWith;  // BITSTRING;
        struct MAPLaneTypeAttributes laneType;  // CHOICE;
        struct MAPRegionalExtensionLaneAttributes regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct MAPAllowedManeuvers {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[13];
        INT  stringLength;
    };
    
    struct MAPNode_XY_20b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -512..511;
        INT y;  // INTEGER, -512..511;
    };
    
    struct MAPNode_XY_22b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -1024..1023;
        INT y;  // INTEGER, -1024..1023;
    };
    
    struct MAPNode_XY_24b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -2048..2047;
        INT y;  // INTEGER, -2048..2047;
    };
    
    struct MAPNode_XY_26b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -4096..4095;
        INT y;  // INTEGER, -4096..4095;
    };
    
    struct MAPNode_XY_28b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -8192..8191;
        INT y;  // INTEGER, -8192..8191;
    };
    
    struct MAPNode_XY_32b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -32768..32767;
        INT y;  // INTEGER, -32768..32767;
    };
    
    struct MAPNode_LLmD_64b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -1799999999..1800000001;
        LONG lat;  // INTEGER, -900000000..900000001;
    };
    
    struct MAP_AddGrpB_Node_LLdms_48b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -64800000..64800000;
        LONG lat;  // INTEGER, -32400000..32400000;
    };
    
    struct MAP_AddGrpB_Node_LLdms_80b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAP_AddGrpB_LongitudeDMS2 lon;  // SEQUENCE;
        struct MAP_AddGrpB_LatitudeDMS2 lat;  // SEQUENCE;
    };
    
    struct MAP_AddGrpB_NodeOffsetPointXY_addGrpB {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MAP_AddGrpB_Node_LLdms_48b posA;  // SEQUENCE;
        struct MAP_AddGrpB_Node_LLdms_80b posB;  // SEQUENCE;
    };
    
    struct MAPREG_EXT_ID_AND_TYPE_NodeOffsetPointXY {
        struct MAP_AddGrpB_NodeOffsetPointXY_addGrpB addGrpB;  // CHOICE;
    };
    
    struct MAPRegionalExtensionNodeOffsetPointXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_NodeOffsetPointXY regExtValue;  // TABLE;
    };
    
    struct MAPNodeOffsetPointXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MAPNode_XY_20b node_XY1;  // SEQUENCE;
        struct MAPNode_XY_22b node_XY2;  // SEQUENCE;
        struct MAPNode_XY_24b node_XY3;  // SEQUENCE;
        struct MAPNode_XY_26b node_XY4;  // SEQUENCE;
        struct MAPNode_XY_28b node_XY5;  // SEQUENCE;
        struct MAPNode_XY_32b node_XY6;  // SEQUENCE;
        struct MAPNode_LLmD_64b node_LatLon;  // SEQUENCE;
        struct MAPRegionalExtensionNodeOffsetPointXY regional;  // SEQUENCE;
    };
    
    struct MAPNodeAttributeXYList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        INT arrayValue[8];  // ENUMERATED, reserved(0), stopLine(1), roundedCapStyleA(2), roundedCapStyleB(3), mergePoint(4), divergePoint(5), downstreamStopLine(6), downstreamStartNode(7), closedToTraffic(8), safeIsland(9), curbPresentAtStepOff(10), hydrantPresent(11);
    };
    
    struct MAPSegmentAttributeXYList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        INT arrayValue[8];  // ENUMERATED, reserved(0), doNotBlock(1), whiteLine(2), mergingLaneLeft(3), mergingLaneRight(4), curbOnLeft(5), curbOnRight(6), loadingzoneOnLeft(7), loadingzoneOnRight(8), turnOutPointOnLeft(9), turnOutPointOnRight(10), adjacentParkingOnLeft(11), adjacentParkingOnRight(12), adjacentBikeLaneOnLeft(13), adjacentBikeLaneOnRight(14), sharedBikeLane(15), bikeBoxInFront(16), transitStopOnLeft(17), transitStopOnRight(18), transitStopInLane(19), sharedWithTrackedVehicle(20), safeIsland(21), lowCurbsPresent(22), rumbleStripPresent(23), audibleSignalingPresent(24), adaptiveTimingPresent(25), rfSignalRequestPresent(26), partialCurbIntrusion(27), taperToLeft(28), taperToRight(29), taperToCenterLine(30), parallelParking(31), headInParking(32), freeParking(33), timeRestrictionsOnParking(34), costToPark(35), midBlockCurbPresent(36), unEvenPavementPresent(37);
    };
    
    struct MAP_AddGrpB_LaneDataAttribute_addGrpB {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct MAPREG_EXT_ID_AND_TYPE_LaneDataAttribute {
        struct MAP_AddGrpB_LaneDataAttribute_addGrpB addGrpB;  // SEQUENCE;
    };
    
    struct MAPRegionalExtensionLaneDataAttribute {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_LaneDataAttribute regExtValue;  // TABLE;
    };
    
    struct MAP_LaneDataAttribute_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionLaneDataAttribute arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPLaneDataAttribute {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT pathEndPointAngle;  // INTEGER, -150..150;
        INT laneCrownPointCenter;  // INTEGER, -128..127;
        INT laneCrownPointLeft;  // INTEGER, -128..127;
        INT laneCrownPointRight;  // INTEGER, -128..127;
        INT laneAngle;  // INTEGER, -180..180;
        struct MAPSpeedLimitList speedLimits;  // SEQUENCEOF;
        struct MAP_LaneDataAttribute_regional regional;  // SEQUENCEOF;
    };
    
    struct MAPLaneDataAttributeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPLaneDataAttribute arrayValue[8];  // CHOICE;
    };
    
    struct MAPRegionalExtensionNodeAttributeSetXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct MAP_NodeAttributeSetXY_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionNodeAttributeSetXY arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPNodeAttributeSetXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPNodeAttributeXYList localNode;  // SEQUENCEOF, OPTIONAL;
        struct MAPSegmentAttributeXYList disabled;  // SEQUENCEOF, OPTIONAL;
        struct MAPSegmentAttributeXYList enabled;  // SEQUENCEOF, OPTIONAL;
        struct MAPLaneDataAttributeList data;  // SEQUENCEOF, OPTIONAL;
        struct OPT_INT_ASN dWidth;  // INTEGER, OPTIONAL, -512..511;
        struct OPT_INT_ASN dElevation;  // INTEGER, OPTIONAL, -512..511;
        struct MAP_NodeAttributeSetXY_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPNodeXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPNodeOffsetPointXY delta;  // CHOICE;
        struct MAPNodeAttributeSetXY attributes;  // SEQUENCE, OPTIONAL;
    };
    
    struct MAPNodeSetXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPNodeXY arrayValue[sizeMAPDSRC_NodeXY];  // SEQUENCE;
    };
    
    struct MAP_ComputedLane_offsetXaxis {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT small;  // INTEGER, -2047..2047;
        INT large;  // INTEGER, -32767..32767;
    };
    
    struct MAP_ComputedLane_offsetYaxis {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT small;  // INTEGER, -2047..2047;
        INT large;  // INTEGER, -32767..32767;
    };
    
    struct MAPRegionalExtensionComputedLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct MAP_ComputedLane_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionComputedLane arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPComputedLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE referenceLaneId;  // INTEGER, 0..255;
        struct MAP_ComputedLane_offsetXaxis offsetXaxis;  // CHOICE;
        struct MAP_ComputedLane_offsetYaxis offsetYaxis;  // CHOICE;
        struct OPT_WORD_ASN rotateXY;  // INTEGER, OPTIONAL, 0..28800;
        struct OPT_INT_ASN scaleXaxis;  // INTEGER, OPTIONAL, -2048..2047;
        struct OPT_INT_ASN scaleYaxis;  // INTEGER, OPTIONAL, -2048..2047;
        struct MAP_ComputedLane_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPNodeListXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct MAPNodeSetXY nodes;  // SEQUENCEOF;
        struct MAPComputedLane computed;  // SEQUENCE;
    };
    
    struct MAPConnectingLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE lane;  // INTEGER, 0..255;
        struct MAPAllowedManeuvers maneuver;  // BITSTRING, OPTIONAL;
    };
    
    struct MAPConnection {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPConnectingLane connectingLane;  // SEQUENCE;
        struct MAPIntersectionReferenceID remoteIntersection;  // SEQUENCE, OPTIONAL;
        struct OPT_BYTE_ASN signalGroup;  // INTEGER, OPTIONAL, 0..255;
        struct OPT_BYTE_ASN userClass;  // INTEGER, OPTIONAL, 0..255;
        struct OPT_BYTE_ASN connectionID;  // INTEGER, OPTIONAL, 0..255;
    };
    
    struct MAPConnectsToList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPConnection arrayValue[16];  // SEQUENCE;
    };
    
    struct MAPOverlayLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        BYTE arrayValue[5];  // INTEGER, 0..255;
    };
    
    struct MAPRegionalExtensionGenericLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct MAP_GenericLane_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionGenericLane arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPGenericLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE laneID;  // INTEGER, 0..255;
        struct MAPDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct OPT_BYTE_ASN ingressApproach;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_BYTE_ASN egressApproach;  // INTEGER, OPTIONAL, 0..15;
        struct MAPLaneAttributes laneAttributes;  // SEQUENCE;
        struct MAPAllowedManeuvers maneuvers;  // BITSTRING, OPTIONAL;
        struct MAPNodeListXY nodeList;  // CHOICE;
        struct MAPConnectsToList connectsTo;  // SEQUENCEOF, OPTIONAL;
        struct MAPOverlayLaneList overlays;  // SEQUENCEOF, OPTIONAL;
        struct MAP_GenericLane_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPGenericLane arrayValue[sizeMAPDSRC_GenericLane];  // SEQUENCE;
    };
    
    struct MAPRegionalExtensionSignalControlZone {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct MAPSignalControlZone {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPRegionalExtensionSignalControlZone zone;  // SEQUENCE;
    };
    
    struct MAPPreemptPriorityList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPSignalControlZone arrayValue[32];  // SEQUENCE;
    };
    
    struct MAPRegionalExtensionIntersectionGeometry {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct MAP_IntersectionGeometry_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionIntersectionGeometry arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPIntersectionGeometry {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct MAPIntersectionReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct MAPPosition3D refPoint;  // SEQUENCE;
        struct OPT_WORD_ASN laneWidth;  // INTEGER, OPTIONAL, 0..32767;
        struct MAPSpeedLimitList speedLimits;  // SEQUENCEOF, OPTIONAL;
        struct MAPLaneList laneSet;  // SEQUENCEOF;
        struct MAPPreemptPriorityList preemptPriorityData;  // SEQUENCEOF, OPTIONAL;
        struct MAP_IntersectionGeometry_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPIntersectionGeometryList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPIntersectionGeometry arrayValue[sizeMAPDSRC_IntersectionGeometry];  // SEQUENCE;
    };
    
    struct MAPRoadSegmentReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct MAPRoadLaneSetList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPGenericLane arrayValue[sizeMAPDSRC_GenericLane];  // SEQUENCE;
    };
    
    struct MAPRegionalExtensionRoadSegment {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct MAP_RoadSegment_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionRoadSegment arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPRoadSegment {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct MAPRoadSegmentReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct MAPPosition3D refPoint;  // SEQUENCE;
        struct OPT_WORD_ASN laneWidth;  // INTEGER, OPTIONAL, 0..32767;
        struct MAPSpeedLimitList speedLimits;  // SEQUENCEOF, OPTIONAL;
        struct MAPRoadLaneSetList roadLaneSet;  // SEQUENCEOF;
        struct MAP_RoadSegment_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPRoadSegmentList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRoadSegment arrayValue[32];  // SEQUENCE;
    };
    
    struct MAP_DataParameters_processMethod {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct MAP_DataParameters_processAgency {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct MAP_DataParameters_lastCheckedDate {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct MAP_DataParameters_geoidUsed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct MAPDataParameters {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAP_DataParameters_processMethod processMethod;  // IA5STRING, OPTIONAL;
        struct MAP_DataParameters_processAgency processAgency;  // IA5STRING, OPTIONAL;
        struct MAP_DataParameters_lastCheckedDate lastCheckedDate;  // IA5STRING, OPTIONAL;
        struct MAP_DataParameters_geoidUsed geoidUsed;  // IA5STRING, OPTIONAL;
    };
    
    struct MAP_AddGrpC_RestrictionUserType_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_ENUM_ASN emission;  // ENUMERATED, OPTIONAL, typeA(0), typeB(1), typeC(2), typeD(3), typeE(4);
    };
    
    struct MAPREG_EXT_ID_AND_TYPE_RestrictionUserType {
        struct MAP_AddGrpC_RestrictionUserType_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct MAPRegionalExtensionRestrictionUserType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_RestrictionUserType regExtValue;  // TABLE;
    };
    
    struct MAP_RestrictionUserType_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionRestrictionUserType arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPRestrictionUserType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT basicType;  // ENUMERATED, none(0), equippedTransit(1), equippedTaxis(2), equippedOther(3), emissionCompliant(4), equippedBicycle(5), weightCompliant(6), heightCompliant(7), pedestrians(8), slowMovingPersons(9), wheelchairUsers(10), visualDisabilities(11), audioDisabilities(12), otherUnknownDisabilities(13);
        struct MAP_RestrictionUserType_regional regional;  // SEQUENCEOF;
    };
    
    struct MAPRestrictionUserTypeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRestrictionUserType arrayValue[16];  // CHOICE;
    };
    
    struct MAPRestrictionClassAssignment {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE id;  // INTEGER, 0..255;
        struct MAPRestrictionUserTypeList users;  // SEQUENCEOF;
    };
    
    struct MAPRestrictionClassList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRestrictionClassAssignment arrayValue[sizeMAPDSRC_RestrictionClassAssignment];  // SEQUENCE;
    };
    
    struct MAP_AddGrpC_SignalHeadLocation {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAPNodeOffsetPointXY node;  // CHOICE;
        BYTE signalGroupID;  // INTEGER, 0..255;
    };
    
    struct MAP_AddGrpC_SignalHeadLocationList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAP_AddGrpC_SignalHeadLocation arrayValue[20];  // SEQUENCE;
    };
    
    struct MAP_AddGrpC_MapData_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct MAP_AddGrpC_SignalHeadLocationList signalHeadLocations;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPREG_EXT_ID_AND_TYPE_MapData {
        struct MAP_AddGrpC_MapData_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct MAPRegionalExtensionMapData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct MAPREG_EXT_ID_AND_TYPE_MapData regExtValue;  // TABLE;
    };
    
    struct MAP_MapData_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct MAPRegionalExtensionMapData arrayValue[4];  // SEQUENCE;
    };
    
    struct MAPMapData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        BYTE msgIssueRevision;  // INTEGER, 0..127;
        struct OPT_ENUM_ASN layerType;  // ENUMERATED, OPTIONAL, none(0), mixedContent(1), generalMapData(2), intersectionData(3), curveData(4), roadwaySectionData(5), parkingAreaData(6), sharedLaneData(7);
        struct OPT_BYTE_ASN layerID;  // INTEGER, OPTIONAL, 0..100;
        struct MAPIntersectionGeometryList intersections;  // SEQUENCEOF, OPTIONAL;
        struct MAPRoadSegmentList roadSegments;  // SEQUENCEOF, OPTIONAL;
        struct MAPDataParameters dataParameters;  // SEQUENCE, OPTIONAL;
        struct MAPRestrictionClassList restrictionList;  // SEQUENCEOF, OPTIONAL;
        struct MAP_MapData_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct MAPMESSAGE_ID_AND_TYPE {
        struct MAPMapData mapData;  // SEQUENCE;
    };
    
    struct MAP {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD messageId;  // INTEGER, 0..32767, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollision_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData(18), signalPhaseAndTimingMessage(19), basicSafetyMessage(20), commonSafetyRequest(21), emergencyVehicleAlert(22), intersectionCollision(23), nmeaCorrections(24), probeDataManagement(25), probeVehicleData(26), roadSideAlert(27), rtcmCorrections(28), signalRequestMessage(29), signalStatusMessage(30), travelerInformation(31), personalSafetyMessage(32), testMessage00(240), testMessage01(241), testMessage02(242), testMessage03(243), testMessage04(244), testMessage05(245), testMessage06(246), testMessage07(247), testMessage08(248), testMessage09(249), testMessage10(250), testMessage11(251), testMessage12(252), testMessage13(253), testMessage14(254), testMessage15(255);
        struct MAPMESSAGE_ID_AND_TYPE value;  // TABLE;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitMAPPacket()
{
  return C2xInitPacket("MAP"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitMAPPacket(struct MAP msgStruct)
{
  long pktHandle;

  pktHandle = API_InitMAPPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetMAPParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitMAPPacket(struct MAP msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("MAP", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetMAPParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetMAPIntersectionReferenceIDParams(LONG packetHandle, struct MAPIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPIntersectionReferenceIDParams(LONG packetHandle, struct MAPIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.region.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.id);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpB_LatitudeDMS2Params(LONG packetHandle, struct MAP_AddGrpB_LatitudeDMS2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "d");
  value.d = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "m");
  value.m = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "s");
  value.s = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAP_AddGrpB_LatitudeDMS2Params(LONG packetHandle, struct MAP_AddGrpB_LatitudeDMS2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "d");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.d);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "m");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.m);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "s");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.s);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpB_LongitudeDMS2Params(LONG packetHandle, struct MAP_AddGrpB_LongitudeDMS2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "d");
  value.d = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "m");
  value.m = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "s");
  value.s = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAP_AddGrpB_LongitudeDMS2Params(LONG packetHandle, struct MAP_AddGrpB_LongitudeDMS2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "d");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.d);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "m");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.m);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "s");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.s);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpB_Position3D_addGrpBParams(LONG packetHandle, struct MAP_AddGrpB_Position3D_addGrpB value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latitude");
  GetMAP_AddGrpB_LatitudeDMS2Params(packetHandle, value.latitude, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longitude");
  GetMAP_AddGrpB_LongitudeDMS2Params(packetHandle, value.longitude, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAP_AddGrpB_Position3D_addGrpBParams(LONG packetHandle, struct MAP_AddGrpB_Position3D_addGrpB value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latitude");
  SetMAP_AddGrpB_LatitudeDMS2Params(packetHandle, value.latitude, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longitude");
  SetMAP_AddGrpB_LongitudeDMS2Params(packetHandle, value.longitude, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.elevation);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpC_AltitudeParams(LONG packetHandle, struct MAP_AddGrpC_Altitude value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "value");
  value.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAP_AddGrpC_AltitudeParams(LONG packetHandle, struct MAP_AddGrpC_Altitude value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "value");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.value);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.confidence);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpC_Position3D_addGrpCParams(LONG packetHandle, struct MAP_AddGrpC_Position3D_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitude");
  GetMAP_AddGrpC_AltitudeParams(packetHandle, value.altitude, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAP_AddGrpC_Position3D_addGrpCParams(LONG packetHandle, struct MAP_AddGrpC_Position3D_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "altitude");
  SetMAP_AddGrpC_AltitudeParams(packetHandle, value.altitude, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPREG_EXT_ID_AND_TYPE_Position3DParams(LONG packetHandle, WORD tableKey, struct MAPREG_EXT_ID_AND_TYPE_Position3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpB");
      GetMAP_AddGrpB_Position3D_addGrpBParams(packetHandle, value.addGrpB, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetMAP_AddGrpC_Position3D_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPREG_EXT_ID_AND_TYPE_Position3DParams(LONG packetHandle, WORD tableKey, struct MAPREG_EXT_ID_AND_TYPE_Position3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpB");
      SetMAP_AddGrpB_Position3D_addGrpBParams(packetHandle, value.addGrpB, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetMAP_AddGrpC_Position3D_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPRegionalExtensionPosition3DParams(LONG packetHandle, struct MAPRegionalExtensionPosition3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetMAPREG_EXT_ID_AND_TYPE_Position3DParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionPosition3DParams(LONG packetHandle, struct MAPRegionalExtensionPosition3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetMAPREG_EXT_ID_AND_TYPE_Position3DParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_Position3D_regionalParams(LONG packetHandle, struct MAP_Position3D_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionPosition3DParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_Position3D_regionalParams(LONG packetHandle, struct MAP_Position3D_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionPosition3DParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPPosition3DParams(LONG packetHandle, struct MAPPosition3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.elevation.isValidFlag==1)
  {
    value.elevation.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAP_Position3D_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPPosition3DParams(LONG packetHandle, struct MAPPosition3D value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lat);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lon);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  if(value.elevation.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.elevation.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAP_Position3D_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPRegulatorySpeedLimitParams(LONG packetHandle, struct MAPRegulatorySpeedLimit value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  value.type = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegulatorySpeedLimitParams(LONG packetHandle, struct MAPRegulatorySpeedLimit value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.type);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.speed);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPSpeedLimitListParams(LONG packetHandle, struct MAPSpeedLimitList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegulatorySpeedLimitParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPSpeedLimitListParams(LONG packetHandle, struct MAPSpeedLimitList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegulatorySpeedLimitParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPLaneTypeAttributesParams(LONG packetHandle, struct MAPLaneTypeAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicle");
      value.vehicle.isValidFlag = 1;
      value.vehicle.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.vehicle.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.vehicle.string[j] = '0';
          }
          else
          {
            value.vehicle.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crosswalk");
      value.crosswalk.isValidFlag = 1;
      value.crosswalk.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.crosswalk.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.crosswalk.string[j] = '0';
          }
          else
          {
            value.crosswalk.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "bikeLane");
      value.bikeLane.isValidFlag = 1;
      value.bikeLane.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.bikeLane.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.bikeLane.string[j] = '0';
          }
          else
          {
            value.bikeLane.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sidewalk");
      value.sidewalk.isValidFlag = 1;
      value.sidewalk.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.sidewalk.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.sidewalk.string[j] = '0';
          }
          else
          {
            value.sidewalk.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "median");
      value.median.isValidFlag = 1;
      value.median.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.median.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.median.string[j] = '0';
          }
          else
          {
            value.median.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "striping");
      value.striping.isValidFlag = 1;
      value.striping.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.striping.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.striping.string[j] = '0';
          }
          else
          {
            value.striping.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trackedVehicle");
      value.trackedVehicle.isValidFlag = 1;
      value.trackedVehicle.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.trackedVehicle.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.trackedVehicle.string[j] = '0';
          }
          else
          {
            value.trackedVehicle.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "parking");
      value.parking.isValidFlag = 1;
      value.parking.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
      if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.parking.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.parking.string[j] = '0';
          }
          else
          {
            value.parking.string[j] = '1';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPLaneTypeAttributesParams(LONG packetHandle, struct MAPLaneTypeAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicle");
      for(j=0; j<value.vehicle.stringLength; j++)
      {
        if(value.vehicle.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crosswalk");
      for(j=0; j<value.crosswalk.stringLength; j++)
      {
        if(value.crosswalk.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "bikeLane");
      for(j=0; j<value.bikeLane.stringLength; j++)
      {
        if(value.bikeLane.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sidewalk");
      for(j=0; j<value.sidewalk.stringLength; j++)
      {
        if(value.sidewalk.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "median");
      for(j=0; j<value.median.stringLength; j++)
      {
        if(value.median.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "striping");
      for(j=0; j<value.striping.stringLength; j++)
      {
        if(value.striping.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trackedVehicle");
      for(j=0; j<value.trackedVehicle.stringLength; j++)
      {
        if(value.trackedVehicle.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "parking");
      for(j=0; j<value.parking.stringLength; j++)
      {
        if(value.parking.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPRegionalExtensionLaneAttributesParams(LONG packetHandle, struct MAPRegionalExtensionLaneAttributes value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionLaneAttributesParams(LONG packetHandle, struct MAPRegionalExtensionLaneAttributes value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAPLaneAttributesParams(LONG packetHandle, struct MAPLaneAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionalUse");
  value.directionalUse.isValidFlag = 1;
  value.directionalUse.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
  if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    if(value.directionalUse.stringLength > 0)
    {
      for(j=0; j<value.directionalUse.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
        {
          value.directionalUse.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 1)
        {
          value.directionalUse.string[j] = '1';
        }

        if(value.directionalUse.stringLength == 1)
        {
          value.directionalUse.string[1] = '0';
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.directionalUse.stringLength+1; k > -1; k--)
      {
        if(value.directionalUse.string[k] == '1')
        {
          value.directionalUse.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sharedWith");
  value.sharedWith.isValidFlag = 1;
  value.sharedWith.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
  if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    if(value.sharedWith.stringLength > 0)
    {
      for(j=0; j<value.sharedWith.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
        {
          value.sharedWith.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 1)
        {
          value.sharedWith.string[j] = '1';
        }

        if(value.sharedWith.stringLength == 1)
        {
          value.sharedWith.string[1] = '0';
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.sharedWith.stringLength+1; k > -1; k--)
      {
        if(value.sharedWith.string[k] == '1')
        {
          value.sharedWith.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneType");
  GetMAPLaneTypeAttributesParams(packetHandle, value.laneType, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAPRegionalExtensionLaneAttributesParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPLaneAttributesParams(LONG packetHandle, struct MAPLaneAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionalUse");
    for(j=0; j<value.directionalUse.stringLength; j++)
    {
      if(value.directionalUse.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sharedWith");
    for(j=0; j<value.sharedWith.stringLength; j++)
    {
      if(value.sharedWith.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
      }
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneType");
  SetMAPLaneTypeAttributesParams(packetHandle, value.laneType, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAPRegionalExtensionLaneAttributesParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPNode_XY_20bParams(LONG packetHandle, struct MAPNode_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPNode_XY_20bParams(LONG packetHandle, struct MAPNode_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPNode_XY_22bParams(LONG packetHandle, struct MAPNode_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPNode_XY_22bParams(LONG packetHandle, struct MAPNode_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPNode_XY_24bParams(LONG packetHandle, struct MAPNode_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPNode_XY_24bParams(LONG packetHandle, struct MAPNode_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPNode_XY_26bParams(LONG packetHandle, struct MAPNode_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPNode_XY_26bParams(LONG packetHandle, struct MAPNode_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPNode_XY_28bParams(LONG packetHandle, struct MAPNode_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPNode_XY_28bParams(LONG packetHandle, struct MAPNode_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPNode_XY_32bParams(LONG packetHandle, struct MAPNode_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPNode_XY_32bParams(LONG packetHandle, struct MAPNode_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.x);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.y);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPNode_LLmD_64bParams(LONG packetHandle, struct MAPNode_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPNode_LLmD_64bParams(LONG packetHandle, struct MAPNode_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lon);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lat);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpB_Node_LLdms_48bParams(LONG packetHandle, struct MAP_AddGrpB_Node_LLdms_48b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAP_AddGrpB_Node_LLdms_48bParams(LONG packetHandle, struct MAP_AddGrpB_Node_LLdms_48b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lon);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lat);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpB_Node_LLdms_80bParams(LONG packetHandle, struct MAP_AddGrpB_Node_LLdms_80b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  GetMAP_AddGrpB_LongitudeDMS2Params(packetHandle, value.lon, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  GetMAP_AddGrpB_LatitudeDMS2Params(packetHandle, value.lat, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAP_AddGrpB_Node_LLdms_80bParams(LONG packetHandle, struct MAP_AddGrpB_Node_LLdms_80b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  SetMAP_AddGrpB_LongitudeDMS2Params(packetHandle, value.lon, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  SetMAP_AddGrpB_LatitudeDMS2Params(packetHandle, value.lat, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpB_NodeOffsetPointXY_addGrpBParams(LONG packetHandle, struct MAP_AddGrpB_NodeOffsetPointXY_addGrpB value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posA");
      GetMAP_AddGrpB_Node_LLdms_48bParams(packetHandle, value.posA, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posB");
      GetMAP_AddGrpB_Node_LLdms_80bParams(packetHandle, value.posB, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAP_AddGrpB_NodeOffsetPointXY_addGrpBParams(LONG packetHandle, struct MAP_AddGrpB_NodeOffsetPointXY_addGrpB value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posA");
      SetMAP_AddGrpB_Node_LLdms_48bParams(packetHandle, value.posA, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posB");
      SetMAP_AddGrpB_Node_LLdms_80bParams(packetHandle, value.posB, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPREG_EXT_ID_AND_TYPE_NodeOffsetPointXYParams(LONG packetHandle, WORD tableKey, struct MAPREG_EXT_ID_AND_TYPE_NodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpB");
      GetMAP_AddGrpB_NodeOffsetPointXY_addGrpBParams(packetHandle, value.addGrpB, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPREG_EXT_ID_AND_TYPE_NodeOffsetPointXYParams(LONG packetHandle, WORD tableKey, struct MAPREG_EXT_ID_AND_TYPE_NodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpB");
      SetMAP_AddGrpB_NodeOffsetPointXY_addGrpBParams(packetHandle, value.addGrpB, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPRegionalExtensionNodeOffsetPointXYParams(LONG packetHandle, struct MAPRegionalExtensionNodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetMAPREG_EXT_ID_AND_TYPE_NodeOffsetPointXYParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionNodeOffsetPointXYParams(LONG packetHandle, struct MAPRegionalExtensionNodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetMAPREG_EXT_ID_AND_TYPE_NodeOffsetPointXYParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPNodeOffsetPointXYParams(LONG packetHandle, struct MAPNodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      GetMAPNode_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      GetMAPNode_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      GetMAPNode_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      GetMAPNode_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      GetMAPNode_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      GetMAPNode_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      GetMAPNode_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      GetMAPRegionalExtensionNodeOffsetPointXYParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPNodeOffsetPointXYParams(LONG packetHandle, struct MAPNodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      SetMAPNode_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      SetMAPNode_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      SetMAPNode_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      SetMAPNode_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      SetMAPNode_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      SetMAPNode_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      SetMAPNode_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      SetMAPRegionalExtensionNodeOffsetPointXYParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPNodeAttributeXYListParams(LONG packetHandle, struct MAPNodeAttributeXYList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPNodeAttributeXYListParams(LONG packetHandle, struct MAPNodeAttributeXYList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "MAP", newPath, value.arrayValue[i]);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPSegmentAttributeXYListParams(LONG packetHandle, struct MAPSegmentAttributeXYList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPSegmentAttributeXYListParams(LONG packetHandle, struct MAPSegmentAttributeXYList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "MAP", newPath, value.arrayValue[i]);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRegionalExtensionLaneDataAttributeParams(LONG packetHandle, struct MAPRegionalExtensionLaneDataAttribute value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionLaneDataAttributeParams(LONG packetHandle, struct MAPRegionalExtensionLaneDataAttribute value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAP_LaneDataAttribute_regionalParams(LONG packetHandle, struct MAP_LaneDataAttribute_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionLaneDataAttributeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_LaneDataAttribute_regionalParams(LONG packetHandle, struct MAP_LaneDataAttribute_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionLaneDataAttributeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPLaneDataAttributeParams(LONG packetHandle, struct MAPLaneDataAttribute value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathEndPointAngle");
      value.pathEndPointAngle = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointCenter");
      value.laneCrownPointCenter = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointLeft");
      value.laneCrownPointLeft = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointRight");
      value.laneCrownPointRight = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAngle");
      value.laneAngle = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
      GetMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      GetMAP_LaneDataAttribute_regionalParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPLaneDataAttributeParams(LONG packetHandle, struct MAPLaneDataAttribute value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathEndPointAngle");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.pathEndPointAngle);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointCenter");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneCrownPointCenter);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointLeft");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneCrownPointLeft);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointRight");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneCrownPointRight);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAngle");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneAngle);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
      SetMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      SetMAP_LaneDataAttribute_regionalParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPLaneDataAttributeListParams(LONG packetHandle, struct MAPLaneDataAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPLaneDataAttributeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPLaneDataAttributeListParams(LONG packetHandle, struct MAPLaneDataAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPLaneDataAttributeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRegionalExtensionNodeAttributeSetXYParams(LONG packetHandle, struct MAPRegionalExtensionNodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionNodeAttributeSetXYParams(LONG packetHandle, struct MAPRegionalExtensionNodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAP_NodeAttributeSetXY_regionalParams(LONG packetHandle, struct MAP_NodeAttributeSetXY_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionNodeAttributeSetXYParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_NodeAttributeSetXY_regionalParams(LONG packetHandle, struct MAP_NodeAttributeSetXY_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionNodeAttributeSetXYParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPNodeAttributeSetXYParams(LONG packetHandle, struct MAPNodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "localNode");
  value.localNode.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.localNode.isValidFlag==1)
  {
    GetMAPNodeAttributeXYListParams(packetHandle, value.localNode, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "disabled");
  value.disabled.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.disabled.isValidFlag==1)
  {
    GetMAPSegmentAttributeXYListParams(packetHandle, value.disabled, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabled");
  value.enabled.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.enabled.isValidFlag==1)
  {
    GetMAPSegmentAttributeXYListParams(packetHandle, value.enabled, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "data");
  value.data.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.data.isValidFlag==1)
  {
    GetMAPLaneDataAttributeListParams(packetHandle, value.data, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dWidth");
  value.dWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.dWidth.isValidFlag==1)
  {
    value.dWidth.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dElevation");
  value.dElevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.dElevation.isValidFlag==1)
  {
    value.dElevation.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAP_NodeAttributeSetXY_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPNodeAttributeSetXYParams(LONG packetHandle, struct MAPNodeAttributeSetXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "localNode");
  if(value.localNode.isValidFlag==1)
  {
    SetMAPNodeAttributeXYListParams(packetHandle, value.localNode, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "disabled");
  if(value.disabled.isValidFlag==1)
  {
    SetMAPSegmentAttributeXYListParams(packetHandle, value.disabled, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabled");
  if(value.enabled.isValidFlag==1)
  {
    SetMAPSegmentAttributeXYListParams(packetHandle, value.enabled, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "data");
  if(value.data.isValidFlag==1)
  {
    SetMAPLaneDataAttributeListParams(packetHandle, value.data, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dWidth");
  if(value.dWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.dWidth.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dElevation");
  if(value.dElevation.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.dElevation.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAP_NodeAttributeSetXY_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPNodeXYParams(LONG packetHandle, struct MAPNodeXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "delta");
  GetMAPNodeOffsetPointXYParams(packetHandle, value.delta, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "attributes");
  value.attributes.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.attributes.isValidFlag==1)
  {
    GetMAPNodeAttributeSetXYParams(packetHandle, value.attributes, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPNodeXYParams(LONG packetHandle, struct MAPNodeXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "delta");
  SetMAPNodeOffsetPointXYParams(packetHandle, value.delta, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "attributes");
  if(value.attributes.isValidFlag==1)
  {
    SetMAPNodeAttributeSetXYParams(packetHandle, value.attributes, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPNodeSetXYParams(LONG packetHandle, struct MAPNodeSetXY value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPNodeXYParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPNodeSetXYParams(LONG packetHandle, struct MAPNodeSetXY value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPNodeXYParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAP_ComputedLane_offsetXaxisParams(LONG packetHandle, struct MAP_ComputedLane_offsetXaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      value.small = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      value.large = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAP_ComputedLane_offsetXaxisParams(LONG packetHandle, struct MAP_ComputedLane_offsetXaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.small);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.large);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAP_ComputedLane_offsetYaxisParams(LONG packetHandle, struct MAP_ComputedLane_offsetYaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      value.small = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      value.large = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAP_ComputedLane_offsetYaxisParams(LONG packetHandle, struct MAP_ComputedLane_offsetYaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.small);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.large);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPRegionalExtensionComputedLaneParams(LONG packetHandle, struct MAPRegionalExtensionComputedLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionComputedLaneParams(LONG packetHandle, struct MAPRegionalExtensionComputedLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAP_ComputedLane_regionalParams(LONG packetHandle, struct MAP_ComputedLane_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionComputedLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_ComputedLane_regionalParams(LONG packetHandle, struct MAP_ComputedLane_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionComputedLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPComputedLaneParams(LONG packetHandle, struct MAPComputedLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceLaneId");
  value.referenceLaneId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetXaxis");
  GetMAP_ComputedLane_offsetXaxisParams(packetHandle, value.offsetXaxis, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetYaxis");
  GetMAP_ComputedLane_offsetYaxisParams(packetHandle, value.offsetYaxis, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rotateXY");
  value.rotateXY.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.rotateXY.isValidFlag==1)
  {
    value.rotateXY.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleXaxis");
  value.scaleXaxis.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.scaleXaxis.isValidFlag==1)
  {
    value.scaleXaxis.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleYaxis");
  value.scaleYaxis.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.scaleYaxis.isValidFlag==1)
  {
    value.scaleYaxis.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAP_ComputedLane_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPComputedLaneParams(LONG packetHandle, struct MAPComputedLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceLaneId");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.referenceLaneId);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetXaxis");
  SetMAP_ComputedLane_offsetXaxisParams(packetHandle, value.offsetXaxis, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetYaxis");
  SetMAP_ComputedLane_offsetYaxisParams(packetHandle, value.offsetYaxis, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rotateXY");
  if(value.rotateXY.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.rotateXY.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleXaxis");
  if(value.scaleXaxis.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.scaleXaxis.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleYaxis");
  if(value.scaleYaxis.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.scaleYaxis.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAP_ComputedLane_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPNodeListXYParams(LONG packetHandle, struct MAPNodeListXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
      GetMAPNodeSetXYParams(packetHandle, value.nodes, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "computed");
      GetMAPComputedLaneParams(packetHandle, value.computed, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPNodeListXYParams(LONG packetHandle, struct MAPNodeListXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
      SetMAPNodeSetXYParams(packetHandle, value.nodes, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "computed");
      SetMAPComputedLaneParams(packetHandle, value.computed, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPConnectingLaneParams(LONG packetHandle, struct MAPConnectingLane value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
  value.lane = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuver");
  value.maneuver.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.maneuver.isValidFlag==1)
  {
    value.maneuver.isValidFlag = 1;
    value.maneuver.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
    if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
    {
      if(value.maneuver.stringLength > 0)
      {
        for(j=0; j<value.maneuver.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.maneuver.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 1)
          {
            value.maneuver.string[j] = '1';
          }

          if(value.maneuver.stringLength == 1)
          {
            value.maneuver.string[1] = '0';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.maneuver.stringLength+1; k > -1; k--)
        {
          if(value.maneuver.string[k] == '1')
          {
            value.maneuver.string[k] = '0';
          }
        }
      }
    }

  }
  return result;
}

int SetMAPConnectingLaneParams(LONG packetHandle, struct MAPConnectingLane value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.lane);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuver");
  if(value.maneuver.isValidFlag==1)
  {
      for(j=0; j<value.maneuver.stringLength; j++)
      {
        if(value.maneuver.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPConnectionParams(LONG packetHandle, struct MAPConnection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectingLane");
  GetMAPConnectingLaneParams(packetHandle, value.connectingLane, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  value.remoteIntersection.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.remoteIntersection.isValidFlag==1)
  {
    GetMAPIntersectionReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  value.signalGroup.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.signalGroup.isValidFlag==1)
  {
    value.signalGroup.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "userClass");
  value.userClass.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.userClass.isValidFlag==1)
  {
    value.userClass.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  value.connectionID.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.connectionID.isValidFlag==1)
  {
    value.connectionID.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPConnectionParams(LONG packetHandle, struct MAPConnection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectingLane");
  SetMAPConnectingLaneParams(packetHandle, value.connectingLane, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  if(value.remoteIntersection.isValidFlag==1)
  {
    SetMAPIntersectionReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  if(value.signalGroup.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.signalGroup.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "userClass");
  if(value.userClass.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.userClass.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  if(value.connectionID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.connectionID.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPConnectsToListParams(LONG packetHandle, struct MAPConnectsToList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPConnectionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPConnectsToListParams(LONG packetHandle, struct MAPConnectsToList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPConnectionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPOverlayLaneListParams(LONG packetHandle, struct MAPOverlayLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPOverlayLaneListParams(LONG packetHandle, struct MAPOverlayLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "MAP", newPath, value.arrayValue[i]);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRegionalExtensionGenericLaneParams(LONG packetHandle, struct MAPRegionalExtensionGenericLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionGenericLaneParams(LONG packetHandle, struct MAPRegionalExtensionGenericLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAP_GenericLane_regionalParams(LONG packetHandle, struct MAP_GenericLane_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_GenericLane_regionalParams(LONG packetHandle, struct MAP_GenericLane_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPGenericLaneParams(LONG packetHandle, struct MAPGenericLane value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  value.laneID = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "ingressApproach");
  value.ingressApproach.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.ingressApproach.isValidFlag==1)
  {
    value.ingressApproach.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "egressApproach");
  value.egressApproach.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.egressApproach.isValidFlag==1)
  {
    value.egressApproach.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAttributes");
  GetMAPLaneAttributesParams(packetHandle, value.laneAttributes, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuvers");
  value.maneuvers.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.maneuvers.isValidFlag==1)
  {
    value.maneuvers.isValidFlag = 1;
    value.maneuvers.stringLength = C2xGetTokenLengthBit(packetHandle, "MAP", newPath);
    if ((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
    {
      if(value.maneuvers.stringLength > 0)
      {
        for(j=0; j<value.maneuvers.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 0)
          {
            value.maneuvers.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "MAP", newPath, j) == 1)
          {
            value.maneuvers.string[j] = '1';
          }

          if(value.maneuvers.stringLength == 1)
          {
            value.maneuvers.string[1] = '0';
          }
          result = CheckLastError("MAP", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.maneuvers.stringLength+1; k > -1; k--)
        {
          if(value.maneuvers.string[k] == '1')
          {
            value.maneuvers.string[k] = '0';
          }
        }
      }
    }

  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodeList");
  GetMAPNodeListXYParams(packetHandle, value.nodeList, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectsTo");
  value.connectsTo.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.connectsTo.isValidFlag==1)
  {
    GetMAPConnectsToListParams(packetHandle, value.connectsTo, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "overlays");
  value.overlays.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.overlays.isValidFlag==1)
  {
    GetMAPOverlayLaneListParams(packetHandle, value.overlays, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAP_GenericLane_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPGenericLaneParams(LONG packetHandle, struct MAPGenericLane value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneID);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "ingressApproach");
  if(value.ingressApproach.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.ingressApproach.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "egressApproach");
  if(value.egressApproach.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.egressApproach.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAttributes");
  SetMAPLaneAttributesParams(packetHandle, value.laneAttributes, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuvers");
  if(value.maneuvers.isValidFlag==1)
  {
      for(j=0; j<value.maneuvers.stringLength; j++)
      {
        if(value.maneuvers.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "MAP", newPath, j, 1);
        }
        result = CheckLastError("MAP", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodeList");
  SetMAPNodeListXYParams(packetHandle, value.nodeList, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectsTo");
  if(value.connectsTo.isValidFlag==1)
  {
    SetMAPConnectsToListParams(packetHandle, value.connectsTo, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "overlays");
  if(value.overlays.isValidFlag==1)
  {
    SetMAPOverlayLaneListParams(packetHandle, value.overlays, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAP_GenericLane_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPLaneListParams(LONG packetHandle, struct MAPLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPLaneListParams(LONG packetHandle, struct MAPLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRegionalExtensionSignalControlZoneParams(LONG packetHandle, struct MAPRegionalExtensionSignalControlZone value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionSignalControlZoneParams(LONG packetHandle, struct MAPRegionalExtensionSignalControlZone value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAPSignalControlZoneParams(LONG packetHandle, struct MAPSignalControlZone value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "zone");
  GetMAPRegionalExtensionSignalControlZoneParams(packetHandle, value.zone, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPSignalControlZoneParams(LONG packetHandle, struct MAPSignalControlZone value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "zone");
  SetMAPRegionalExtensionSignalControlZoneParams(packetHandle, value.zone, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPPreemptPriorityListParams(LONG packetHandle, struct MAPPreemptPriorityList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPSignalControlZoneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPPreemptPriorityListParams(LONG packetHandle, struct MAPPreemptPriorityList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPSignalControlZoneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRegionalExtensionIntersectionGeometryParams(LONG packetHandle, struct MAPRegionalExtensionIntersectionGeometry value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionIntersectionGeometryParams(LONG packetHandle, struct MAPRegionalExtensionIntersectionGeometry value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAP_IntersectionGeometry_regionalParams(LONG packetHandle, struct MAP_IntersectionGeometry_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionIntersectionGeometryParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_IntersectionGeometry_regionalParams(LONG packetHandle, struct MAP_IntersectionGeometry_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionIntersectionGeometryParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPIntersectionGeometryParams(LONG packetHandle, struct MAPIntersectionGeometry value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetMAPIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  GetMAPPosition3DParams(packetHandle, value.refPoint, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  value.laneWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.laneWidth.isValidFlag==1)
  {
    value.laneWidth.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  value.speedLimits.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.speedLimits.isValidFlag==1)
  {
    GetMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneSet");
  GetMAPLaneListParams(packetHandle, value.laneSet, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "preemptPriorityData");
  value.preemptPriorityData.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.preemptPriorityData.isValidFlag==1)
  {
    GetMAPPreemptPriorityListParams(packetHandle, value.preemptPriorityData, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAP_IntersectionGeometry_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPIntersectionGeometryParams(LONG packetHandle, struct MAPIntersectionGeometry value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetMAPIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.revision);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  SetMAPPosition3DParams(packetHandle, value.refPoint, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  if(value.laneWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneWidth.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  if(value.speedLimits.isValidFlag==1)
  {
    SetMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneSet");
  SetMAPLaneListParams(packetHandle, value.laneSet, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "preemptPriorityData");
  if(value.preemptPriorityData.isValidFlag==1)
  {
    SetMAPPreemptPriorityListParams(packetHandle, value.preemptPriorityData, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAP_IntersectionGeometry_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPIntersectionGeometryListParams(LONG packetHandle, struct MAPIntersectionGeometryList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPIntersectionGeometryParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPIntersectionGeometryListParams(LONG packetHandle, struct MAPIntersectionGeometryList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPIntersectionGeometryParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRoadSegmentReferenceIDParams(LONG packetHandle, struct MAPRoadSegmentReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRoadSegmentReferenceIDParams(LONG packetHandle, struct MAPRoadSegmentReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.region.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.id);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPRoadLaneSetListParams(LONG packetHandle, struct MAPRoadLaneSetList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPRoadLaneSetListParams(LONG packetHandle, struct MAPRoadLaneSetList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRegionalExtensionRoadSegmentParams(LONG packetHandle, struct MAPRegionalExtensionRoadSegment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionRoadSegmentParams(LONG packetHandle, struct MAPRegionalExtensionRoadSegment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetMAP_RoadSegment_regionalParams(LONG packetHandle, struct MAP_RoadSegment_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionRoadSegmentParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_RoadSegment_regionalParams(LONG packetHandle, struct MAP_RoadSegment_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionRoadSegmentParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRoadSegmentParams(LONG packetHandle, struct MAPRoadSegment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetMAPRoadSegmentReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  GetMAPPosition3DParams(packetHandle, value.refPoint, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  value.laneWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.laneWidth.isValidFlag==1)
  {
    value.laneWidth.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  value.speedLimits.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.speedLimits.isValidFlag==1)
  {
    GetMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadLaneSet");
  GetMAPRoadLaneSetListParams(packetHandle, value.roadLaneSet, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAP_RoadSegment_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPRoadSegmentParams(LONG packetHandle, struct MAPRoadSegment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetMAPRoadSegmentReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.revision);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  SetMAPPosition3DParams(packetHandle, value.refPoint, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  if(value.laneWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.laneWidth.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  if(value.speedLimits.isValidFlag==1)
  {
    SetMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadLaneSet");
  SetMAPRoadLaneSetListParams(packetHandle, value.roadLaneSet, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAP_RoadSegment_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPRoadSegmentListParams(LONG packetHandle, struct MAPRoadSegmentList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRoadSegmentParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPRoadSegmentListParams(LONG packetHandle, struct MAPRoadSegmentList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRoadSegmentParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPDataParametersParams(LONG packetHandle, struct MAPDataParameters value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processMethod");
  value.processMethod.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.processMethod.isValidFlag==1)
  {
    value.processMethod.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.processMethod.string), value.processMethod.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processAgency");
  value.processAgency.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.processAgency.isValidFlag==1)
  {
    value.processAgency.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.processAgency.string), value.processAgency.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lastCheckedDate");
  value.lastCheckedDate.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.lastCheckedDate.isValidFlag==1)
  {
    value.lastCheckedDate.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.lastCheckedDate.string), value.lastCheckedDate.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "geoidUsed");
  value.geoidUsed.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.geoidUsed.isValidFlag==1)
  {
    value.geoidUsed.stringLength = C2xGetTokenData(packetHandle, "MAP", newPath, elcount(value.geoidUsed.string), value.geoidUsed.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPDataParametersParams(LONG packetHandle, struct MAPDataParameters value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processMethod");
  if(value.processMethod.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.processMethod.stringLength, value.processMethod.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processAgency");
  if(value.processAgency.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.processAgency.stringLength, value.processAgency.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lastCheckedDate");
  if(value.lastCheckedDate.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.lastCheckedDate.stringLength, value.lastCheckedDate.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "geoidUsed");
  if(value.geoidUsed.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "MAP", newPath, value.geoidUsed.stringLength, value.geoidUsed.string);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAP_AddGrpC_RestrictionUserType_addGrpCParams(LONG packetHandle, struct MAP_AddGrpC_RestrictionUserType_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "emission");
  value.emission.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.emission.isValidFlag==1)
  {
    value.emission.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAP_AddGrpC_RestrictionUserType_addGrpCParams(LONG packetHandle, struct MAP_AddGrpC_RestrictionUserType_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "emission");
  if(value.emission.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.emission.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPREG_EXT_ID_AND_TYPE_RestrictionUserTypeParams(LONG packetHandle, WORD tableKey, struct MAPREG_EXT_ID_AND_TYPE_RestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetMAP_AddGrpC_RestrictionUserType_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPREG_EXT_ID_AND_TYPE_RestrictionUserTypeParams(LONG packetHandle, WORD tableKey, struct MAPREG_EXT_ID_AND_TYPE_RestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetMAP_AddGrpC_RestrictionUserType_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPRegionalExtensionRestrictionUserTypeParams(LONG packetHandle, struct MAPRegionalExtensionRestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetMAPREG_EXT_ID_AND_TYPE_RestrictionUserTypeParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionRestrictionUserTypeParams(LONG packetHandle, struct MAPRegionalExtensionRestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetMAPREG_EXT_ID_AND_TYPE_RestrictionUserTypeParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_RestrictionUserType_regionalParams(LONG packetHandle, struct MAP_RestrictionUserType_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionRestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_RestrictionUserType_regionalParams(LONG packetHandle, struct MAP_RestrictionUserType_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionRestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRestrictionUserTypeParams(LONG packetHandle, struct MAPRestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "MAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "basicType");
      value.basicType = C2xGetTokenInt(packetHandle, "MAP", newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      GetMAP_RestrictionUserType_regionalParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPRestrictionUserTypeParams(LONG packetHandle, struct MAPRestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "basicType");
      C2xSetTokenInt(packetHandle, "MAP", newPath, value.basicType);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      SetMAP_RestrictionUserType_regionalParams(packetHandle, value.regional, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPRestrictionUserTypeListParams(LONG packetHandle, struct MAPRestrictionUserTypeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPRestrictionUserTypeListParams(LONG packetHandle, struct MAPRestrictionUserTypeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPRestrictionClassAssignmentParams(LONG packetHandle, struct MAPRestrictionClassAssignment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "users");
  GetMAPRestrictionUserTypeListParams(packetHandle, value.users, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRestrictionClassAssignmentParams(LONG packetHandle, struct MAPRestrictionClassAssignment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.id);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "users");
  SetMAPRestrictionUserTypeListParams(packetHandle, value.users, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAPRestrictionClassListParams(LONG packetHandle, struct MAPRestrictionClassList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRestrictionClassAssignmentParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAPRestrictionClassListParams(LONG packetHandle, struct MAPRestrictionClassList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRestrictionClassAssignmentParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAP_AddGrpC_SignalHeadLocationParams(LONG packetHandle, struct MAP_AddGrpC_SignalHeadLocation value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node");
  GetMAPNodeOffsetPointXYParams(packetHandle, value.node, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroupID");
  value.signalGroupID = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAP_AddGrpC_SignalHeadLocationParams(LONG packetHandle, struct MAP_AddGrpC_SignalHeadLocation value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node");
  SetMAPNodeOffsetPointXYParams(packetHandle, value.node, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroupID");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.signalGroupID);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_AddGrpC_SignalHeadLocationListParams(LONG packetHandle, struct MAP_AddGrpC_SignalHeadLocationList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAP_AddGrpC_SignalHeadLocationParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_AddGrpC_SignalHeadLocationListParams(LONG packetHandle, struct MAP_AddGrpC_SignalHeadLocationList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAP_AddGrpC_SignalHeadLocationParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAP_AddGrpC_MapData_addGrpCParams(LONG packetHandle, struct MAP_AddGrpC_MapData_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalHeadLocations");
  value.signalHeadLocations.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.signalHeadLocations.isValidFlag==1)
  {
    GetMAP_AddGrpC_SignalHeadLocationListParams(packetHandle, value.signalHeadLocations, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAP_AddGrpC_MapData_addGrpCParams(LONG packetHandle, struct MAP_AddGrpC_MapData_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalHeadLocations");
  if(value.signalHeadLocations.isValidFlag==1)
  {
    SetMAP_AddGrpC_SignalHeadLocationListParams(packetHandle, value.signalHeadLocations, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPREG_EXT_ID_AND_TYPE_MapDataParams(LONG packetHandle, WORD tableKey, struct MAPREG_EXT_ID_AND_TYPE_MapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetMAP_AddGrpC_MapData_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPREG_EXT_ID_AND_TYPE_MapDataParams(LONG packetHandle, WORD tableKey, struct MAPREG_EXT_ID_AND_TYPE_MapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetMAP_AddGrpC_MapData_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetMAPRegionalExtensionMapDataParams(LONG packetHandle, struct MAPRegionalExtensionMapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetMAPREG_EXT_ID_AND_TYPE_MapDataParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int SetMAPRegionalExtensionMapDataParams(LONG packetHandle, struct MAPRegionalExtensionMapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetMAPREG_EXT_ID_AND_TYPE_MapDataParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int GetMAP_MapData_regionalParams(LONG packetHandle, struct MAP_MapData_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "MAP", oldPath);
  if((result = CheckLastError("MAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetMAPRegionalExtensionMapDataParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetMAP_MapData_regionalParams(LONG packetHandle, struct MAP_MapData_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "MAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetMAPRegionalExtensionMapDataParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int GetMAPMapDataParams(LONG packetHandle, struct MAPMapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgIssueRevision");
  value.msgIssueRevision = C2xGetTokenInt(packetHandle, "MAP", newPath);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerType");
  value.layerType.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.layerType.isValidFlag==1)
  {
    value.layerType.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerID");
  value.layerID.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.layerID.isValidFlag==1)
  {
    value.layerID.value = C2xGetTokenInt(packetHandle, "MAP", newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  value.intersections.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.intersections.isValidFlag==1)
  {
    GetMAPIntersectionGeometryListParams(packetHandle, value.intersections, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadSegments");
  value.roadSegments.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.roadSegments.isValidFlag==1)
  {
    GetMAPRoadSegmentListParams(packetHandle, value.roadSegments, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dataParameters");
  value.dataParameters.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.dataParameters.isValidFlag==1)
  {
    GetMAPDataParametersParams(packetHandle, value.dataParameters, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restrictionList");
  value.restrictionList.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.restrictionList.isValidFlag==1)
  {
    GetMAPRestrictionClassListParams(packetHandle, value.restrictionList, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "MAP", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetMAP_MapData_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  return result;
}

int SetMAPMapDataParams(LONG packetHandle, struct MAPMapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.timeStamp.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgIssueRevision");
  C2xSetTokenInt(packetHandle, "MAP", newPath, value.msgIssueRevision);
  result = CheckLastError("MAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerType");
  if(value.layerType.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.layerType.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerID");
  if(value.layerID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "MAP", newPath, value.layerID.value);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  if(value.intersections.isValidFlag==1)
  {
    SetMAPIntersectionGeometryListParams(packetHandle, value.intersections, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadSegments");
  if(value.roadSegments.isValidFlag==1)
  {
    SetMAPRoadSegmentListParams(packetHandle, value.roadSegments, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dataParameters");
  if(value.dataParameters.isValidFlag==1)
  {
    SetMAPDataParametersParams(packetHandle, value.dataParameters, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restrictionList");
  if(value.restrictionList.isValidFlag==1)
  {
    SetMAPRestrictionClassListParams(packetHandle, value.restrictionList, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetMAP_MapData_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("MAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "MAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "MAP", newPath);
    }
  }

  return result;
}

int GetMAPMESSAGE_ID_AND_TYPEParams(LONG packetHandle, WORD tableKey, struct MAPMESSAGE_ID_AND_TYPE value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 18:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "mapData");
      GetMAPMapDataParams(packetHandle, value.mapData, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetMAPMESSAGE_ID_AND_TYPEParams(LONG packetHandle, WORD tableKey, struct MAPMESSAGE_ID_AND_TYPE value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 18:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "mapData");
      SetMAPMapDataParams(packetHandle, value.mapData, newPath);
      result = CheckLastError("MAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int API_GetMAPParams(LONG packetHandle, struct MAP value)
{
  int result;
  result = 0;

  value.messageId = C2xGetTokenInt(packetHandle, "MAP", "messageId");
  result = CheckLastError("MAP", gkFuncRefGet, result);

  GetMAPMESSAGE_ID_AND_TYPEParams(packetHandle, value.messageId, value.value, "value");
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

int API_SetMAPParams(LONG packetHandle, struct MAP value)
{
  int result;
  result = 0;

  value.messageId = 18;

  SetMAPMESSAGE_ID_AND_TYPEParams(packetHandle, value.messageId, value.value, "value");
  result = CheckLastError("MAP", gkFuncRefGet, result);

  return result;
}

