/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct IntersectionCollision payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitIntersectionCollisionPacket();
//  if (packetHandle!=0) {
//    if (API_SetIntersectionCollisionParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    struct IntersectionCollisionTemporaryID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[5];
        INT  stringLength;
    };
    
    struct IntersectionCollisionPositionalAccuracy {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE semiMajor;  // INTEGER, 0..255;
        BYTE semiMinor;  // INTEGER, 0..255;
        WORD orientation;  // INTEGER, 0..65535;
    };
    
    struct IntersectionCollisionAccelerationSet4Way {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT lon;  // INTEGER, -2000..2001;
        INT lat;  // INTEGER, -2000..2001;
        INT vert;  // INTEGER, -127..127;
        INT yaw;  // INTEGER, -32767..32767;
    };
    
    struct IntersectionCollisionBrakeAppliedStatus {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[6];
        INT  stringLength;
    };
    
    struct IntersectionCollisionBrakeSystemStatus {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct IntersectionCollisionBrakeAppliedStatus wheelBrakes;  // BITSTRING;
        INT traction;  // ENUMERATED, unavailable(0), off(1), on(2), engaged(3);
        INT antiLockBrakes;  // ENUMERATED, unavailable(0), off(1), on(2), engaged(3);
        INT scs;  // ENUMERATED, unavailable(0), off(1), on(2), engaged(3);
        INT brakeBoost;  // ENUMERATED, unavailable(0), off(1), on(2);
        INT auxBrakes;  // ENUMERATED, unavailable(0), off(1), on(2), reserved(3);
    };
    
    struct IntersectionCollisionVehicleSize {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD width;  // INTEGER, 0..1023;
        WORD length;  // INTEGER, 0..4095;
    };
    
    struct IntersectionCollisionBSMcoreData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE msgCnt;  // INTEGER, 0..127;
        struct IntersectionCollisionTemporaryID id;  // OCTETSTRING;
        WORD secMark;  // INTEGER, 0..65535;
        LONG lat;  // INTEGER, -900000000..900000001;
        LONG lon;  // INTEGER, -1799999999..1800000001;
        LONG elev;  // INTEGER, -4096..61439;
        struct IntersectionCollisionPositionalAccuracy accuracy;  // SEQUENCE;
        INT transmission;  // ENUMERATED, neutral(0), park(1), forwardGears(2), reverseGears(3), reserved1(4), reserved2(5), reserved3(6), unavailable(7);
        WORD speed;  // INTEGER, 0..8191;
        WORD heading;  // INTEGER, 0..28800;
        INT angle;  // INTEGER, -126..127;
        struct IntersectionCollisionAccelerationSet4Way accelSet;  // SEQUENCE;
        struct IntersectionCollisionBrakeSystemStatus brakes;  // SEQUENCE;
        struct IntersectionCollisionVehicleSize size;  // SEQUENCE;
    };
    
    struct IntersectionCollisionDDateTime {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN year;  // INTEGER, OPTIONAL, 0..4095;
        struct OPT_BYTE_ASN month;  // INTEGER, OPTIONAL, 0..12;
        struct OPT_BYTE_ASN day;  // INTEGER, OPTIONAL, 0..31;
        struct OPT_BYTE_ASN hour;  // INTEGER, OPTIONAL, 0..31;
        struct OPT_BYTE_ASN minute;  // INTEGER, OPTIONAL, 0..60;
        struct OPT_WORD_ASN second;  // INTEGER, OPTIONAL, 0..65535;
        struct OPT_INT_ASN offset;  // INTEGER, OPTIONAL, -840..840;
    };
    
    struct IntersectionCollisionTransmissionAndSpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT transmisson;  // ENUMERATED, neutral(0), park(1), forwardGears(2), reverseGears(3), reserved1(4), reserved2(5), reserved3(6), unavailable(7);
        WORD speed;  // INTEGER, 0..8191;
    };
    
    struct IntersectionCollisionPositionConfidenceSet {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT pos;  // ENUMERATED, unavailable(0), a500m(1), a200m(2), a100m(3), a50m(4), a20m(5), a10m(6), a5m(7), a2m(8), a1m(9), a50cm(10), a20cm(11), a10cm(12), a5cm(13), a2cm(14), a1cm(15);
        INT elevation;  // ENUMERATED, unavailable(0), elev_500_00(1), elev_200_00(2), elev_100_00(3), elev_050_00(4), elev_020_00(5), elev_010_00(6), elev_005_00(7), elev_002_00(8), elev_001_00(9), elev_000_50(10), elev_000_20(11), elev_000_10(12), elev_000_05(13), elev_000_02(14), elev_000_01(15);
    };
    
    struct IntersectionCollisionSpeedandHeadingandThrottleConfidence {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT heading;  // ENUMERATED, unavailable(0), prec10deg(1), prec05deg(2), prec01deg(3), prec0_1deg(4), prec0_05deg(5), prec0_01deg(6), prec0_0125deg(7);
        INT speed;  // ENUMERATED, unavailable(0), prec100ms(1), prec10ms(2), prec5ms(3), prec1ms(4), prec0_1ms(5), prec0_05ms(6), prec0_01ms(7);
        INT throttle;  // ENUMERATED, unavailable(0), prec10percent(1), prec1percent(2), prec0_5percent(3);
    };
    
    struct IntersectionCollisionFullPositionVector {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct IntersectionCollisionDDateTime utcTime;  // SEQUENCE, OPTIONAL;
        LONG lon;  // INTEGER, -1799999999..1800000001;
        LONG lat;  // INTEGER, -900000000..900000001;
        struct OPT_LONG_ASN elevation;  // INTEGER, OPTIONAL, -4096..61439;
        struct OPT_WORD_ASN heading;  // INTEGER, OPTIONAL, 0..28800;
        struct IntersectionCollisionTransmissionAndSpeed speed;  // SEQUENCE, OPTIONAL;
        struct IntersectionCollisionPositionalAccuracy posAccuracy;  // SEQUENCE, OPTIONAL;
        struct OPT_ENUM_ASN timeConfidence;  // ENUMERATED, OPTIONAL, unavailable(0), time_100_000(1), time_050_000(2), time_020_000(3), time_010_000(4), time_002_000(5), time_001_000(6), time_000_500(7), time_000_200(8), time_000_100(9), time_000_050(10), time_000_020(11), time_000_010(12), time_000_005(13), time_000_002(14), time_000_001(15), time_000_000_5(16), time_000_000_2(17), time_000_000_1(18), time_000_000_05(19), time_000_000_02(20), time_000_000_01(21), time_000_000_005(22), time_000_000_002(23), time_000_000_001(24), time_000_000_000_5(25), time_000_000_000_2(26), time_000_000_000_1(27), time_000_000_000_05(28), time_000_000_000_02(29), time_000_000_000_01(30), time_000_000_000_005(31), time_000_000_000_002(32), time_000_000_000_001(33), time_000_000_000_000_5(34), time_000_000_000_000_2(35), time_000_000_000_000_1(36), time_000_000_000_000_05(37), time_000_000_000_000_02(38), time_000_000_000_000_01(39);
        struct IntersectionCollisionPositionConfidenceSet posConfidence;  // SEQUENCE, OPTIONAL;
        struct IntersectionCollisionSpeedandHeadingandThrottleConfidence speedConfidence;  // SEQUENCE, OPTIONAL;
    };
    
    struct IntersectionCollisionGNSSstatus {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[9];
        INT  stringLength;
    };
    
    struct IntersectionCollisionPathHistoryPoint {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG lonOffset;  // INTEGER, -131072..131071;
        INT elevationOffset;  // INTEGER, -2048..2047;
        WORD timeOffset;  // INTEGER, 1..65535;
        struct OPT_WORD_ASN speed;  // INTEGER, OPTIONAL, 0..8191;
        struct IntersectionCollisionPositionalAccuracy posAccuracy;  // SEQUENCE, OPTIONAL;
        struct OPT_BYTE_ASN heading;  // INTEGER, OPTIONAL, 0..240;
    };
    
    struct IntersectionCollisionPathHistoryPointList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollisionPathHistoryPoint arrayValue[23];  // SEQUENCE;
    };
    
    struct IntersectionCollisionPathHistory {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct IntersectionCollisionFullPositionVector initialPosition;  // SEQUENCE, OPTIONAL;
        struct IntersectionCollisionGNSSstatus currGNSSstatus;  // BITSTRING, OPTIONAL;
        struct IntersectionCollisionPathHistoryPointList crumbData;  // SEQUENCEOF;
    };
    
    struct IntersectionCollisionPathPrediction {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT radiusOfCurve;  // INTEGER, -32767..32767;
        BYTE confidence;  // INTEGER, 0..200;
    };
    
    struct IntersectionCollisionIntersectionReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct IntersectionCollisionApproachOrLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        BYTE approach;  // INTEGER, 0..15;
        BYTE lane;  // INTEGER, 0..255;
    };
    
    struct IntersectionCollisionVehicleEventFlags {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[14];
        INT  stringLength;
    };
    
    struct IntersectionCollisionREG_EXT_ID_AND_TYPE_Empty {
    };
    
    struct IntersectionCollisionRegionalExtensionIntersectionCollision {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct IntersectionCollisionREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct IntersectionCollision_IntersectionCollision_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollisionRegionalExtensionIntersectionCollision arrayValue[4];  // SEQUENCE;
    };
    
    struct IntersectionCollisionIC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE msgCnt;  // INTEGER, 0..127;
        struct IntersectionCollisionTemporaryID id;  // OCTETSTRING;
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        struct IntersectionCollisionBSMcoreData partOne;  // SEQUENCE, OPTIONAL;
        struct IntersectionCollisionPathHistory path;  // SEQUENCE, OPTIONAL;
        struct IntersectionCollisionPathPrediction pathPrediction;  // SEQUENCE, OPTIONAL;
        struct IntersectionCollisionIntersectionReferenceID intersectionID;  // SEQUENCE;
        struct IntersectionCollisionApproachOrLane laneNumber;  // CHOICE;
        struct IntersectionCollisionVehicleEventFlags eventFlag;  // BITSTRING;
        struct IntersectionCollision_IntersectionCollision_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct IntersectionCollisionMESSAGE_ID_AND_TYPE {
        struct IntersectionCollisionIC intersectionCollision;  // SEQUENCE;
    };
    
    struct IntersectionCollision {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD messageId;  // INTEGER, 0..32767, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollision_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData(18), signalPhaseAndTimingMessage(19), basicSafetyMessage(20), commonSafetyRequest(21), emergencyVehicleAlert(22), intersectionCollision(23), nmeaCorrections(24), probeDataManagement(25), probeVehicleData(26), roadSideAlert(27), rtcmCorrections(28), signalRequestMessage(29), signalStatusMessage(30), travelerInformation(31), personalSafetyMessage(32), testMessage00(240), testMessage01(241), testMessage02(242), testMessage03(243), testMessage04(244), testMessage05(245), testMessage06(246), testMessage07(247), testMessage08(248), testMessage09(249), testMessage10(250), testMessage11(251), testMessage12(252), testMessage13(253), testMessage14(254), testMessage15(255);
        struct IntersectionCollisionMESSAGE_ID_AND_TYPE value;  // TABLE;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitIntersectionCollisionPacket()
{
  return C2xInitPacket("IntersectionCollision"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitIntersectionCollisionPacket(struct IntersectionCollision msgStruct)
{
  long pktHandle;

  pktHandle = API_InitIntersectionCollisionPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetIntersectionCollisionParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitIntersectionCollisionPacket(struct IntersectionCollision msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("IntersectionCollision", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetIntersectionCollisionParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetIntersectionCollisionPositionalAccuracyParams(LONG packetHandle, struct IntersectionCollisionPositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajor");
  value.semiMajor = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMinor");
  value.semiMinor = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "orientation");
  value.orientation = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionPositionalAccuracyParams(LONG packetHandle, struct IntersectionCollisionPositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMajor");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.semiMajor);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "semiMinor");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.semiMinor);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "orientation");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.orientation);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionAccelerationSet4WayParams(LONG packetHandle, struct IntersectionCollisionAccelerationSet4Way value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vert");
  value.vert = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "yaw");
  value.yaw = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionAccelerationSet4WayParams(LONG packetHandle, struct IntersectionCollisionAccelerationSet4Way value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lon);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lat);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vert");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.vert);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "yaw");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.yaw);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionBrakeSystemStatusParams(LONG packetHandle, struct IntersectionCollisionBrakeSystemStatus value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wheelBrakes");
  value.wheelBrakes.isValidFlag = 1;
  value.wheelBrakes.stringLength = C2xGetTokenLengthBit(packetHandle, "IntersectionCollision", newPath);
  if ((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    if(value.wheelBrakes.stringLength > 0)
    {
      for(j=0; j<value.wheelBrakes.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j) == 0)
        {
          value.wheelBrakes.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j) == 1)
        {
          value.wheelBrakes.string[j] = '1';
        }

        if(value.wheelBrakes.stringLength == 1)
        {
          value.wheelBrakes.string[1] = '0';
        }
        result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.wheelBrakes.stringLength+1; k > -1; k--)
      {
        if(value.wheelBrakes.string[k] == '1')
        {
          value.wheelBrakes.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "traction");
  value.traction = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "antiLockBrakes");
  value.antiLockBrakes = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scs");
  value.scs = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "brakeBoost");
  value.brakeBoost = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "auxBrakes");
  value.auxBrakes = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionBrakeSystemStatusParams(LONG packetHandle, struct IntersectionCollisionBrakeSystemStatus value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "wheelBrakes");
    for(j=0; j<value.wheelBrakes.stringLength; j++)
    {
      if(value.wheelBrakes.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j, 1);
      }
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "traction");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.traction);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "antiLockBrakes");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.antiLockBrakes);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scs");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.scs);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "brakeBoost");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.brakeBoost);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "auxBrakes");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.auxBrakes);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionVehicleSizeParams(LONG packetHandle, struct IntersectionCollisionVehicleSize value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "width");
  value.width = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "length");
  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionVehicleSizeParams(LONG packetHandle, struct IntersectionCollisionVehicleSize value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "width");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.width);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "length");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.length);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionBSMcoreDataParams(LONG packetHandle, struct IntersectionCollisionBSMcoreData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCnt");
  value.msgCnt = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.id.string), value.id.string);
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "secMark");
  value.secMark = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elev");
  value.elev = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  GetIntersectionCollisionPositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmission");
  value.transmission = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  value.heading = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "angle");
  value.angle = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accelSet");
  GetIntersectionCollisionAccelerationSet4WayParams(packetHandle, value.accelSet, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "brakes");
  GetIntersectionCollisionBrakeSystemStatusParams(packetHandle, value.brakes, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "size");
  GetIntersectionCollisionVehicleSizeParams(packetHandle, value.size, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionBSMcoreDataParams(LONG packetHandle, struct IntersectionCollisionBSMcoreData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCnt");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.msgCnt);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  if(value.id.stringLength == 0)
  {
    value.id.stringLength = 4;
    memcpy(value.id.string, "0000", value.id.stringLength);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.id.stringLength, value.id.string);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "secMark");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.secMark);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lat);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lon);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elev");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elev);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  SetIntersectionCollisionPositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmission");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.transmission);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.speed);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.heading);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "angle");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.angle);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accelSet");
  SetIntersectionCollisionAccelerationSet4WayParams(packetHandle, value.accelSet, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "brakes");
  SetIntersectionCollisionBrakeSystemStatusParams(packetHandle, value.brakes, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "size");
  SetIntersectionCollisionVehicleSizeParams(packetHandle, value.size, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionDDateTimeParams(LONG packetHandle, struct IntersectionCollisionDDateTime value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "year");
  value.year.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.year.isValidFlag==1)
  {
    value.year.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "month");
  value.month.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.month.isValidFlag==1)
  {
    value.month.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "day");
  value.day.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.day.isValidFlag==1)
  {
    value.day.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hour");
  value.hour.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.hour.isValidFlag==1)
  {
    value.hour.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minute");
  value.minute.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.minute.isValidFlag==1)
  {
    value.minute.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  value.second.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.second.isValidFlag==1)
  {
    value.second.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset");
  value.offset.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.offset.isValidFlag==1)
  {
    value.offset.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int SetIntersectionCollisionDDateTimeParams(LONG packetHandle, struct IntersectionCollisionDDateTime value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "year");
  if(value.year.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.year.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "month");
  if(value.month.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.month.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "day");
  if(value.day.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.day.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hour");
  if(value.hour.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.hour.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minute");
  if(value.minute.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.minute.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  if(value.second.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.second.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offset");
  if(value.offset.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.offset.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  return result;
}

int GetIntersectionCollisionTransmissionAndSpeedParams(LONG packetHandle, struct IntersectionCollisionTransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmisson");
  value.transmisson = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionTransmissionAndSpeedParams(LONG packetHandle, struct IntersectionCollisionTransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmisson");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.transmisson);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.speed);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionPositionConfidenceSetParams(LONG packetHandle, struct IntersectionCollisionPositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pos");
  value.pos = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionPositionConfidenceSetParams(LONG packetHandle, struct IntersectionCollisionPositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pos");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.pos);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevation);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionSpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct IntersectionCollisionSpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  value.heading = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "throttle");
  value.throttle = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionSpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct IntersectionCollisionSpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.heading);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.speed);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "throttle");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.throttle);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionFullPositionVectorParams(LONG packetHandle, struct IntersectionCollisionFullPositionVector value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "utcTime");
  value.utcTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.utcTime.isValidFlag==1)
  {
    GetIntersectionCollisionDDateTimeParams(packetHandle, value.utcTime, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.elevation.isValidFlag==1)
  {
    value.elevation.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  value.heading.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.heading.isValidFlag==1)
  {
    value.heading.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.speed.isValidFlag==1)
  {
    GetIntersectionCollisionTransmissionAndSpeedParams(packetHandle, value.speed, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  value.posAccuracy.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.posAccuracy.isValidFlag==1)
  {
    GetIntersectionCollisionPositionalAccuracyParams(packetHandle, value.posAccuracy, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeConfidence");
  value.timeConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.timeConfidence.isValidFlag==1)
  {
    value.timeConfidence.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posConfidence");
  value.posConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.posConfidence.isValidFlag==1)
  {
    GetIntersectionCollisionPositionConfidenceSetParams(packetHandle, value.posConfidence, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  value.speedConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.speedConfidence.isValidFlag==1)
  {
    GetIntersectionCollisionSpeedandHeadingandThrottleConfidenceParams(packetHandle, value.speedConfidence, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int SetIntersectionCollisionFullPositionVectorParams(LONG packetHandle, struct IntersectionCollisionFullPositionVector value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "utcTime");
  if(value.utcTime.isValidFlag==1)
  {
    SetIntersectionCollisionDDateTimeParams(packetHandle, value.utcTime, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lon);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lat);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  if(value.elevation.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevation.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  if(value.heading.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.heading.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  if(value.speed.isValidFlag==1)
  {
    SetIntersectionCollisionTransmissionAndSpeedParams(packetHandle, value.speed, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  if(value.posAccuracy.isValidFlag==1)
  {
    SetIntersectionCollisionPositionalAccuracyParams(packetHandle, value.posAccuracy, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeConfidence");
  if(value.timeConfidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeConfidence.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posConfidence");
  if(value.posConfidence.isValidFlag==1)
  {
    SetIntersectionCollisionPositionConfidenceSetParams(packetHandle, value.posConfidence, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  if(value.speedConfidence.isValidFlag==1)
  {
    SetIntersectionCollisionSpeedandHeadingandThrottleConfidenceParams(packetHandle, value.speedConfidence, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  return result;
}

int GetIntersectionCollisionPathHistoryPointParams(LONG packetHandle, struct IntersectionCollisionPathHistoryPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lonOffset");
  value.lonOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  value.elevationOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  value.timeOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.speed.isValidFlag==1)
  {
    value.speed.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  value.posAccuracy.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.posAccuracy.isValidFlag==1)
  {
    GetIntersectionCollisionPositionalAccuracyParams(packetHandle, value.posAccuracy, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  value.heading.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.heading.isValidFlag==1)
  {
    value.heading.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int SetIntersectionCollisionPathHistoryPointParams(LONG packetHandle, struct IntersectionCollisionPathHistoryPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lonOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lonOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevationOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  if(value.speed.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.speed.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  if(value.posAccuracy.isValidFlag==1)
  {
    SetIntersectionCollisionPositionalAccuracyParams(packetHandle, value.posAccuracy, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  if(value.heading.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.heading.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  return result;
}

int GetIntersectionCollisionPathHistoryPointListParams(LONG packetHandle, struct IntersectionCollisionPathHistoryPointList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollisionPathHistoryPointParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollisionPathHistoryPointListParams(LONG packetHandle, struct IntersectionCollisionPathHistoryPointList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollisionPathHistoryPointParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollisionPathHistoryParams(LONG packetHandle, struct IntersectionCollisionPathHistory value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "initialPosition");
  value.initialPosition.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.initialPosition.isValidFlag==1)
  {
    GetIntersectionCollisionFullPositionVectorParams(packetHandle, value.initialPosition, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "currGNSSstatus");
  value.currGNSSstatus.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.currGNSSstatus.isValidFlag==1)
  {
    value.currGNSSstatus.isValidFlag = 1;
    value.currGNSSstatus.stringLength = C2xGetTokenLengthBit(packetHandle, "IntersectionCollision", newPath);
    if ((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
    {
      if(value.currGNSSstatus.stringLength > 0)
      {
        for(j=0; j<value.currGNSSstatus.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j) == 0)
          {
            value.currGNSSstatus.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j) == 1)
          {
            value.currGNSSstatus.string[j] = '1';
          }

          if(value.currGNSSstatus.stringLength == 1)
          {
            value.currGNSSstatus.string[1] = '0';
          }
          result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.currGNSSstatus.stringLength+1; k > -1; k--)
        {
          if(value.currGNSSstatus.string[k] == '1')
          {
            value.currGNSSstatus.string[k] = '0';
          }
        }
      }
    }

  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crumbData");
  GetIntersectionCollisionPathHistoryPointListParams(packetHandle, value.crumbData, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionPathHistoryParams(LONG packetHandle, struct IntersectionCollisionPathHistory value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "initialPosition");
  if(value.initialPosition.isValidFlag==1)
  {
    SetIntersectionCollisionFullPositionVectorParams(packetHandle, value.initialPosition, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "currGNSSstatus");
  if(value.currGNSSstatus.isValidFlag==1)
  {
      for(j=0; j<value.currGNSSstatus.stringLength; j++)
      {
        if(value.currGNSSstatus.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j, 1);
        }
        result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crumbData");
  SetIntersectionCollisionPathHistoryPointListParams(packetHandle, value.crumbData, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionPathPredictionParams(LONG packetHandle, struct IntersectionCollisionPathPrediction value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "radiusOfCurve");
  value.radiusOfCurve = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionPathPredictionParams(LONG packetHandle, struct IntersectionCollisionPathPrediction value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "radiusOfCurve");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.radiusOfCurve);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.confidence);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionIntersectionReferenceIDParams(LONG packetHandle, struct IntersectionCollisionIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionIntersectionReferenceIDParams(LONG packetHandle, struct IntersectionCollisionIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.region.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.id);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionApproachOrLaneParams(LONG packetHandle, struct IntersectionCollisionApproachOrLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "approach");
      value.approach = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
      value.lane = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetIntersectionCollisionApproachOrLaneParams(LONG packetHandle, struct IntersectionCollisionApproachOrLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "approach");
      C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.approach);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
      C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lane);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetIntersectionCollisionRegionalExtensionIntersectionCollisionParams(LONG packetHandle, struct IntersectionCollisionRegionalExtensionIntersectionCollision value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionRegionalExtensionIntersectionCollisionParams(LONG packetHandle, struct IntersectionCollisionRegionalExtensionIntersectionCollision value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetIntersectionCollision_IntersectionCollision_regionalParams(LONG packetHandle, struct IntersectionCollision_IntersectionCollision_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollisionRegionalExtensionIntersectionCollisionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_IntersectionCollision_regionalParams(LONG packetHandle, struct IntersectionCollision_IntersectionCollision_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollisionRegionalExtensionIntersectionCollisionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollisionICParams(LONG packetHandle, struct IntersectionCollisionIC value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCnt");
  value.msgCnt = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.id.string), value.id.string);
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "partOne");
  value.partOne.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.partOne.isValidFlag==1)
  {
    GetIntersectionCollisionBSMcoreDataParams(packetHandle, value.partOne, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "path");
  value.path.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.path.isValidFlag==1)
  {
    GetIntersectionCollisionPathHistoryParams(packetHandle, value.path, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathPrediction");
  value.pathPrediction.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.pathPrediction.isValidFlag==1)
  {
    GetIntersectionCollisionPathPredictionParams(packetHandle, value.pathPrediction, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersectionID");
  GetIntersectionCollisionIntersectionReferenceIDParams(packetHandle, value.intersectionID, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneNumber");
  GetIntersectionCollisionApproachOrLaneParams(packetHandle, value.laneNumber, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventFlag");
  value.eventFlag.isValidFlag = 1;
  value.eventFlag.stringLength = C2xGetTokenLengthBit(packetHandle, "IntersectionCollision", newPath);
  if ((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    if(value.eventFlag.stringLength > 0)
    {
      for(j=0; j<value.eventFlag.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j) == 0)
        {
          value.eventFlag.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j) == 1)
        {
          value.eventFlag.string[j] = '1';
        }

        if(value.eventFlag.stringLength == 1)
        {
          value.eventFlag.string[1] = '0';
        }
        result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.eventFlag.stringLength+1; k > -1; k--)
      {
        if(value.eventFlag.string[k] == '1')
        {
          value.eventFlag.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetIntersectionCollision_IntersectionCollision_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int SetIntersectionCollisionICParams(LONG packetHandle, struct IntersectionCollisionIC value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCnt");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.msgCnt);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  if(value.id.stringLength == 0)
  {
    value.id.stringLength = 4;
    memcpy(value.id.string, "0000", value.id.stringLength);
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.id.stringLength, value.id.string);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeStamp.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "partOne");
  if(value.partOne.isValidFlag==1)
  {
    SetIntersectionCollisionBSMcoreDataParams(packetHandle, value.partOne, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "path");
  if(value.path.isValidFlag==1)
  {
    SetIntersectionCollisionPathHistoryParams(packetHandle, value.path, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathPrediction");
  if(value.pathPrediction.isValidFlag==1)
  {
    SetIntersectionCollisionPathPredictionParams(packetHandle, value.pathPrediction, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersectionID");
  SetIntersectionCollisionIntersectionReferenceIDParams(packetHandle, value.intersectionID, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneNumber");
  SetIntersectionCollisionApproachOrLaneParams(packetHandle, value.laneNumber, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventFlag");
    for(j=0; j<value.eventFlag.stringLength; j++)
    {
      if(value.eventFlag.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j, 1);
      }
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetIntersectionCollision_IntersectionCollision_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  return result;
}

int GetIntersectionCollisionMESSAGE_ID_AND_TYPEParams(LONG packetHandle, WORD tableKey, struct IntersectionCollisionMESSAGE_ID_AND_TYPE value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 23:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersectionCollision");
      GetIntersectionCollisionICParams(packetHandle, value.intersectionCollision, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetIntersectionCollisionMESSAGE_ID_AND_TYPEParams(LONG packetHandle, WORD tableKey, struct IntersectionCollisionMESSAGE_ID_AND_TYPE value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 23:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersectionCollision");
      SetIntersectionCollisionICParams(packetHandle, value.intersectionCollision, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int API_GetIntersectionCollisionParams(LONG packetHandle, struct IntersectionCollision value)
{
  int result;
  result = 0;

  value.messageId = C2xGetTokenInt(packetHandle, "IntersectionCollision", "messageId");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  GetIntersectionCollisionMESSAGE_ID_AND_TYPEParams(packetHandle, value.messageId, value.value, "value");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int API_SetIntersectionCollisionParams(LONG packetHandle, struct IntersectionCollision value)
{
  int result;
  result = 0;

  value.messageId = 23;

  SetIntersectionCollisionMESSAGE_ID_AND_TYPEParams(packetHandle, value.messageId, value.value, "value");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

