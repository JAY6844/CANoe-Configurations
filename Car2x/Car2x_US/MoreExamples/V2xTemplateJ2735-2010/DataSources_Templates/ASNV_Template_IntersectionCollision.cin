/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct IntersectionCollision payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitIntersectionCollisionPacket();
//  if (packetHandle!=0) {
//    if (API_SetIntersectionCollisionParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    struct IntersectionCollision_Blob_TemporaryID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        DWORD temporaryID;  // INTEGER, 0..4294967295;
    };
    
    struct IntersectionCollisionTemporaryID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[5];
        INT  stringLength;
        struct IntersectionCollision_Blob_TemporaryID _Blob_TemporaryID;  // SEQUENCE;
    };
    
    struct IntersectionCollisionDDateTime {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN year;  // INTEGER, OPTIONAL, 0..9999;
        struct OPT_BYTE_ASN month;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_BYTE_ASN day;  // INTEGER, OPTIONAL, 0..31;
        struct OPT_BYTE_ASN hour;  // INTEGER, OPTIONAL, 0..31;
        struct OPT_BYTE_ASN minute;  // INTEGER, OPTIONAL, 0..63;
        struct OPT_WORD_ASN second;  // INTEGER, OPTIONAL, 0..65535;
    };
    
    struct IntersectionCollisionElevation {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
        WORD _Blob_Elevation;  // INTEGER, 0..65535;
    };
    
    struct IntersectionCollision_Blob_TransmissionAndSpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE transmissionState;  // INTEGER, 0..7, neutral(0), park(1), forwardGears(2), reverseGears(3), reserved1(4), reserved2(5), reserved3(6), unavailable(7);
        WORD speed;  // INTEGER, 0..8191;
    };
    
    struct IntersectionCollisionTransmissionAndSpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
        struct IntersectionCollision_Blob_TransmissionAndSpeed _Blob_TransmissionAndSpeed;  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_PositionalAccuracy {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE accuracySemiMajor;  // INTEGER, 0..255;
        BYTE accuracySemiMinor;  // INTEGER, 0..255;
        WORD accuracyOrientation;  // INTEGER, 0..65535;
    };
    
    struct IntersectionCollisionPositionalAccuracy {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[5];
        INT  stringLength;
        struct IntersectionCollision_Blob_PositionalAccuracy _Blob_PositionalAccuracy;  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_PositionConfidenceSet {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE positionConfidence;  // INTEGER, 0..15, unavailable(0), a500m(1), a200m(2), a100m(3), a50m(4), a20m(5), a10m(6), a5m(7), a2m(8), a1m(9), a50cm(10), a20cm(11), a10cm(12), a5cm(13), a2cm(14), a1cm(15);
        BYTE elevationConfidence;  // INTEGER, 0..15, unavailable(0), elev_500_00(1), elev_200_00(2), elev_100_00(3), elev_050_00(4), elev_020_00(5), elev_010_00(6), elev_005_00(7), elev_002_00(8), elev_001_00(9), elev_000_50(10), elev_000_20(11), elev_000_10(12), elev_000_05(13), elev_000_02(14), elev_000_01(15);
    };
    
    struct IntersectionCollisionPositionConfidenceSet {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[2];
        INT  stringLength;
        struct IntersectionCollision_Blob_PositionConfidenceSet _Blob_PositionConfidenceSet;  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_SpeedandHeadingandThrottleConfidence {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE headingConfidence;  // INTEGER, 0..7, unavailable(0), prec45deg(1), prec10deg(2), prec05deg(3), prec01deg(4), prec0_1deg(5), prec0_05deg(6), prec0_01deg(7);
        BYTE speedConfidence;  // INTEGER, 0..7, unavailable(0), prec100ms(1), prec10ms(2), prec5ms(3), prec1ms(4), prec0_1ms(5), prec0_05ms(6), prec0_01ms(7);
        BYTE throttleConfidence;  // INTEGER, 0..3, unavailable(0), prec10percent(1), prec1percent(2), prec0_5percent(3);
    };
    
    struct IntersectionCollisionSpeedandHeadingandThrottleConfidence {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[2];
        INT  stringLength;
        struct IntersectionCollision_Blob_SpeedandHeadingandThrottleConfidence _Blob_SpeedandHeadingandThrottleConfidence;  // SEQUENCE;
    };
    
    struct IntersectionCollisionFullPositionVector {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct IntersectionCollisionDDateTime utcTime;  // SEQUENCE, OPTIONAL;
        LONG lon;  // INTEGER, -1799999999..1800000001;
        LONG lat;  // INTEGER, -900000000..900000001;
        struct IntersectionCollisionElevation elevation;  // OCTETSTRING, OPTIONAL;
        struct OPT_WORD_ASN heading;  // INTEGER, OPTIONAL, 0..28800;
        struct IntersectionCollisionTransmissionAndSpeed speed;  // OCTETSTRING, OPTIONAL;
        struct IntersectionCollisionPositionalAccuracy posAccuracy;  // OCTETSTRING, OPTIONAL;
        struct OPT_ENUM_ASN timeConfidence;  // ENUMERATED, OPTIONAL, unavailable(0), time_100_000(1), time_050_000(2), time_020_000(3), time_010_000(4), time_002_000(5), time_001_000(6), time_000_500(7), time_000_200(8), time_000_100(9), time_000_050(10), time_000_020(11), time_000_010(12), time_000_005(13), time_000_002(14), time_000_001(15), time_000_000_5(16), time_000_000_2(17), time_000_000_1(18), time_000_000_05(19), time_000_000_02(20), time_000_000_01(21), time_000_000_005(22), time_000_000_002(23), time_000_000_001(24), time_000_000_000_5(25), time_000_000_000_2(26), time_000_000_000_1(27), time_000_000_000_05(28), time_000_000_000_02(29), time_000_000_000_01(30), time_000_000_000_005(31), time_000_000_000_002(32), time_000_000_000_001(33), time_000_000_000_000_5(34), time_000_000_000_000_2(35), time_000_000_000_000_1(36), time_000_000_000_000_05(37), time_000_000_000_000_02(38), time_000_000_000_000_01(39);
        struct IntersectionCollisionPositionConfidenceSet posConfidence;  // OCTETSTRING, OPTIONAL;
        struct IntersectionCollisionSpeedandHeadingandThrottleConfidence speedConfidence;  // OCTETSTRING, OPTIONAL;
    };
    
    struct IntersectionCollisionGPSstatus {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct IntersectionCollisionPathHistoryPointType_01 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        struct OPT_INT_ASN elevationOffset;  // INTEGER, OPTIONAL, -2048..2047;
        struct OPT_WORD_ASN timeOffset;  // INTEGER, OPTIONAL, 1..65535;
        struct IntersectionCollisionPositionalAccuracy posAccuracy;  // OCTETSTRING, OPTIONAL;
        struct OPT_INT_ASN heading;  // INTEGER, OPTIONAL, -128..127;
        struct IntersectionCollisionTransmissionAndSpeed speed;  // OCTETSTRING, OPTIONAL;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_01 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollisionPathHistoryPointType_01 arrayValue[23];  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_02 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        INT elevationOffset;  // INTEGER, -2048..2047;
        WORD timeOffset;  // INTEGER, 0..65535;
        struct IntersectionCollision_Blob_PositionalAccuracy accuracy;  // SEQUENCE;
        INT heading;  // INTEGER, -128..127;
        struct IntersectionCollision_Blob_TransmissionAndSpeed speed;  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_02 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_02 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_02 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[346];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_02 _Blob_PathHistory_crumbData_pathHistoryPointSets_02;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_03 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        INT elevationOffset;  // INTEGER, -2048..2047;
        WORD timeOffset;  // INTEGER, 0..65535;
        struct IntersectionCollision_Blob_PositionalAccuracy accuracy;  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_03 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_03 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_03 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[277];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_03 _Blob_PathHistory_crumbData_pathHistoryPointSets_03;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_04 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        INT elevationOffset;  // INTEGER, -2048..2047;
        WORD timeOffset;  // INTEGER, 0..65535;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_04 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_04 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_04 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[185];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_04 _Blob_PathHistory_crumbData_pathHistoryPointSets_04;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_05 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        INT elevationOffset;  // INTEGER, -2048..2047;
        struct IntersectionCollision_Blob_PositionalAccuracy accuracy;  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_05 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_05 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_05 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[231];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_05 _Blob_PathHistory_crumbData_pathHistoryPointSets_05;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_06 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        INT elevationOffset;  // INTEGER, -2048..2047;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_06 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_06 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_06 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[139];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_06 _Blob_PathHistory_crumbData_pathHistoryPointSets_06;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_07 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        WORD timeOffset;  // INTEGER, 0..65535;
        struct IntersectionCollision_Blob_PositionalAccuracy accuracy;  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_07 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_07 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_07 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[243];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_07 _Blob_PathHistory_crumbData_pathHistoryPointSets_07;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_08 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        WORD timeOffset;  // INTEGER, 0..65535;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_08 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_08 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_08 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[162];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_08 _Blob_PathHistory_crumbData_pathHistoryPointSets_08;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_09 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
        struct IntersectionCollision_Blob_PositionalAccuracy accuracy;  // SEQUENCE;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_09 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_09 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_09 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[197];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_09 _Blob_PathHistory_crumbData_pathHistoryPointSets_09;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_Blob_PathHistoryPointType_10 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG latOffset;  // INTEGER, -131072..131071;
        LONG longOffset;  // INTEGER, -131072..131071;
    };
    
    struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_10 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct IntersectionCollision_Blob_PathHistoryPointType_10 arrayValue[32];  // SEQUENCE;
    };
    
    struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_10 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[105];
        INT  stringLength;
        struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_10 _Blob_PathHistory_crumbData_pathHistoryPointSets_10;  // SEQUENCEOF;
    };
    
    struct IntersectionCollision_PathHistory_crumbData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_01 pathHistoryPointSets_01;  // SEQUENCEOF;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_02 pathHistoryPointSets_02;  // OCTETSTRING;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_03 pathHistoryPointSets_03;  // OCTETSTRING;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_04 pathHistoryPointSets_04;  // OCTETSTRING;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_05 pathHistoryPointSets_05;  // OCTETSTRING;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_06 pathHistoryPointSets_06;  // OCTETSTRING;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_07 pathHistoryPointSets_07;  // OCTETSTRING;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_08 pathHistoryPointSets_08;  // OCTETSTRING;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_09 pathHistoryPointSets_09;  // OCTETSTRING;
        struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_10 pathHistoryPointSets_10;  // OCTETSTRING;
    };
    
    struct IntersectionCollisionPathHistory {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct IntersectionCollisionFullPositionVector initialPosition;  // SEQUENCE, OPTIONAL;
        struct IntersectionCollisionGPSstatus currGPSstatus;  // BITSTRING, OPTIONAL;
        struct OPT_BYTE_ASN itemCnt;  // INTEGER, OPTIONAL, 0..32;
        struct IntersectionCollision_PathHistory_crumbData crumbData;  // CHOICE;
    };
    
    struct IntersectionCollision_Blob_LaneNumber {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE laneNumber;  // INTEGER, 0..255;
    };
    
    struct IntersectionCollisionLaneNumber {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[2];
        INT  stringLength;
        struct IntersectionCollision_Blob_LaneNumber _Blob_LaneNumber;  // SEQUENCE;
    };
    
    struct IntersectionCollision {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT msgID;  // ENUMERATED, reserved(0), alaCarteMessage(1), basicSafetyMessage(2), basicSafetyMessageVerbose(3), commonSafetyRequest(4), emergencyVehicleAlert(5), intersectionCollisionAlert(6), mapData(7), nmeaCorrections(8), probeDataManagement(9), probeVehicleData(10), roadSideAlert(11), rtcmCorrections(12), signalPhaseAndTimingMessage(13), signalRequestMessage(14), signalStatusMessage(15), travelerInformation(16);
        BYTE msgCnt;  // INTEGER, 0..127;
        struct IntersectionCollisionTemporaryID id;  // OCTETSTRING;
        struct OPT_WORD_ASN secMark;  // INTEGER, OPTIONAL, 0..65535;
        struct IntersectionCollisionPathHistory path;  // SEQUENCE;
        WORD intersetionID;  // INTEGER, 0..65535;
        struct IntersectionCollisionLaneNumber laneNumber;  // OCTETSTRING;
        WORD eventFlag;  // INTEGER, 0..8192, eventHazardLights(1), eventStopLineViolation(2), eventABSactivated(4), eventTractionControlLoss(8), eventStabilityControlactivated(16), eventHazardousMaterials(32), eventEmergencyResponse(64), eventHardBraking(128), eventLightsChanged(256), eventWipersChanged(512), eventFlatTire(1024), eventDisabledVehicle(2048), eventAirBagDeployment(4096);
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitIntersectionCollisionPacket()
{
  return C2xInitPacket("IntersectionCollision"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitIntersectionCollisionPacket(struct IntersectionCollision msgStruct)
{
  long pktHandle;

  pktHandle = API_InitIntersectionCollisionPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetIntersectionCollisionParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitIntersectionCollisionPacket(struct IntersectionCollision msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("IntersectionCollision", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetIntersectionCollisionParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetIntersectionCollision_Blob_TemporaryIDParams(LONG packetHandle, struct IntersectionCollision_Blob_TemporaryID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "temporaryID");
  value.temporaryID = C2xGetTokenInt64(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_TemporaryIDParams(LONG packetHandle, struct IntersectionCollision_Blob_TemporaryID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "temporaryID");
  C2xSetTokenInt64(packetHandle, "IntersectionCollision", newPath, value.temporaryID);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionTemporaryIDParams(LONG packetHandle, struct IntersectionCollisionTemporaryID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_TemporaryID");
  GetIntersectionCollision_Blob_TemporaryIDParams(packetHandle, value._Blob_TemporaryID, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionTemporaryIDParams(LONG packetHandle, struct IntersectionCollisionTemporaryID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_TemporaryID");
  SetIntersectionCollision_Blob_TemporaryIDParams(packetHandle, value._Blob_TemporaryID, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionDDateTimeParams(LONG packetHandle, struct IntersectionCollisionDDateTime value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "year");
  value.year.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.year.isValidFlag==1)
  {
    value.year.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "month");
  value.month.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.month.isValidFlag==1)
  {
    value.month.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "day");
  value.day.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.day.isValidFlag==1)
  {
    value.day.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hour");
  value.hour.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.hour.isValidFlag==1)
  {
    value.hour.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minute");
  value.minute.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.minute.isValidFlag==1)
  {
    value.minute.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  value.second.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.second.isValidFlag==1)
  {
    value.second.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int SetIntersectionCollisionDDateTimeParams(LONG packetHandle, struct IntersectionCollisionDDateTime value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "year");
  if(value.year.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.year.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "month");
  if(value.month.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.month.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "day");
  if(value.day.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.day.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hour");
  if(value.hour.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.hour.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minute");
  if(value.minute.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.minute.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  if(value.second.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.second.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  return result;
}

int GetIntersectionCollisionElevationParams(LONG packetHandle, struct IntersectionCollisionElevation value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_Elevation");
  value._Blob_Elevation = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionElevationParams(LONG packetHandle, struct IntersectionCollisionElevation value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_Elevation");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value._Blob_Elevation);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_TransmissionAndSpeedParams(LONG packetHandle, struct IntersectionCollision_Blob_TransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmissionState");
  value.transmissionState = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_TransmissionAndSpeedParams(LONG packetHandle, struct IntersectionCollision_Blob_TransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmissionState");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.transmissionState);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.speed);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionTransmissionAndSpeedParams(LONG packetHandle, struct IntersectionCollisionTransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_TransmissionAndSpeed");
  GetIntersectionCollision_Blob_TransmissionAndSpeedParams(packetHandle, value._Blob_TransmissionAndSpeed, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionTransmissionAndSpeedParams(LONG packetHandle, struct IntersectionCollisionTransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_TransmissionAndSpeed");
  SetIntersectionCollision_Blob_TransmissionAndSpeedParams(packetHandle, value._Blob_TransmissionAndSpeed, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PositionalAccuracyParams(LONG packetHandle, struct IntersectionCollision_Blob_PositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracySemiMajor");
  value.accuracySemiMajor = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracySemiMinor");
  value.accuracySemiMinor = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracyOrientation");
  value.accuracyOrientation = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PositionalAccuracyParams(LONG packetHandle, struct IntersectionCollision_Blob_PositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracySemiMajor");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.accuracySemiMajor);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracySemiMinor");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.accuracySemiMinor);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracyOrientation");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.accuracyOrientation);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionPositionalAccuracyParams(LONG packetHandle, struct IntersectionCollisionPositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PositionalAccuracy");
  GetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value._Blob_PositionalAccuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionPositionalAccuracyParams(LONG packetHandle, struct IntersectionCollisionPositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PositionalAccuracy");
  SetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value._Blob_PositionalAccuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PositionConfidenceSetParams(LONG packetHandle, struct IntersectionCollision_Blob_PositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionConfidence");
  value.positionConfidence = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationConfidence");
  value.elevationConfidence = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PositionConfidenceSetParams(LONG packetHandle, struct IntersectionCollision_Blob_PositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionConfidence");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.positionConfidence);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationConfidence");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevationConfidence);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionPositionConfidenceSetParams(LONG packetHandle, struct IntersectionCollisionPositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PositionConfidenceSet");
  GetIntersectionCollision_Blob_PositionConfidenceSetParams(packetHandle, value._Blob_PositionConfidenceSet, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionPositionConfidenceSetParams(LONG packetHandle, struct IntersectionCollisionPositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PositionConfidenceSet");
  SetIntersectionCollision_Blob_PositionConfidenceSetParams(packetHandle, value._Blob_PositionConfidenceSet, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_SpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct IntersectionCollision_Blob_SpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "headingConfidence");
  value.headingConfidence = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  value.speedConfidence = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "throttleConfidence");
  value.throttleConfidence = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_SpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct IntersectionCollision_Blob_SpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "headingConfidence");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.headingConfidence);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.speedConfidence);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "throttleConfidence");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.throttleConfidence);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionSpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct IntersectionCollisionSpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_SpeedandHeadingandThrottleConfidence");
  GetIntersectionCollision_Blob_SpeedandHeadingandThrottleConfidenceParams(packetHandle, value._Blob_SpeedandHeadingandThrottleConfidence, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionSpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct IntersectionCollisionSpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_SpeedandHeadingandThrottleConfidence");
  SetIntersectionCollision_Blob_SpeedandHeadingandThrottleConfidenceParams(packetHandle, value._Blob_SpeedandHeadingandThrottleConfidence, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionFullPositionVectorParams(LONG packetHandle, struct IntersectionCollisionFullPositionVector value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "utcTime");
  value.utcTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.utcTime.isValidFlag==1)
  {
    GetIntersectionCollisionDDateTimeParams(packetHandle, value.utcTime, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.elevation.isValidFlag==1)
  {
    value.elevation.isValidFlag = 1;
    value.elevation.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.elevation.string), value.elevation.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  value.heading.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.heading.isValidFlag==1)
  {
    value.heading.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.speed.isValidFlag==1)
  {
    value.speed.isValidFlag = 1;
    value.speed.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.speed.string), value.speed.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  value.posAccuracy.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.posAccuracy.isValidFlag==1)
  {
    value.posAccuracy.isValidFlag = 1;
    value.posAccuracy.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.posAccuracy.string), value.posAccuracy.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeConfidence");
  value.timeConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.timeConfidence.isValidFlag==1)
  {
    value.timeConfidence.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posConfidence");
  value.posConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.posConfidence.isValidFlag==1)
  {
    value.posConfidence.isValidFlag = 1;
    value.posConfidence.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.posConfidence.string), value.posConfidence.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  value.speedConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.speedConfidence.isValidFlag==1)
  {
    value.speedConfidence.isValidFlag = 1;
    value.speedConfidence.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.speedConfidence.string), value.speedConfidence.string);
  }
  return result;
}

int SetIntersectionCollisionFullPositionVectorParams(LONG packetHandle, struct IntersectionCollisionFullPositionVector value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "utcTime");
  if(value.utcTime.isValidFlag==1)
  {
    SetIntersectionCollisionDDateTimeParams(packetHandle, value.utcTime, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lon);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.lat);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  if(value.elevation.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.elevation.stringLength, value.elevation.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  if(value.heading.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.heading.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  if(value.speed.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.speed.stringLength, value.speed.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  if(value.posAccuracy.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.posAccuracy.stringLength, value.posAccuracy.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeConfidence");
  if(value.timeConfidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeConfidence.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posConfidence");
  if(value.posConfidence.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.posConfidence.stringLength, value.posConfidence.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  if(value.speedConfidence.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.speedConfidence.stringLength, value.speedConfidence.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  return result;
}

int GetIntersectionCollisionPathHistoryPointType_01Params(LONG packetHandle, struct IntersectionCollisionPathHistoryPointType_01 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  value.elevationOffset.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.elevationOffset.isValidFlag==1)
  {
    value.elevationOffset.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  value.timeOffset.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.timeOffset.isValidFlag==1)
  {
    value.timeOffset.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  value.posAccuracy.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.posAccuracy.isValidFlag==1)
  {
    value.posAccuracy.isValidFlag = 1;
    value.posAccuracy.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.posAccuracy.string), value.posAccuracy.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  value.heading.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.heading.isValidFlag==1)
  {
    value.heading.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.speed.isValidFlag==1)
  {
    value.speed.isValidFlag = 1;
    value.speed.stringLength = C2xGetTokenData(packetHandle, "IntersectionCollision", newPath, elcount(value.speed.string), value.speed.string);
  }
  return result;
}

int SetIntersectionCollisionPathHistoryPointType_01Params(LONG packetHandle, struct IntersectionCollisionPathHistoryPointType_01 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  if(value.elevationOffset.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevationOffset.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  if(value.timeOffset.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeOffset.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  if(value.posAccuracy.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.posAccuracy.stringLength, value.posAccuracy.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  if(value.heading.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.heading.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  if(value.speed.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "IntersectionCollision", newPath, value.speed.stringLength, value.speed.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_01Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_01 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollisionPathHistoryPointType_01Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_01Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_01 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollisionPathHistoryPointType_01Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_02Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_02 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  value.elevationOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  value.timeOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  GetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  value.heading = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  GetIntersectionCollision_Blob_TransmissionAndSpeedParams(packetHandle, value.speed, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_02Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_02 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevationOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  SetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.heading);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  SetIntersectionCollision_Blob_TransmissionAndSpeedParams(packetHandle, value.speed, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_02Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_02 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_02Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_02Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_02 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_02Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_02Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_02 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_02");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_02Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_02, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_02Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_02 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_02");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_02Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_02, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_03Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_03 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  value.elevationOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  value.timeOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  GetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_03Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_03 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevationOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  SetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_03Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_03 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_03Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_03Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_03 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_03Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_03Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_03 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_03");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_03Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_03, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_03Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_03 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_03");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_03Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_03, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_04Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_04 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  value.elevationOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  value.timeOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_04Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_04 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevationOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_04Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_04 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_04Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_04Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_04 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_04Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_04Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_04 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_04");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_04Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_04, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_04Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_04 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_04");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_04Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_04, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_05Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_05 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  value.elevationOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  GetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_05Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_05 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevationOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  SetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_05Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_05 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_05Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_05Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_05 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_05Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_05Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_05 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_05");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_05Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_05, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_05Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_05 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_05");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_05Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_05, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_06Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_06 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  value.elevationOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_06Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_06 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.elevationOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_06Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_06 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_06Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_06Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_06 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_06Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_06Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_06 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_06");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_06Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_06, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_06Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_06 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_06");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_06Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_06, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_07Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_07 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  value.timeOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  GetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_07Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_07 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  SetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_07Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_07 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_07Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_07Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_07 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_07Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_07Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_07 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_07");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_07Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_07, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_07Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_07 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_07");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_07Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_07, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_08Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_08 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  value.timeOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_08Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_08 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.timeOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_08Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_08 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_08Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_08Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_08 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_08Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_08Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_08 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_08");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_08Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_08, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_08Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_08 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_08");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_08Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_08, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_09Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_09 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  GetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_09Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_09 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracy");
  SetIntersectionCollision_Blob_PositionalAccuracyParams(packetHandle, value.accuracy, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_09Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_09 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_09Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_09Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_09 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_09Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_09Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_09 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_09");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_09Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_09, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_09Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_09 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_09");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_09Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_09, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistoryPointType_10Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_10 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  value.latOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  value.longOffset = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_PathHistoryPointType_10Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistoryPointType_10 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "latOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.latOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "longOffset");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.longOffset);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_10Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_10 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);
  if((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetIntersectionCollision_Blob_PathHistoryPointType_10Params(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_10Params(LONG packetHandle, struct IntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_10 value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "IntersectionCollision", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetIntersectionCollision_Blob_PathHistoryPointType_10Params(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  return result;
}

int GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_10Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_10 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_10");
  GetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_10Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_10, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_10Params(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_10 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PathHistory_crumbData_pathHistoryPointSets_10");
  SetIntersectionCollision_Blob_PathHistory_crumbData_pathHistoryPointSets_10Params(packetHandle, value._Blob_PathHistory_crumbData_pathHistoryPointSets_10, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_PathHistory_crumbDataParams(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "IntersectionCollision", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_01");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_01Params(packetHandle, value.pathHistoryPointSets_01, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_02");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_02Params(packetHandle, value.pathHistoryPointSets_02, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_03");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_03Params(packetHandle, value.pathHistoryPointSets_03, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_04");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_04Params(packetHandle, value.pathHistoryPointSets_04, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_05");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_05Params(packetHandle, value.pathHistoryPointSets_05, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_06");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_06Params(packetHandle, value.pathHistoryPointSets_06, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_07");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_07Params(packetHandle, value.pathHistoryPointSets_07, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_08");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_08Params(packetHandle, value.pathHistoryPointSets_08, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 8:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_09");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_09Params(packetHandle, value.pathHistoryPointSets_09, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 9:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_10");
      GetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_10Params(packetHandle, value.pathHistoryPointSets_10, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetIntersectionCollision_PathHistory_crumbDataParams(LONG packetHandle, struct IntersectionCollision_PathHistory_crumbData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_01");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_01Params(packetHandle, value.pathHistoryPointSets_01, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_02");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_02Params(packetHandle, value.pathHistoryPointSets_02, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_03");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_03Params(packetHandle, value.pathHistoryPointSets_03, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_04");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_04Params(packetHandle, value.pathHistoryPointSets_04, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_05");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_05Params(packetHandle, value.pathHistoryPointSets_05, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_06");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_06Params(packetHandle, value.pathHistoryPointSets_06, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_07");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_07Params(packetHandle, value.pathHistoryPointSets_07, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_08");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_08Params(packetHandle, value.pathHistoryPointSets_08, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 8:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_09");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_09Params(packetHandle, value.pathHistoryPointSets_09, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
    case 9:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathHistoryPointSets_10");
      SetIntersectionCollision_PathHistory_crumbData_pathHistoryPointSets_10Params(packetHandle, value.pathHistoryPointSets_10, newPath);
      result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetIntersectionCollisionPathHistoryParams(LONG packetHandle, struct IntersectionCollisionPathHistory value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "initialPosition");
  value.initialPosition.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.initialPosition.isValidFlag==1)
  {
    GetIntersectionCollisionFullPositionVectorParams(packetHandle, value.initialPosition, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "currGPSstatus");
  value.currGPSstatus.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.currGPSstatus.isValidFlag==1)
  {
    value.currGPSstatus.isValidFlag = 1;
    value.currGPSstatus.stringLength = C2xGetTokenLengthBit(packetHandle, "IntersectionCollision", newPath);
    if ((result = CheckLastError("IntersectionCollision", gkFuncRefGet, result))==0)
    {
      for(j=0; j<value.currGPSstatus.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j) == 0)
        {
          value.currGPSstatus.string[j] = '0';
        }
        else
        {
          value.currGPSstatus.string[j] = '1';
        }
        result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
      }
    }

  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "itemCnt");
  value.itemCnt.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath);
  if(value.itemCnt.isValidFlag==1)
  {
    value.itemCnt.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crumbData");
  GetIntersectionCollision_PathHistory_crumbDataParams(packetHandle, value.crumbData, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionPathHistoryParams(LONG packetHandle, struct IntersectionCollisionPathHistory value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "initialPosition");
  if(value.initialPosition.isValidFlag==1)
  {
    SetIntersectionCollisionFullPositionVectorParams(packetHandle, value.initialPosition, newPath);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "currGPSstatus");
  if(value.currGPSstatus.isValidFlag==1)
  {
      for(j=0; j<value.currGPSstatus.stringLength; j++)
      {
        if(value.currGPSstatus.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "IntersectionCollision", newPath, j, 1);
        }
        result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "itemCnt");
  if(value.itemCnt.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.itemCnt.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", newPath) )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crumbData");
  SetIntersectionCollision_PathHistory_crumbDataParams(packetHandle, value.crumbData, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollision_Blob_LaneNumberParams(LONG packetHandle, struct IntersectionCollision_Blob_LaneNumber value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneNumber");
  value.laneNumber = C2xGetTokenInt(packetHandle, "IntersectionCollision", newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollision_Blob_LaneNumberParams(LONG packetHandle, struct IntersectionCollision_Blob_LaneNumber value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneNumber");
  C2xSetTokenInt(packetHandle, "IntersectionCollision", newPath, value.laneNumber);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int GetIntersectionCollisionLaneNumberParams(LONG packetHandle, struct IntersectionCollisionLaneNumber value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_LaneNumber");
  GetIntersectionCollision_Blob_LaneNumberParams(packetHandle, value._Blob_LaneNumber, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int SetIntersectionCollisionLaneNumberParams(LONG packetHandle, struct IntersectionCollisionLaneNumber value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_LaneNumber");
  SetIntersectionCollision_Blob_LaneNumberParams(packetHandle, value._Blob_LaneNumber, newPath);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int API_GetIntersectionCollisionParams(LONG packetHandle, struct IntersectionCollision value)
{
  int result;
  result = 0;

  value.msgID = C2xGetTokenInt(packetHandle, "IntersectionCollision", "msgID");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  value.msgCnt = C2xGetTokenInt(packetHandle, "IntersectionCollision", "msgCnt");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  value.id.isValidFlag = 1;
  GetIntersectionCollisionTemporaryIDParams(packetHandle, value.id, "id");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  value.secMark.isValidFlag = C2xIsTokenAvailable(packetHandle, "IntersectionCollision", "secMark");
  if(value.secMark.isValidFlag == 1)
  {
    value.secMark.value = C2xGetTokenInt(packetHandle, "IntersectionCollision", "secMark");
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  }
  value.path.isValidFlag = 1;
  GetIntersectionCollisionPathHistoryParams(packetHandle, value.path, "path");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  value.intersetionID = C2xGetTokenInt(packetHandle, "IntersectionCollision", "intersetionID");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  value.laneNumber.isValidFlag = 1;
  GetIntersectionCollisionLaneNumberParams(packetHandle, value.laneNumber, "laneNumber");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  value.eventFlag = C2xGetTokenInt(packetHandle, "IntersectionCollision", "eventFlag");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

int API_SetIntersectionCollisionParams(LONG packetHandle, struct IntersectionCollision value)
{
  int result;
  result = 0;

  value.msgID = 6;

  C2xSetTokenInt(packetHandle, "IntersectionCollision", "msgID", value.msgID);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  C2xSetTokenInt(packetHandle, "IntersectionCollision", "msgCnt", value.msgCnt);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  SetIntersectionCollisionTemporaryIDParams(packetHandle, value.id, "id");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  if (value.secMark.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "IntersectionCollision", "secMark", value.secMark.value);
    result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "IntersectionCollision", "secMark") )
    {
      C2xRemoveToken(packetHandle, "IntersectionCollision", "secMark");
    }
  }

  SetIntersectionCollisionPathHistoryParams(packetHandle, value.path, "path");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  C2xSetTokenInt(packetHandle, "IntersectionCollision", "intersetionID", value.intersetionID);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  SetIntersectionCollisionLaneNumberParams(packetHandle, value.laneNumber, "laneNumber");
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  C2xSetTokenInt(packetHandle, "IntersectionCollision", "eventFlag", value.eventFlag);
  result = CheckLastError("IntersectionCollision", gkFuncRefGet, result);

  return result;
}

