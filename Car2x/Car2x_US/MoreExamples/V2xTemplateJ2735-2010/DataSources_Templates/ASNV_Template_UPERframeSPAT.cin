/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct UPERframeSPAT payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitUPERframeSPATPacket();
//  if (packetHandle!=0) {
//    if (API_SetUPERframeSPATParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    struct UPERframeSPATDescriptiveName {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[64];
        INT  stringLength;
    };
    
    struct UPERframeSPATIntersectionReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct UPERframeSPATIntersectionStatusObject {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeSPATEnabledLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        BYTE arrayValue[16];  // INTEGER, 0..255;
    };
    
    struct UPERframeSPATTimeChangeDetails {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN startTime;  // INTEGER, OPTIONAL, 0..36002;
        WORD minEndTime;  // INTEGER, 0..36002;
        struct OPT_WORD_ASN maxEndTime;  // INTEGER, OPTIONAL, 0..36002;
        struct OPT_WORD_ASN likelyTime;  // INTEGER, OPTIONAL, 0..36002;
        struct OPT_BYTE_ASN confidence;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_WORD_ASN nextTime;  // INTEGER, OPTIONAL, 0..36002;
    };
    
    struct UPERframeSPAT_REGION_Reg_AdvisorySpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeSPATAdvisorySpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT type;  // ENUMERATED, none(0), greenwave(1), ecoDrive(2), transit(3);
        struct OPT_WORD_ASN speed;  // INTEGER, OPTIONAL, 0..500;
        struct OPT_ENUM_ASN confidence;  // ENUMERATED, OPTIONAL, unavailable(0), prec100ms(1), prec10ms(2), prec5ms(3), prec1ms(4), prec0_1ms(5), prec0_05ms(6), prec0_01ms(7);
        struct OPT_WORD_ASN distance;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_BYTE_ASN class;  // INTEGER, OPTIONAL, 0..255;
        struct UPERframeSPAT_REGION_Reg_AdvisorySpeed regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeSPATAdvisorySpeedList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeSPATAdvisorySpeed arrayValue[16];  // SEQUENCE;
    };
    
    struct UPERframeSPAT_REGION_Reg_MovementEvent {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeSPATMovementEvent {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT eventState;  // ENUMERATED, unavailable(0), dark(1), stop_Then_Proceed(2), stop_And_Remain(3), pre_Movement(4), permissive_Movement_Allowed(5), protected_Movement_Allowed(6), permissive_clearance(7), protected_clearance(8), caution_Conflicting_Traffic(9);
        struct UPERframeSPATTimeChangeDetails timing;  // SEQUENCE, OPTIONAL;
        struct UPERframeSPATAdvisorySpeedList speeds;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeSPAT_REGION_Reg_MovementEvent regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeSPATMovementEventList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeSPATMovementEvent arrayValue[16];  // SEQUENCE;
    };
    
    struct UPERframeSPAT_REGION_Reg_ConnectionManeuverAssist {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeSPATConnectionManeuverAssist {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE connectionID;  // INTEGER, 0..255;
        struct OPT_WORD_ASN queueLength;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_WORD_ASN availableStorageLength;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_BOOL_ASN waitOnStop;  // BOOLEAN, OPTIONAL;
        struct OPT_BOOL_ASN pedBicycleDetect;  // BOOLEAN, OPTIONAL;
        struct UPERframeSPAT_REGION_Reg_ConnectionManeuverAssist regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeSPATManeuverAssistList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeSPATConnectionManeuverAssist arrayValue[16];  // SEQUENCE;
    };
    
    struct UPERframeSPAT_REGION_Reg_MovementState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeSPATMovementState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeSPATDescriptiveName movementName;  // IA5STRING, OPTIONAL;
        BYTE signalGroup;  // INTEGER, 0..255;
        struct UPERframeSPATMovementEventList state_time_speed;  // SEQUENCEOF;
        struct UPERframeSPATManeuverAssistList maneuverAssistList;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeSPAT_REGION_Reg_MovementState regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeSPATMovementList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeSPATMovementState arrayValue[255];  // SEQUENCE;
    };
    
    struct UPERframeSPATSignalControlState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[2];
        INT  stringLength;
    };
    
    struct UPERframeSPAT_REGION_Reg_IntersectionState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeSPATIntersectionState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeSPATDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct UPERframeSPATIntersectionReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct UPERframeSPATIntersectionStatusObject status;  // BITSTRING;
        struct OPT_DWORD_ASN moy;  // INTEGER, OPTIONAL, 0..527040;
        struct OPT_WORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..65535;
        struct UPERframeSPATEnabledLaneList enabledLanes;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeSPATMovementList states;  // SEQUENCEOF;
        struct UPERframeSPATManeuverAssistList maneuverAssistList;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeSPATSignalControlState priority;  // OCTETSTRING, OPTIONAL;
        struct UPERframeSPATSignalControlState preempt;  // OCTETSTRING, OPTIONAL;
        struct UPERframeSPAT_REGION_Reg_IntersectionState regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeSPATIntersectionStateList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeSPATIntersectionState arrayValue[32];  // SEQUENCE;
    };
    
    struct UPERframeSPAT_REGION_Reg_SPAT {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeSPATSPAT {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE msgID;  // INTEGER, 0..255, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollisionAlert_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData_P(18), signalPhaseAndTimingMessage_P(19);
        struct OPT_BYTE_ASN msgSubID;  // INTEGER, OPTIONAL, 0..255;
        struct UPERframeSPATDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct UPERframeSPATIntersectionStateList intersections;  // SEQUENCEOF;
        struct UPERframeSPAT_REGION_Reg_SPAT regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeSPATUPER_BlobSPAT {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[1024];
        INT  stringLength;
        struct UPERframeSPATSPAT SPAT;  // SEQUENCE;
    };
    
    struct UPERframeSPAT_Blob_MsgCRC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD msgCRC;  // INTEGER, 0..65535;
    };
    
    struct UPERframeSPATMsgCRC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
        struct UPERframeSPAT_Blob_MsgCRC _Blob_MsgCRC;  // SEQUENCE;
    };
    
    struct UPERframeSPAT {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE msgID;  // INTEGER, 0..255, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollisionAlert_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData_P(18), signalPhaseAndTimingMessage_P(19);
        struct OPT_BYTE_ASN msgSubID;  // INTEGER, OPTIONAL, 0..255;
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        BYTE contentID;  // INTEGER, 0..255, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollisionAlert_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData_P(18), signalPhaseAndTimingMessage_P(19);
        struct UPERframeSPATUPER_BlobSPAT msgBlob;  // OCTETSTRING;
        struct UPERframeSPATMsgCRC crc;  // OCTETSTRING, OPTIONAL;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitUPERframeSPATPacket()
{
  return C2xInitPacket("UPERframeSPAT"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitUPERframeSPATPacket(struct UPERframeSPAT msgStruct)
{
  long pktHandle;

  pktHandle = API_InitUPERframeSPATPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetUPERframeSPATParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitUPERframeSPATPacket(struct UPERframeSPAT msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("UPERframeSPAT", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetUPERframeSPATParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetUPERframeSPATIntersectionReferenceIDParams(LONG packetHandle, struct UPERframeSPATIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int SetUPERframeSPATIntersectionReferenceIDParams(LONG packetHandle, struct UPERframeSPATIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.region.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.id);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int GetUPERframeSPATEnabledLaneListParams(LONG packetHandle, struct UPERframeSPATEnabledLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeSPAT", oldPath);
  if((result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "UPERframeSPAT", newPath);
      result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeSPATEnabledLaneListParams(LONG packetHandle, struct UPERframeSPATEnabledLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeSPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "UPERframeSPAT", newPath, value.arrayValue[i]);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeSPATTimeChangeDetailsParams(LONG packetHandle, struct UPERframeSPATTimeChangeDetails value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startTime");
  value.startTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.startTime.isValidFlag==1)
  {
    value.startTime.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minEndTime");
  value.minEndTime = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maxEndTime");
  value.maxEndTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.maxEndTime.isValidFlag==1)
  {
    value.maxEndTime.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "likelyTime");
  value.likelyTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.likelyTime.isValidFlag==1)
  {
    value.likelyTime.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.confidence.isValidFlag==1)
  {
    value.confidence.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nextTime");
  value.nextTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.nextTime.isValidFlag==1)
  {
    value.nextTime.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeSPATTimeChangeDetailsParams(LONG packetHandle, struct UPERframeSPATTimeChangeDetails value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startTime");
  if(value.startTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.startTime.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minEndTime");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.minEndTime);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maxEndTime");
  if(value.maxEndTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.maxEndTime.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "likelyTime");
  if(value.likelyTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.likelyTime.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  if(value.confidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.confidence.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nextTime");
  if(value.nextTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.nextTime.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  return result;
}

int GetUPERframeSPATAdvisorySpeedParams(LONG packetHandle, struct UPERframeSPATAdvisorySpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  value.type = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.speed.isValidFlag==1)
  {
    value.speed.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.confidence.isValidFlag==1)
  {
    value.confidence.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "distance");
  value.distance.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.distance.isValidFlag==1)
  {
    value.distance.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "class");
  value.class.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.class.isValidFlag==1)
  {
    value.class.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeSPATAdvisorySpeedParams(LONG packetHandle, struct UPERframeSPATAdvisorySpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.type);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  if(value.speed.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.speed.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  if(value.confidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.confidence.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "distance");
  if(value.distance.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.distance.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "class");
  if(value.class.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.class.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  return result;
}

int GetUPERframeSPATAdvisorySpeedListParams(LONG packetHandle, struct UPERframeSPATAdvisorySpeedList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeSPAT", oldPath);
  if((result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeSPATAdvisorySpeedParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeSPATAdvisorySpeedListParams(LONG packetHandle, struct UPERframeSPATAdvisorySpeedList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeSPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeSPATAdvisorySpeedParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeSPATMovementEventParams(LONG packetHandle, struct UPERframeSPATMovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventState");
  value.eventState = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timing");
  value.timing.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.timing.isValidFlag==1)
  {
    GetUPERframeSPATTimeChangeDetailsParams(packetHandle, value.timing, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speeds");
  value.speeds.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.speeds.isValidFlag==1)
  {
    GetUPERframeSPATAdvisorySpeedListParams(packetHandle, value.speeds, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeSPATMovementEventParams(LONG packetHandle, struct UPERframeSPATMovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventState");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.eventState);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timing");
  if(value.timing.isValidFlag==1)
  {
    SetUPERframeSPATTimeChangeDetailsParams(packetHandle, value.timing, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speeds");
  if(value.speeds.isValidFlag==1)
  {
    SetUPERframeSPATAdvisorySpeedListParams(packetHandle, value.speeds, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  return result;
}

int GetUPERframeSPATMovementEventListParams(LONG packetHandle, struct UPERframeSPATMovementEventList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeSPAT", oldPath);
  if((result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeSPATMovementEventParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeSPATMovementEventListParams(LONG packetHandle, struct UPERframeSPATMovementEventList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeSPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeSPATMovementEventParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeSPATConnectionManeuverAssistParams(LONG packetHandle, struct UPERframeSPATConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  value.connectionID = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "queueLength");
  value.queueLength.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.queueLength.isValidFlag==1)
  {
    value.queueLength.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "availableStorageLength");
  value.availableStorageLength.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.availableStorageLength.isValidFlag==1)
  {
    value.availableStorageLength.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "waitOnStop");
  value.waitOnStop.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.waitOnStop.isValidFlag==1)
  {
    value.waitOnStop.value = C2xGetTokenInt64(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pedBicycleDetect");
  value.pedBicycleDetect.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.pedBicycleDetect.isValidFlag==1)
  {
    value.pedBicycleDetect.value = C2xGetTokenInt64(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeSPATConnectionManeuverAssistParams(LONG packetHandle, struct UPERframeSPATConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.connectionID);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "queueLength");
  if(value.queueLength.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.queueLength.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "availableStorageLength");
  if(value.availableStorageLength.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.availableStorageLength.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "waitOnStop");
  if(value.waitOnStop.isValidFlag==1)
  {
    C2xSetTokenInt64(packetHandle, "UPERframeSPAT", newPath, value.waitOnStop.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pedBicycleDetect");
  if(value.pedBicycleDetect.isValidFlag==1)
  {
    C2xSetTokenInt64(packetHandle, "UPERframeSPAT", newPath, value.pedBicycleDetect.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  return result;
}

int GetUPERframeSPATManeuverAssistListParams(LONG packetHandle, struct UPERframeSPATManeuverAssistList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeSPAT", oldPath);
  if((result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeSPATConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeSPATManeuverAssistListParams(LONG packetHandle, struct UPERframeSPATManeuverAssistList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeSPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeSPATConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeSPATMovementStateParams(LONG packetHandle, struct UPERframeSPATMovementState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "movementName");
  value.movementName.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.movementName.isValidFlag==1)
  {
    value.movementName.stringLength = C2xGetTokenData(packetHandle, "UPERframeSPAT", newPath, elcount(value.movementName.string), value.movementName.string);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  value.signalGroup = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "state_time_speed");
  GetUPERframeSPATMovementEventListParams(packetHandle, value.state_time_speed, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  value.maneuverAssistList.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.maneuverAssistList.isValidFlag==1)
  {
    GetUPERframeSPATManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeSPATMovementStateParams(LONG packetHandle, struct UPERframeSPATMovementState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "movementName");
  if(value.movementName.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeSPAT", newPath, value.movementName.stringLength, value.movementName.string);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.signalGroup);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "state_time_speed");
  SetUPERframeSPATMovementEventListParams(packetHandle, value.state_time_speed, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  if(value.maneuverAssistList.isValidFlag==1)
  {
    SetUPERframeSPATManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  return result;
}

int GetUPERframeSPATMovementListParams(LONG packetHandle, struct UPERframeSPATMovementList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeSPAT", oldPath);
  if((result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeSPATMovementStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeSPATMovementListParams(LONG packetHandle, struct UPERframeSPATMovementList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeSPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeSPATMovementStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeSPATIntersectionStateParams(LONG packetHandle, struct UPERframeSPATIntersectionState value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "UPERframeSPAT", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetUPERframeSPATIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
  value.status.isValidFlag = 1;
  value.status.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeSPAT", newPath);
  if ((result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result))==0)
  {
    if(value.status.stringLength > 0)
    {
      for(j=0; j<value.status.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeSPAT", newPath, j) == 0)
        {
          value.status.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeSPAT", newPath, j) == 1)
        {
          value.status.string[j] = '1';
        }

        if(value.status.stringLength == 1)
        {
          value.status.string[1] = '0';
        }
        result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.status.stringLength+1; k > -1; k--)
      {
        if(value.status.string[k] == '1')
        {
          value.status.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "moy");
  value.moy.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.moy.isValidFlag==1)
  {
    value.moy.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabledLanes");
  value.enabledLanes.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.enabledLanes.isValidFlag==1)
  {
    GetUPERframeSPATEnabledLaneListParams(packetHandle, value.enabledLanes, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "states");
  GetUPERframeSPATMovementListParams(packetHandle, value.states, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  value.maneuverAssistList.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.maneuverAssistList.isValidFlag==1)
  {
    GetUPERframeSPATManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "priority");
  value.priority.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.priority.isValidFlag==1)
  {
    value.priority.isValidFlag = 1;
    value.priority.stringLength = C2xGetTokenData(packetHandle, "UPERframeSPAT", newPath, elcount(value.priority.string), value.priority.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "preempt");
  value.preempt.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.preempt.isValidFlag==1)
  {
    value.preempt.isValidFlag = 1;
    value.preempt.stringLength = C2xGetTokenData(packetHandle, "UPERframeSPAT", newPath, elcount(value.preempt.string), value.preempt.string);
  }
  return result;
}

int SetUPERframeSPATIntersectionStateParams(LONG packetHandle, struct UPERframeSPATIntersectionState value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeSPAT", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetUPERframeSPATIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.revision);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
    for(j=0; j<value.status.stringLength; j++)
    {
      if(value.status.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "UPERframeSPAT", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "UPERframeSPAT", newPath, j, 1);
      }
      result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "moy");
  if(value.moy.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.moy.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.timeStamp.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabledLanes");
  if(value.enabledLanes.isValidFlag==1)
  {
    SetUPERframeSPATEnabledLaneListParams(packetHandle, value.enabledLanes, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "states");
  SetUPERframeSPATMovementListParams(packetHandle, value.states, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  if(value.maneuverAssistList.isValidFlag==1)
  {
    SetUPERframeSPATManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "priority");
  if(value.priority.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeSPAT", newPath, value.priority.stringLength, value.priority.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "preempt");
  if(value.preempt.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeSPAT", newPath, value.preempt.stringLength, value.preempt.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  return result;
}

int GetUPERframeSPATIntersectionStateListParams(LONG packetHandle, struct UPERframeSPATIntersectionStateList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeSPAT", oldPath);
  if((result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeSPATIntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeSPATIntersectionStateListParams(LONG packetHandle, struct UPERframeSPATIntersectionStateList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeSPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeSPATIntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeSPATSPATParams(LONG packetHandle, struct UPERframeSPATSPAT value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgID");
  value.msgID = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgSubID");
  value.msgSubID.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.msgSubID.isValidFlag==1)
  {
    value.msgSubID.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "UPERframeSPAT", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  GetUPERframeSPATIntersectionStateListParams(packetHandle, value.intersections, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int SetUPERframeSPATSPATParams(LONG packetHandle, struct UPERframeSPATSPAT value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgID");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.msgID);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgSubID");
  if(value.msgSubID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.msgSubID.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeSPAT", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  SetUPERframeSPATIntersectionStateListParams(packetHandle, value.intersections, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int GetUPERframeSPATUPER_BlobSPATParams(LONG packetHandle, struct UPERframeSPATUPER_BlobSPAT value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "SPAT");
  GetUPERframeSPATSPATParams(packetHandle, value.SPAT, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int SetUPERframeSPATUPER_BlobSPATParams(LONG packetHandle, struct UPERframeSPATUPER_BlobSPAT value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "SPAT");
  SetUPERframeSPATSPATParams(packetHandle, value.SPAT, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int GetUPERframeSPAT_Blob_MsgCRCParams(LONG packetHandle, struct UPERframeSPAT_Blob_MsgCRC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCRC");
  value.msgCRC = C2xGetTokenInt(packetHandle, "UPERframeSPAT", newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int SetUPERframeSPAT_Blob_MsgCRCParams(LONG packetHandle, struct UPERframeSPAT_Blob_MsgCRC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCRC");
  C2xSetTokenInt(packetHandle, "UPERframeSPAT", newPath, value.msgCRC);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int GetUPERframeSPATMsgCRCParams(LONG packetHandle, struct UPERframeSPATMsgCRC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_MsgCRC");
  GetUPERframeSPAT_Blob_MsgCRCParams(packetHandle, value._Blob_MsgCRC, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int SetUPERframeSPATMsgCRCParams(LONG packetHandle, struct UPERframeSPATMsgCRC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_MsgCRC");
  SetUPERframeSPAT_Blob_MsgCRCParams(packetHandle, value._Blob_MsgCRC, newPath);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  return result;
}

int API_GetUPERframeSPATParams(LONG packetHandle, struct UPERframeSPAT value)
{
  int result;
  result = 0;

  value.msgID = C2xGetTokenInt(packetHandle, "UPERframeSPAT", "msgID");
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  value.msgSubID.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", "msgSubID");
  if(value.msgSubID.isValidFlag == 1)
  {
    value.msgSubID.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", "msgSubID");
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  }
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", "timeStamp");
  if(value.timeStamp.isValidFlag == 1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "UPERframeSPAT", "timeStamp");
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  }
  value.contentID = C2xGetTokenInt(packetHandle, "UPERframeSPAT", "contentID");
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  value.msgBlob.isValidFlag = 1;
  GetUPERframeSPATUPER_BlobSPATParams(packetHandle, value.msgBlob, "msgBlob");
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  value.crc.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", "crc");
  if(value.crc.isValidFlag == 1)
  {
    value.crc.isValidFlag = 1;
    GetUPERframeSPATMsgCRCParams(packetHandle, value.crc, "crc");
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  }
  return result;
}

int API_SetUPERframeSPATParams(LONG packetHandle, struct UPERframeSPAT value)
{
  int result;
  result = 0;

  value.msgID = 17;

  C2xSetTokenInt(packetHandle, "UPERframeSPAT", "msgID", value.msgID);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  if (value.msgSubID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", "msgSubID", value.msgSubID.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", "msgSubID") )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", "msgSubID");
    }
  }

  if (value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeSPAT", "timeStamp", value.timeStamp.value);
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", "timeStamp") )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", "timeStamp");
    }
  }

  value.contentID = 19;

  C2xSetTokenInt(packetHandle, "UPERframeSPAT", "contentID", value.contentID);
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  SetUPERframeSPATUPER_BlobSPATParams(packetHandle, value.msgBlob, "msgBlob");
  result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  if (value.crc.isValidFlag==1)
  {
    SetUPERframeSPATMsgCRCParams(packetHandle, value.crc, "crc");
    result = CheckLastError("UPERframeSPAT", gkFuncRefGet, result);

  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeSPAT", "crc") )
    {
      C2xRemoveToken(packetHandle, "UPERframeSPAT", "crc");
    }
  }

  return result;
}

