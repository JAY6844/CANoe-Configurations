/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct RTCM_Corrections payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitRTCM_CorrectionsPacket();
//  if (packetHandle!=0) {
//    if (API_SetRTCM_CorrectionsParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    struct RTCM_CorrectionsDDateTime {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN year;  // INTEGER, OPTIONAL, 0..9999;
        struct OPT_BYTE_ASN month;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_BYTE_ASN day;  // INTEGER, OPTIONAL, 0..31;
        struct OPT_BYTE_ASN hour;  // INTEGER, OPTIONAL, 0..31;
        struct OPT_BYTE_ASN minute;  // INTEGER, OPTIONAL, 0..63;
        struct OPT_WORD_ASN second;  // INTEGER, OPTIONAL, 0..65535;
    };
    
    struct RTCM_CorrectionsElevation {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
        WORD _Blob_Elevation;  // INTEGER, 0..65535;
    };
    
    struct RTCM_Corrections_Blob_TransmissionAndSpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE transmissionState;  // INTEGER, 0..7, neutral(0), park(1), forwardGears(2), reverseGears(3), reserved1(4), reserved2(5), reserved3(6), unavailable(7);
        WORD speed;  // INTEGER, 0..8191;
    };
    
    struct RTCM_CorrectionsTransmissionAndSpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
        struct RTCM_Corrections_Blob_TransmissionAndSpeed _Blob_TransmissionAndSpeed;  // SEQUENCE;
    };
    
    struct RTCM_Corrections_Blob_PositionalAccuracy {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE accuracySemiMajor;  // INTEGER, 0..255;
        BYTE accuracySemiMinor;  // INTEGER, 0..255;
        WORD accuracyOrientation;  // INTEGER, 0..65535;
    };
    
    struct RTCM_CorrectionsPositionalAccuracy {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[5];
        INT  stringLength;
        struct RTCM_Corrections_Blob_PositionalAccuracy _Blob_PositionalAccuracy;  // SEQUENCE;
    };
    
    struct RTCM_Corrections_Blob_PositionConfidenceSet {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE positionConfidence;  // INTEGER, 0..15, unavailable(0), a500m(1), a200m(2), a100m(3), a50m(4), a20m(5), a10m(6), a5m(7), a2m(8), a1m(9), a50cm(10), a20cm(11), a10cm(12), a5cm(13), a2cm(14), a1cm(15);
        BYTE elevationConfidence;  // INTEGER, 0..15, unavailable(0), elev_500_00(1), elev_200_00(2), elev_100_00(3), elev_050_00(4), elev_020_00(5), elev_010_00(6), elev_005_00(7), elev_002_00(8), elev_001_00(9), elev_000_50(10), elev_000_20(11), elev_000_10(12), elev_000_05(13), elev_000_02(14), elev_000_01(15);
    };
    
    struct RTCM_CorrectionsPositionConfidenceSet {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[2];
        INT  stringLength;
        struct RTCM_Corrections_Blob_PositionConfidenceSet _Blob_PositionConfidenceSet;  // SEQUENCE;
    };
    
    struct RTCM_Corrections_Blob_SpeedandHeadingandThrottleConfidence {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE headingConfidence;  // INTEGER, 0..7, unavailable(0), prec45deg(1), prec10deg(2), prec05deg(3), prec01deg(4), prec0_1deg(5), prec0_05deg(6), prec0_01deg(7);
        BYTE speedConfidence;  // INTEGER, 0..7, unavailable(0), prec100ms(1), prec10ms(2), prec5ms(3), prec1ms(4), prec0_1ms(5), prec0_05ms(6), prec0_01ms(7);
        BYTE throttleConfidence;  // INTEGER, 0..3, unavailable(0), prec10percent(1), prec1percent(2), prec0_5percent(3);
    };
    
    struct RTCM_CorrectionsSpeedandHeadingandThrottleConfidence {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[2];
        INT  stringLength;
        struct RTCM_Corrections_Blob_SpeedandHeadingandThrottleConfidence _Blob_SpeedandHeadingandThrottleConfidence;  // SEQUENCE;
    };
    
    struct RTCM_CorrectionsFullPositionVector {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct RTCM_CorrectionsDDateTime utcTime;  // SEQUENCE, OPTIONAL;
        LONG lon;  // INTEGER, -1799999999..1800000001;
        LONG lat;  // INTEGER, -900000000..900000001;
        struct RTCM_CorrectionsElevation elevation;  // OCTETSTRING, OPTIONAL;
        struct OPT_WORD_ASN heading;  // INTEGER, OPTIONAL, 0..28800;
        struct RTCM_CorrectionsTransmissionAndSpeed speed;  // OCTETSTRING, OPTIONAL;
        struct RTCM_CorrectionsPositionalAccuracy posAccuracy;  // OCTETSTRING, OPTIONAL;
        struct OPT_ENUM_ASN timeConfidence;  // ENUMERATED, OPTIONAL, unavailable(0), time_100_000(1), time_050_000(2), time_020_000(3), time_010_000(4), time_002_000(5), time_001_000(6), time_000_500(7), time_000_200(8), time_000_100(9), time_000_050(10), time_000_020(11), time_000_010(12), time_000_005(13), time_000_002(14), time_000_001(15), time_000_000_5(16), time_000_000_2(17), time_000_000_1(18), time_000_000_05(19), time_000_000_02(20), time_000_000_01(21), time_000_000_005(22), time_000_000_002(23), time_000_000_001(24), time_000_000_000_5(25), time_000_000_000_2(26), time_000_000_000_1(27), time_000_000_000_05(28), time_000_000_000_02(29), time_000_000_000_01(30), time_000_000_000_005(31), time_000_000_000_002(32), time_000_000_000_001(33), time_000_000_000_000_5(34), time_000_000_000_000_2(35), time_000_000_000_000_1(36), time_000_000_000_000_05(37), time_000_000_000_000_02(38), time_000_000_000_000_01(39);
        struct RTCM_CorrectionsPositionConfidenceSet posConfidence;  // OCTETSTRING, OPTIONAL;
        struct RTCM_CorrectionsSpeedandHeadingandThrottleConfidence speedConfidence;  // OCTETSTRING, OPTIONAL;
    };
    
    struct RTCM_Corrections_Blob_GPSstatus {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[9];
        INT  stringLength;
    };
    
    struct RTCM_Corrections_Blob_AntennaOffsetSet {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT antOffsetX;  // INTEGER, -8192..8191;
        INT antOffsetY;  // INTEGER, -256..255;
        WORD antOffsetZ;  // INTEGER, 0..511;
    };
    
    struct RTCM_Corrections_Blob_RTCMHeader {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct RTCM_Corrections_Blob_GPSstatus status;  // BITSTRING;
        struct RTCM_Corrections_Blob_AntennaOffsetSet offsetSet;  // SEQUENCE;
    };
    
    struct RTCM_CorrectionsRTCMHeader {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[6];
        INT  stringLength;
        struct RTCM_Corrections_Blob_RTCMHeader _Blob_RTCMHeader;  // SEQUENCE;
    };
    
    struct RTCM_CorrectionsRTCM_Payload {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[1024];
        INT  stringLength;
    };
    
    struct RTCM_CorrectionsRTCMmsg {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_ENUM_ASN rev;  // ENUMERATED, OPTIONAL, unknown(0), reserved(1), rtcmCMR(2), rtcmCMR_Plus(3), rtcmSAPOS(4), rtcmSAPOS_Adv(5), rtcmRTCA(6), rtcmRAW(7), rtcmRINEX(8), rtcmSP3(9), rtcmBINEX(10), rtcmRev2_x(19), rtcmRev2_0(20), rtcmRev2_1(21), rtcmRev2_3(23), rtcmRev3_0(30), rtcmRev3_1(31);
        struct OPT_WORD_ASN rtcmID;  // INTEGER, OPTIONAL, 0..32767;
        struct RTCM_CorrectionsRTCM_Payload payload;  // OCTETSTRING;
    };
    
    struct RTCM_Corrections_RTCM_Corrections_rtcmSets {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct RTCM_CorrectionsRTCMmsg arrayValue[5];  // SEQUENCE;
    };
    
    struct RTCM_Corrections {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT msgID;  // ENUMERATED, reserved(0), alaCarteMessage(1), basicSafetyMessage(2), basicSafetyMessageVerbose(3), commonSafetyRequest(4), emergencyVehicleAlert(5), intersectionCollisionAlert(6), mapData(7), nmeaCorrections(8), probeDataManagement(9), probeVehicleData(10), roadSideAlert(11), rtcmCorrections(12), signalPhaseAndTimingMessage(13), signalRequestMessage(14), signalStatusMessage(15), travelerInformation(16);
        BYTE msgCnt;  // INTEGER, 0..127;
        INT rev;  // ENUMERATED, unknown(0), reserved(1), rtcmCMR(2), rtcmCMR_Plus(3), rtcmSAPOS(4), rtcmSAPOS_Adv(5), rtcmRTCA(6), rtcmRAW(7), rtcmRINEX(8), rtcmSP3(9), rtcmBINEX(10), rtcmRev2_x(19), rtcmRev2_0(20), rtcmRev2_1(21), rtcmRev2_3(23), rtcmRev3_0(30), rtcmRev3_1(31);
        struct RTCM_CorrectionsFullPositionVector anchorPoint;  // SEQUENCE, OPTIONAL;
        struct RTCM_CorrectionsRTCMHeader rtcmHeader;  // OCTETSTRING;
        struct RTCM_Corrections_RTCM_Corrections_rtcmSets rtcmSets;  // SEQUENCEOF;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitRTCM_CorrectionsPacket()
{
  return C2xInitPacket("RTCM_Corrections"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitRTCM_CorrectionsPacket(struct RTCM_Corrections msgStruct)
{
  long pktHandle;

  pktHandle = API_InitRTCM_CorrectionsPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetRTCM_CorrectionsParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitRTCM_CorrectionsPacket(struct RTCM_Corrections msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("RTCM_Corrections", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetRTCM_CorrectionsParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetRTCM_CorrectionsDDateTimeParams(LONG packetHandle, struct RTCM_CorrectionsDDateTime value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "year");
  value.year.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.year.isValidFlag==1)
  {
    value.year.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "month");
  value.month.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.month.isValidFlag==1)
  {
    value.month.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "day");
  value.day.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.day.isValidFlag==1)
  {
    value.day.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hour");
  value.hour.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.hour.isValidFlag==1)
  {
    value.hour.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minute");
  value.minute.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.minute.isValidFlag==1)
  {
    value.minute.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  value.second.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.second.isValidFlag==1)
  {
    value.second.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  return result;
}

int SetRTCM_CorrectionsDDateTimeParams(LONG packetHandle, struct RTCM_CorrectionsDDateTime value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "year");
  if(value.year.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.year.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "month");
  if(value.month.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.month.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "day");
  if(value.day.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.day.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hour");
  if(value.hour.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.hour.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minute");
  if(value.minute.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.minute.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  if(value.second.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.second.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  return result;
}

int GetRTCM_CorrectionsElevationParams(LONG packetHandle, struct RTCM_CorrectionsElevation value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_Elevation");
  value._Blob_Elevation = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_CorrectionsElevationParams(LONG packetHandle, struct RTCM_CorrectionsElevation value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_Elevation");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value._Blob_Elevation);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_Corrections_Blob_TransmissionAndSpeedParams(LONG packetHandle, struct RTCM_Corrections_Blob_TransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmissionState");
  value.transmissionState = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_Corrections_Blob_TransmissionAndSpeedParams(LONG packetHandle, struct RTCM_Corrections_Blob_TransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "transmissionState");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.transmissionState);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.speed);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_CorrectionsTransmissionAndSpeedParams(LONG packetHandle, struct RTCM_CorrectionsTransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_TransmissionAndSpeed");
  GetRTCM_Corrections_Blob_TransmissionAndSpeedParams(packetHandle, value._Blob_TransmissionAndSpeed, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_CorrectionsTransmissionAndSpeedParams(LONG packetHandle, struct RTCM_CorrectionsTransmissionAndSpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_TransmissionAndSpeed");
  SetRTCM_Corrections_Blob_TransmissionAndSpeedParams(packetHandle, value._Blob_TransmissionAndSpeed, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_Corrections_Blob_PositionalAccuracyParams(LONG packetHandle, struct RTCM_Corrections_Blob_PositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracySemiMajor");
  value.accuracySemiMajor = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracySemiMinor");
  value.accuracySemiMinor = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracyOrientation");
  value.accuracyOrientation = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_Corrections_Blob_PositionalAccuracyParams(LONG packetHandle, struct RTCM_Corrections_Blob_PositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracySemiMajor");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.accuracySemiMajor);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracySemiMinor");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.accuracySemiMinor);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "accuracyOrientation");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.accuracyOrientation);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_CorrectionsPositionalAccuracyParams(LONG packetHandle, struct RTCM_CorrectionsPositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PositionalAccuracy");
  GetRTCM_Corrections_Blob_PositionalAccuracyParams(packetHandle, value._Blob_PositionalAccuracy, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_CorrectionsPositionalAccuracyParams(LONG packetHandle, struct RTCM_CorrectionsPositionalAccuracy value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PositionalAccuracy");
  SetRTCM_Corrections_Blob_PositionalAccuracyParams(packetHandle, value._Blob_PositionalAccuracy, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_Corrections_Blob_PositionConfidenceSetParams(LONG packetHandle, struct RTCM_Corrections_Blob_PositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionConfidence");
  value.positionConfidence = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationConfidence");
  value.elevationConfidence = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_Corrections_Blob_PositionConfidenceSetParams(LONG packetHandle, struct RTCM_Corrections_Blob_PositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "positionConfidence");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.positionConfidence);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevationConfidence");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.elevationConfidence);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_CorrectionsPositionConfidenceSetParams(LONG packetHandle, struct RTCM_CorrectionsPositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PositionConfidenceSet");
  GetRTCM_Corrections_Blob_PositionConfidenceSetParams(packetHandle, value._Blob_PositionConfidenceSet, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_CorrectionsPositionConfidenceSetParams(LONG packetHandle, struct RTCM_CorrectionsPositionConfidenceSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_PositionConfidenceSet");
  SetRTCM_Corrections_Blob_PositionConfidenceSetParams(packetHandle, value._Blob_PositionConfidenceSet, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_Corrections_Blob_SpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct RTCM_Corrections_Blob_SpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "headingConfidence");
  value.headingConfidence = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  value.speedConfidence = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "throttleConfidence");
  value.throttleConfidence = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_Corrections_Blob_SpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct RTCM_Corrections_Blob_SpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "headingConfidence");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.headingConfidence);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.speedConfidence);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "throttleConfidence");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.throttleConfidence);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_CorrectionsSpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct RTCM_CorrectionsSpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_SpeedandHeadingandThrottleConfidence");
  GetRTCM_Corrections_Blob_SpeedandHeadingandThrottleConfidenceParams(packetHandle, value._Blob_SpeedandHeadingandThrottleConfidence, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_CorrectionsSpeedandHeadingandThrottleConfidenceParams(LONG packetHandle, struct RTCM_CorrectionsSpeedandHeadingandThrottleConfidence value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_SpeedandHeadingandThrottleConfidence");
  SetRTCM_Corrections_Blob_SpeedandHeadingandThrottleConfidenceParams(packetHandle, value._Blob_SpeedandHeadingandThrottleConfidence, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_CorrectionsFullPositionVectorParams(LONG packetHandle, struct RTCM_CorrectionsFullPositionVector value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "utcTime");
  value.utcTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.utcTime.isValidFlag==1)
  {
    GetRTCM_CorrectionsDDateTimeParams(packetHandle, value.utcTime, newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.elevation.isValidFlag==1)
  {
    value.elevation.isValidFlag = 1;
    value.elevation.stringLength = C2xGetTokenData(packetHandle, "RTCM_Corrections", newPath, elcount(value.elevation.string), value.elevation.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  value.heading.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.heading.isValidFlag==1)
  {
    value.heading.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.speed.isValidFlag==1)
  {
    value.speed.isValidFlag = 1;
    value.speed.stringLength = C2xGetTokenData(packetHandle, "RTCM_Corrections", newPath, elcount(value.speed.string), value.speed.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  value.posAccuracy.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.posAccuracy.isValidFlag==1)
  {
    value.posAccuracy.isValidFlag = 1;
    value.posAccuracy.stringLength = C2xGetTokenData(packetHandle, "RTCM_Corrections", newPath, elcount(value.posAccuracy.string), value.posAccuracy.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeConfidence");
  value.timeConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.timeConfidence.isValidFlag==1)
  {
    value.timeConfidence.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posConfidence");
  value.posConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.posConfidence.isValidFlag==1)
  {
    value.posConfidence.isValidFlag = 1;
    value.posConfidence.stringLength = C2xGetTokenData(packetHandle, "RTCM_Corrections", newPath, elcount(value.posConfidence.string), value.posConfidence.string);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  value.speedConfidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.speedConfidence.isValidFlag==1)
  {
    value.speedConfidence.isValidFlag = 1;
    value.speedConfidence.stringLength = C2xGetTokenData(packetHandle, "RTCM_Corrections", newPath, elcount(value.speedConfidence.string), value.speedConfidence.string);
  }
  return result;
}

int SetRTCM_CorrectionsFullPositionVectorParams(LONG packetHandle, struct RTCM_CorrectionsFullPositionVector value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "utcTime");
  if(value.utcTime.isValidFlag==1)
  {
    SetRTCM_CorrectionsDDateTimeParams(packetHandle, value.utcTime, newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.lon);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.lat);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  if(value.elevation.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "RTCM_Corrections", newPath, value.elevation.stringLength, value.elevation.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "heading");
  if(value.heading.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.heading.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  if(value.speed.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "RTCM_Corrections", newPath, value.speed.stringLength, value.speed.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posAccuracy");
  if(value.posAccuracy.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "RTCM_Corrections", newPath, value.posAccuracy.stringLength, value.posAccuracy.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeConfidence");
  if(value.timeConfidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.timeConfidence.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posConfidence");
  if(value.posConfidence.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "RTCM_Corrections", newPath, value.posConfidence.stringLength, value.posConfidence.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedConfidence");
  if(value.speedConfidence.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "RTCM_Corrections", newPath, value.speedConfidence.stringLength, value.speedConfidence.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  return result;
}

int GetRTCM_Corrections_Blob_AntennaOffsetSetParams(LONG packetHandle, struct RTCM_Corrections_Blob_AntennaOffsetSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "antOffsetX");
  value.antOffsetX = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "antOffsetY");
  value.antOffsetY = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "antOffsetZ");
  value.antOffsetZ = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_Corrections_Blob_AntennaOffsetSetParams(LONG packetHandle, struct RTCM_Corrections_Blob_AntennaOffsetSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "antOffsetX");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.antOffsetX);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "antOffsetY");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.antOffsetY);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "antOffsetZ");
  C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.antOffsetZ);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_Corrections_Blob_RTCMHeaderParams(LONG packetHandle, struct RTCM_Corrections_Blob_RTCMHeader value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
  value.status.isValidFlag = 1;
  value.status.stringLength = C2xGetTokenLengthBit(packetHandle, "RTCM_Corrections", newPath);
  if ((result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result))==0)
  {
    for(j=0; j<value.status.stringLength; j++)
    {
      if(C2xGetTokenBitOfBitString(packetHandle, "RTCM_Corrections", newPath, j) == 0)
      {
        value.status.string[j] = '0';
      }
      else
      {
        value.status.string[j] = '1';
      }
      result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetSet");
  GetRTCM_Corrections_Blob_AntennaOffsetSetParams(packetHandle, value.offsetSet, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_Corrections_Blob_RTCMHeaderParams(LONG packetHandle, struct RTCM_Corrections_Blob_RTCMHeader value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
    for(j=0; j<value.status.stringLength; j++)
    {
      if(value.status.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "RTCM_Corrections", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "RTCM_Corrections", newPath, j, 1);
      }
      result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetSet");
  SetRTCM_Corrections_Blob_AntennaOffsetSetParams(packetHandle, value.offsetSet, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_CorrectionsRTCMHeaderParams(LONG packetHandle, struct RTCM_CorrectionsRTCMHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_RTCMHeader");
  GetRTCM_Corrections_Blob_RTCMHeaderParams(packetHandle, value._Blob_RTCMHeader, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int SetRTCM_CorrectionsRTCMHeaderParams(LONG packetHandle, struct RTCM_CorrectionsRTCMHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_RTCMHeader");
  SetRTCM_Corrections_Blob_RTCMHeaderParams(packetHandle, value._Blob_RTCMHeader, newPath);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int GetRTCM_CorrectionsRTCMmsgParams(LONG packetHandle, struct RTCM_CorrectionsRTCMmsg value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rev");
  value.rev.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.rev.isValidFlag==1)
  {
    value.rev.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rtcmID");
  value.rtcmID.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath);
  if(value.rtcmID.isValidFlag==1)
  {
    value.rtcmID.value = C2xGetTokenInt(packetHandle, "RTCM_Corrections", newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "payload");
  value.payload.stringLength = C2xGetTokenData(packetHandle, "RTCM_Corrections", newPath, elcount(value.payload.string), value.payload.string);
  return result;
}

int SetRTCM_CorrectionsRTCMmsgParams(LONG packetHandle, struct RTCM_CorrectionsRTCMmsg value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rev");
  if(value.rev.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.rev.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rtcmID");
  if(value.rtcmID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "RTCM_Corrections", newPath, value.rtcmID.value);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", newPath) )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "payload");
  C2xSetTokenData(packetHandle, "RTCM_Corrections", newPath, value.payload.stringLength, value.payload.string);

  return result;
}

int GetRTCM_Corrections_RTCM_Corrections_rtcmSetsParams(LONG packetHandle, struct RTCM_Corrections_RTCM_Corrections_rtcmSets value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "RTCM_Corrections", oldPath);
  if((result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetRTCM_CorrectionsRTCMmsgParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetRTCM_Corrections_RTCM_Corrections_rtcmSetsParams(LONG packetHandle, struct RTCM_Corrections_RTCM_Corrections_rtcmSets value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "RTCM_Corrections", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetRTCM_CorrectionsRTCMmsgParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);
  }
  return result;
}

int API_GetRTCM_CorrectionsParams(LONG packetHandle, struct RTCM_Corrections value)
{
  int result;
  result = 0;

  value.msgID = C2xGetTokenInt(packetHandle, "RTCM_Corrections", "msgID");
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  value.msgCnt = C2xGetTokenInt(packetHandle, "RTCM_Corrections", "msgCnt");
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  value.rev = C2xGetTokenInt(packetHandle, "RTCM_Corrections", "rev");
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  value.anchorPoint.isValidFlag = C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", "anchorPoint");
  if(value.anchorPoint.isValidFlag == 1)
  {
    value.anchorPoint.isValidFlag = 1;
    GetRTCM_CorrectionsFullPositionVectorParams(packetHandle, value.anchorPoint, "anchorPoint");
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  }
  value.rtcmHeader.isValidFlag = 1;
  GetRTCM_CorrectionsRTCMHeaderParams(packetHandle, value.rtcmHeader, "rtcmHeader");
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  value.rtcmSets.isValidFlag = 1;
  GetRTCM_Corrections_RTCM_Corrections_rtcmSetsParams(packetHandle, value.rtcmSets, "rtcmSets");
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

int API_SetRTCM_CorrectionsParams(LONG packetHandle, struct RTCM_Corrections value)
{
  int result;
  result = 0;

  value.msgID = 12;

  C2xSetTokenInt(packetHandle, "RTCM_Corrections", "msgID", value.msgID);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  C2xSetTokenInt(packetHandle, "RTCM_Corrections", "msgCnt", value.msgCnt);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  C2xSetTokenInt(packetHandle, "RTCM_Corrections", "rev", value.rev);
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  if (value.anchorPoint.isValidFlag==1)
  {
    SetRTCM_CorrectionsFullPositionVectorParams(packetHandle, value.anchorPoint, "anchorPoint");
    result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "RTCM_Corrections", "anchorPoint") )
    {
      C2xRemoveToken(packetHandle, "RTCM_Corrections", "anchorPoint");
    }
  }

  SetRTCM_CorrectionsRTCMHeaderParams(packetHandle, value.rtcmHeader, "rtcmHeader");
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  SetRTCM_Corrections_RTCM_Corrections_rtcmSetsParams(packetHandle, value.rtcmSets, "rtcmSets");
  result = CheckLastError("RTCM_Corrections", gkFuncRefGet, result);

  return result;
}

