/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct UPERframeMAP payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitUPERframeMAPPacket();
//  if (packetHandle!=0) {
//    if (API_SetUPERframeMAPParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    struct UPERframeMAPDescriptiveName {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[64];
        INT  stringLength;
    };
    
    struct UPERframeMAPIntersectionReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct UPERframeMAP_REGION_Reg_Position3D {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPPosition3D_2 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lat;  // INTEGER, -900000000..900000001;
        LONG lon;  // INTEGER, -1799999999..1800000001;
        struct OPT_LONG_ASN elevation;  // INTEGER, OPTIONAL, -4096..61439;
        struct UPERframeMAP_REGION_Reg_Position3D regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeMAPRegulatorySpeedLimit {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT type;  // ENUMERATED, unknown(0), maxSpeedInSchoolZone(1), maxSpeedInSchoolZoneWhenChildrenArePresent(2), maxSpeedInConstructionZone(3), vehicleMinSpeed(4), vehicleMaxSpeed(5), vehicleNightMaxSpeed(6), truckMinSpeed(7), truckMaxSpeed(8), truckNightMaxSpeed(9), vehiclesWithTrailersMinSpeed(10), vehiclesWithTrailersMaxSpeed(11), vehiclesWithTrailersNightMaxSpeed(12);
        WORD speed;  // INTEGER, 0..8191;
    };
    
    struct UPERframeMAPSpeedLimitList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPRegulatorySpeedLimit arrayValue[9];  // SEQUENCE;
    };
    
    struct UPERframeMAPLaneDirection {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneSharing {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[11];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneAttributes_Vehicle {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneAttributes_Crosswalk {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneAttributes_Bike {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneAttributes_Sidewalk {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneAttributes_Barrier {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneAttributes_Striping {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneAttributes_TrackedVehicle {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneAttributes_Parking {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct UPERframeMAPLaneTypeAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct UPERframeMAPLaneAttributes_Vehicle vehicle;  // BITSTRING;
        struct UPERframeMAPLaneAttributes_Crosswalk crosswalk;  // BITSTRING;
        struct UPERframeMAPLaneAttributes_Bike bikeLane;  // BITSTRING;
        struct UPERframeMAPLaneAttributes_Sidewalk sidewalk;  // BITSTRING;
        struct UPERframeMAPLaneAttributes_Barrier median;  // BITSTRING;
        struct UPERframeMAPLaneAttributes_Striping striping;  // BITSTRING;
        struct UPERframeMAPLaneAttributes_TrackedVehicle trackedVehicle;  // BITSTRING;
        struct UPERframeMAPLaneAttributes_Parking parking;  // BITSTRING;
    };
    
    struct UPERframeMAP_REGION_Reg_LaneAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPLaneAttributes {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeMAPLaneDirection directionalUse;  // BITSTRING;
        struct UPERframeMAPLaneSharing sharedWith;  // BITSTRING;
        struct UPERframeMAPLaneTypeAttributes laneType;  // CHOICE;
        struct UPERframeMAP_REGION_Reg_LaneAttributes regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeMAPAllowedManeuvers {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[13];
        INT  stringLength;
    };
    
    struct UPERframeMAPNode_XY_20b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -512..511;
        INT y;  // INTEGER, -512..511;
    };
    
    struct UPERframeMAPNode_XY_22b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -1024..1023;
        INT y;  // INTEGER, -1024..1023;
    };
    
    struct UPERframeMAPNode_XY_24b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -2048..2047;
        INT y;  // INTEGER, -2048..2047;
    };
    
    struct UPERframeMAPNode_XY_26b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -4096..4095;
        INT y;  // INTEGER, -4096..4095;
    };
    
    struct UPERframeMAPNode_XY_28b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -8192..8191;
        INT y;  // INTEGER, -8192..8191;
    };
    
    struct UPERframeMAPNode_XY_32b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -32768..32767;
        INT y;  // INTEGER, -32768..32767;
    };
    
    struct UPERframeMAPNode_LLmD_64b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -1799999999..1800000001;
        LONG lat;  // INTEGER, -900000000..900000001;
    };
    
    struct UPERframeMAP_REGION_Reg_NodeOffsetPoint {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPNodeOffsetPoint {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct UPERframeMAPNode_XY_20b node_XY1;  // SEQUENCE;
        struct UPERframeMAPNode_XY_22b node_XY2;  // SEQUENCE;
        struct UPERframeMAPNode_XY_24b node_XY3;  // SEQUENCE;
        struct UPERframeMAPNode_XY_26b node_XY4;  // SEQUENCE;
        struct UPERframeMAPNode_XY_28b node_XY5;  // SEQUENCE;
        struct UPERframeMAPNode_XY_32b node_XY6;  // SEQUENCE;
        struct UPERframeMAPNode_LLmD_64b node_LatLon;  // SEQUENCE;
        struct UPERframeMAP_REGION_Reg_NodeOffsetPoint node_Regional;  // SEQUENCE;
    };
    
    struct UPERframeMAPNodeAttributeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        INT arrayValue[8];  // ENUMERATED, reserved(0), stopLine(1), roundedCapStyleA(2), roundedCapStyleB(3), mergePoint(4), divergePoint(5), downstreamStopLine(6), downstreamStartNode(7), closedToTraffic(8), safeIsland(9), curbPresentAtStepOff(10), hydrantPresent(11);
    };
    
    struct UPERframeMAPSegmentAttributeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        INT arrayValue[8];  // ENUMERATED, reserved(0), doNotBlock(1), whiteLine(2), mergingLaneLeft(3), mergingLaneRight(4), curbOnLeft(5), curbOnRight(6), loadingzoneOnLeft(7), loadingzoneOnRight(8), turnOutPointOnLeft(9), turnOutPointOnRight(10), adjacentParkingOnLeft(11), adjacentParkingOnRight(12), adjacentBikeLaneOnLeft(13), adjacentBikeLaneOnRight(14), sharedBikeLane(15), bikeBoxInFront(16), transitStopOnLeft(17), transitStopOnRight(18), transitStopInLane(19), sharedWithTrackedVehicle(20), safeIsland(21), lowCurbsPresent(22), rumbleStripPresent(23), audibleSignalingPresent(24), adaptiveTimingPresent(25), rfSignalRequestPresent(26), partialCurbIntrusion(27), taperToLeft(28), taperToRight(29), taperToCenterLine(30), parallelParking(31), headInParking(32), freeParking(33), timeRestrictionsOnParking(34), costToPark(35), midBlockCurbPresent(36), unEvenPavementPresent(37);
    };
    
    struct UPERframeMAP_REGION_Reg_LaneDataAttribute {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPLaneDataAttribute {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT pathEndPointAngle;  // INTEGER, -150..150;
        INT laneCrownPointCenter;  // INTEGER, -128..127;
        INT laneCrownPointLeft;  // INTEGER, -128..127;
        INT laneCrownPointRight;  // INTEGER, -128..127;
        INT laneAngle;  // INTEGER, -180..180;
        struct UPERframeMAPSpeedLimitList speedLimits;  // SEQUENCEOF;
        struct UPERframeMAP_REGION_Reg_LaneDataAttribute regional;  // SEQUENCE;
    };
    
    struct UPERframeMAPLaneDataAttributeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPLaneDataAttribute arrayValue[8];  // CHOICE;
    };
    
    struct UPERframeMAP_REGION_Reg_NodeAttribute {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPRegionalNodeAttributeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAP_REGION_Reg_NodeAttribute arrayValue[8];  // SEQUENCE;
    };
    
    struct UPERframeMAPNodeAttributeSet {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeMAPNodeAttributeList localNode;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPSegmentAttributeList disabled;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPSegmentAttributeList enabled;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPLaneDataAttributeList data;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPRegionalNodeAttributeList regional;  // SEQUENCEOF, OPTIONAL;
        struct OPT_INT_ASN dWidth;  // INTEGER, OPTIONAL, -512..511;
        struct OPT_INT_ASN dElevation;  // INTEGER, OPTIONAL, -512..511;
    };
    
    struct UPERframeMAPNode {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeMAPNodeOffsetPoint delta;  // CHOICE;
        struct UPERframeMAPNodeAttributeSet attributes;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeMAPNodeSet {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPNode arrayValue[63];  // SEQUENCE;
    };
    
    struct UPERframeMAP_ComputedLane_offsetXaxis {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT small;  // INTEGER, -2047..2047;
        INT large;  // INTEGER, -32767..32767;
    };
    
    struct UPERframeMAP_ComputedLane_offsetYaxis {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT small;  // INTEGER, -2047..2047;
        INT large;  // INTEGER, -32767..32767;
    };
    
    struct UPERframeMAP_REGION_Reg_ComputedLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPComputedLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE referenceLaneId;  // INTEGER, 0..255;
        struct UPERframeMAP_ComputedLane_offsetXaxis offsetXaxis;  // CHOICE;
        struct UPERframeMAP_ComputedLane_offsetYaxis offsetYaxis;  // CHOICE;
        struct OPT_WORD_ASN rotateXY;  // INTEGER, OPTIONAL, 0..28800;
        struct OPT_INT_ASN scaleXaxis;  // INTEGER, OPTIONAL, -2048..2047;
        struct OPT_INT_ASN scaleYaxis;  // INTEGER, OPTIONAL, -2048..2047;
        struct UPERframeMAP_REGION_Reg_ComputedLane regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeMAPNodeList2 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct UPERframeMAPNodeSet nodes;  // SEQUENCEOF;
        struct UPERframeMAPComputedLane computed;  // SEQUENCE;
    };
    
    struct UPERframeMAPConnectingLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE lane;  // INTEGER, 0..255;
        struct UPERframeMAPAllowedManeuvers maneuver;  // BITSTRING, OPTIONAL;
    };
    
    struct UPERframeMAPConnection {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeMAPConnectingLane connectingLane;  // SEQUENCE;
        struct UPERframeMAPIntersectionReferenceID remoteIntersection;  // SEQUENCE, OPTIONAL;
        struct OPT_BYTE_ASN signalGroup;  // INTEGER, OPTIONAL, 0..255;
        struct OPT_BYTE_ASN userClass;  // INTEGER, OPTIONAL, 0..255;
        struct OPT_BYTE_ASN connectionID;  // INTEGER, OPTIONAL, 0..255;
    };
    
    struct UPERframeMAPConnectsToList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPConnection arrayValue[16];  // SEQUENCE;
    };
    
    struct UPERframeMAPOverlayLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        BYTE arrayValue[5];  // INTEGER, 0..255;
    };
    
    struct UPERframeMAP_REGION_Reg_GenericLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPGenericLane {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE laneID;  // INTEGER, 0..255;
        struct UPERframeMAPDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct OPT_BYTE_ASN ingressApproach;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_BYTE_ASN egressApproach;  // INTEGER, OPTIONAL, 0..15;
        struct UPERframeMAPLaneAttributes laneAttributes;  // SEQUENCE;
        struct UPERframeMAPAllowedManeuvers maneuvers;  // BITSTRING, OPTIONAL;
        struct UPERframeMAPNodeList2 nodeList;  // CHOICE;
        struct UPERframeMAPConnectsToList connectsTo;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPOverlayLaneList overlays;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAP_REGION_Reg_GenericLane regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeMAPLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPGenericLane arrayValue[255];  // SEQUENCE;
    };
    
    struct UPERframeMAP_REGION_Reg_SignalControlZone {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPPreemptPriorityList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAP_REGION_Reg_SignalControlZone arrayValue[32];  // SEQUENCE;
    };
    
    struct UPERframeMAP_REGION_Reg_Intersection {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPIntersectionGeometry {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeMAPDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct UPERframeMAPIntersectionReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct UPERframeMAPPosition3D_2 refPoint;  // SEQUENCE;
        struct OPT_WORD_ASN laneWidth;  // INTEGER, OPTIONAL, 0..32767;
        struct UPERframeMAPSpeedLimitList speedLimits;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPLaneList laneSet;  // SEQUENCEOF;
        struct UPERframeMAPPreemptPriorityList preemptPriorityData;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAP_REGION_Reg_Intersection regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeMAPIntersectionGeometryList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPIntersectionGeometry arrayValue[32];  // SEQUENCE;
    };
    
    struct UPERframeMAPRoadSegmentReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct UPERframeMAPRoadLaneSetList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPGenericLane arrayValue[255];  // SEQUENCE;
    };
    
    struct UPERframeMAP_REGION_Reg_RoadSegment {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPRoadSegment {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeMAPDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct UPERframeMAPRoadSegmentReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct UPERframeMAPPosition3D_2 refPoint;  // SEQUENCE;
        struct OPT_WORD_ASN laneWidth;  // INTEGER, OPTIONAL, 0..32767;
        struct UPERframeMAPSpeedLimitList speedLimits;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPRoadLaneSetList roadLaneSet;  // SEQUENCEOF;
        struct UPERframeMAP_REGION_Reg_RoadSegment regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct UPERframeMAPRoadSegmentList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPRoadSegment arrayValue[32];  // SEQUENCE;
    };
    
    struct UPERframeMAP_DataParameters_processMethod {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct UPERframeMAP_DataParameters_processAgency {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct UPERframeMAP_DataParameters_lastCheckedDate {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct UPERframeMAP_DataParameters_geoidUsed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[256];
        INT  stringLength;
    };
    
    struct UPERframeMAPDataParameters {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct UPERframeMAP_DataParameters_processMethod processMethod;  // IA5STRING, OPTIONAL;
        struct UPERframeMAP_DataParameters_processAgency processAgency;  // IA5STRING, OPTIONAL;
        struct UPERframeMAP_DataParameters_lastCheckedDate lastCheckedDate;  // IA5STRING, OPTIONAL;
        struct UPERframeMAP_DataParameters_geoidUsed geoidUsed;  // IA5STRING, OPTIONAL;
    };
    
    struct UPERframeMAP_REGION_Reg_RestrictionUserType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAPRestrictionUserType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        INT basicType;  // ENUMERATED, none(0), equippedTransit(1), equippedTaxis(2), equippedOther(3), emissionCompliant(4), equippedBicycle(5), weightCompliant(6), heightCompliant(7), pedestrians(8), slowMovingPersons(9), wheelchairUsers(10), visualDisabilities(11), audioDisabilities(12), otherUnknownDisabilities(13);
        struct UPERframeMAP_REGION_Reg_RestrictionUserType regional;  // SEQUENCE;
    };
    
    struct UPERframeMAPRestrictionUserTypeList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPRestrictionUserType arrayValue[16];  // CHOICE;
    };
    
    struct UPERframeMAPRestrictionClassAssignment {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE id;  // INTEGER, 0..255;
        struct UPERframeMAPRestrictionUserTypeList users;  // SEQUENCEOF;
    };
    
    struct UPERframeMAPRestrictionClassList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct UPERframeMAPRestrictionClassAssignment arrayValue[254];  // SEQUENCE;
    };
    
    struct UPERframeMAP_REGION_Reg_MapData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
    };
    
    struct UPERframeMAP_Blob_MsgCRC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD msgCRC;  // INTEGER, 0..65535;
    };
    
    struct UPERframeMAPMsgCRC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[3];
        INT  stringLength;
        struct UPERframeMAP_Blob_MsgCRC _Blob_MsgCRC;  // SEQUENCE;
    };
    
    struct UPERframeMAPMapData {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE msgID;  // INTEGER, 0..255, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollisionAlert_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData_P(18), signalPhaseAndTimingMessage_P(19);
        struct OPT_BYTE_ASN msgSubID;  // INTEGER, OPTIONAL, 0..255;
        BYTE msgIssueRevision;  // INTEGER, 0..127;
        struct OPT_ENUM_ASN layerType;  // ENUMERATED, OPTIONAL, none(0), mixedContent(1), generalMapData(2), intersectionData(3), curveData(4), roadwaySectionData(5), parkingAreaData(6), sharedLaneData(7);
        struct OPT_BYTE_ASN layerID;  // INTEGER, OPTIONAL, 0..100;
        struct UPERframeMAPIntersectionGeometryList intersections;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPRoadSegmentList roadSegments;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAPDataParameters dataParameters;  // SEQUENCE, OPTIONAL;
        struct UPERframeMAPRestrictionClassList restrictionList;  // SEQUENCEOF, OPTIONAL;
        struct UPERframeMAP_REGION_Reg_MapData regional;  // SEQUENCE, OPTIONAL;
        struct UPERframeMAPMsgCRC crc;  // OCTETSTRING, OPTIONAL;
    };
    
    struct UPERframeMAPUPER_BlobMAP {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[1024];
        INT  stringLength;
        struct UPERframeMAPMapData MapData;  // SEQUENCE;
    };
    
    struct UPERframeMAP {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE msgID;  // INTEGER, 0..255, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollisionAlert_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData_P(18), signalPhaseAndTimingMessage_P(19);
        struct OPT_BYTE_ASN msgSubID;  // INTEGER, OPTIONAL, 0..255;
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        BYTE contentID;  // INTEGER, 0..255, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollisionAlert_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData_P(18), signalPhaseAndTimingMessage_P(19);
        struct UPERframeMAPUPER_BlobMAP msgBlob;  // OCTETSTRING;
        struct UPERframeMAPMsgCRC crc;  // OCTETSTRING, OPTIONAL;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitUPERframeMAPPacket()
{
  return C2xInitPacket("UPERframeMAP"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitUPERframeMAPPacket(struct UPERframeMAP msgStruct)
{
  long pktHandle;

  pktHandle = API_InitUPERframeMAPPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetUPERframeMAPParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitUPERframeMAPPacket(struct UPERframeMAP msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("UPERframeMAP", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetUPERframeMAPParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetUPERframeMAPIntersectionReferenceIDParams(LONG packetHandle, struct UPERframeMAPIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPIntersectionReferenceIDParams(LONG packetHandle, struct UPERframeMAPIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.region.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.id);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPPosition3D_2Params(LONG packetHandle, struct UPERframeMAPPosition3D_2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  value.elevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.elevation.isValidFlag==1)
  {
    value.elevation.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeMAPPosition3D_2Params(LONG packetHandle, struct UPERframeMAPPosition3D_2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.lat);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.lon);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "elevation");
  if(value.elevation.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.elevation.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPRegulatorySpeedLimitParams(LONG packetHandle, struct UPERframeMAPRegulatorySpeedLimit value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  value.type = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPRegulatorySpeedLimitParams(LONG packetHandle, struct UPERframeMAPRegulatorySpeedLimit value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.type);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.speed);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPSpeedLimitListParams(LONG packetHandle, struct UPERframeMAPSpeedLimitList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPRegulatorySpeedLimitParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPSpeedLimitListParams(LONG packetHandle, struct UPERframeMAPSpeedLimitList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPRegulatorySpeedLimitParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPLaneTypeAttributesParams(LONG packetHandle, struct UPERframeMAPLaneTypeAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicle");
      value.vehicle.isValidFlag = 1;
      value.vehicle.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
      if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.vehicle.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.vehicle.string[j] = '0';
          }
          else
          {
            value.vehicle.string[j] = '1';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crosswalk");
      value.crosswalk.isValidFlag = 1;
      value.crosswalk.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
      if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.crosswalk.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.crosswalk.string[j] = '0';
          }
          else
          {
            value.crosswalk.string[j] = '1';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "bikeLane");
      value.bikeLane.isValidFlag = 1;
      value.bikeLane.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
      if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.bikeLane.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.bikeLane.string[j] = '0';
          }
          else
          {
            value.bikeLane.string[j] = '1';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sidewalk");
      value.sidewalk.isValidFlag = 1;
      value.sidewalk.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
      if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.sidewalk.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.sidewalk.string[j] = '0';
          }
          else
          {
            value.sidewalk.string[j] = '1';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "median");
      value.median.isValidFlag = 1;
      value.median.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
      if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.median.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.median.string[j] = '0';
          }
          else
          {
            value.median.string[j] = '1';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "striping");
      value.striping.isValidFlag = 1;
      value.striping.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
      if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.striping.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.striping.string[j] = '0';
          }
          else
          {
            value.striping.string[j] = '1';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trackedVehicle");
      value.trackedVehicle.isValidFlag = 1;
      value.trackedVehicle.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
      if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.trackedVehicle.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.trackedVehicle.string[j] = '0';
          }
          else
          {
            value.trackedVehicle.string[j] = '1';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "parking");
      value.parking.isValidFlag = 1;
      value.parking.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
      if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
      {
        for(j=0; j<value.parking.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.parking.string[j] = '0';
          }
          else
          {
            value.parking.string[j] = '1';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }

      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetUPERframeMAPLaneTypeAttributesParams(LONG packetHandle, struct UPERframeMAPLaneTypeAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicle");
      for(j=0; j<value.vehicle.stringLength; j++)
      {
        if(value.vehicle.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crosswalk");
      for(j=0; j<value.crosswalk.stringLength; j++)
      {
        if(value.crosswalk.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "bikeLane");
      for(j=0; j<value.bikeLane.stringLength; j++)
      {
        if(value.bikeLane.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sidewalk");
      for(j=0; j<value.sidewalk.stringLength; j++)
      {
        if(value.sidewalk.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "median");
      for(j=0; j<value.median.stringLength; j++)
      {
        if(value.median.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "striping");
      for(j=0; j<value.striping.stringLength; j++)
      {
        if(value.striping.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "trackedVehicle");
      for(j=0; j<value.trackedVehicle.stringLength; j++)
      {
        if(value.trackedVehicle.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "parking");
      for(j=0; j<value.parking.stringLength; j++)
      {
        if(value.parking.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetUPERframeMAPLaneAttributesParams(LONG packetHandle, struct UPERframeMAPLaneAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionalUse");
  value.directionalUse.isValidFlag = 1;
  value.directionalUse.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
  if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    if(value.directionalUse.stringLength > 0)
    {
      for(j=0; j<value.directionalUse.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
        {
          value.directionalUse.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 1)
        {
          value.directionalUse.string[j] = '1';
        }

        if(value.directionalUse.stringLength == 1)
        {
          value.directionalUse.string[1] = '0';
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.directionalUse.stringLength+1; k > -1; k--)
      {
        if(value.directionalUse.string[k] == '1')
        {
          value.directionalUse.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sharedWith");
  value.sharedWith.isValidFlag = 1;
  value.sharedWith.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
  if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    if(value.sharedWith.stringLength > 0)
    {
      for(j=0; j<value.sharedWith.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
        {
          value.sharedWith.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 1)
        {
          value.sharedWith.string[j] = '1';
        }

        if(value.sharedWith.stringLength == 1)
        {
          value.sharedWith.string[1] = '0';
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.sharedWith.stringLength+1; k > -1; k--)
      {
        if(value.sharedWith.string[k] == '1')
        {
          value.sharedWith.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneType");
  GetUPERframeMAPLaneTypeAttributesParams(packetHandle, value.laneType, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPLaneAttributesParams(LONG packetHandle, struct UPERframeMAPLaneAttributes value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "directionalUse");
    for(j=0; j<value.directionalUse.stringLength; j++)
    {
      if(value.directionalUse.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sharedWith");
    for(j=0; j<value.sharedWith.stringLength; j++)
    {
      if(value.sharedWith.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
      }
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneType");
  SetUPERframeMAPLaneTypeAttributesParams(packetHandle, value.laneType, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPNode_XY_20bParams(LONG packetHandle, struct UPERframeMAPNode_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPNode_XY_20bParams(LONG packetHandle, struct UPERframeMAPNode_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.x);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.y);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPNode_XY_22bParams(LONG packetHandle, struct UPERframeMAPNode_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPNode_XY_22bParams(LONG packetHandle, struct UPERframeMAPNode_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.x);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.y);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPNode_XY_24bParams(LONG packetHandle, struct UPERframeMAPNode_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPNode_XY_24bParams(LONG packetHandle, struct UPERframeMAPNode_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.x);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.y);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPNode_XY_26bParams(LONG packetHandle, struct UPERframeMAPNode_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPNode_XY_26bParams(LONG packetHandle, struct UPERframeMAPNode_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.x);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.y);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPNode_XY_28bParams(LONG packetHandle, struct UPERframeMAPNode_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPNode_XY_28bParams(LONG packetHandle, struct UPERframeMAPNode_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.x);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.y);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPNode_XY_32bParams(LONG packetHandle, struct UPERframeMAPNode_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPNode_XY_32bParams(LONG packetHandle, struct UPERframeMAPNode_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.x);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.y);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPNode_LLmD_64bParams(LONG packetHandle, struct UPERframeMAPNode_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPNode_LLmD_64bParams(LONG packetHandle, struct UPERframeMAPNode_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.lon);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.lat);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPNodeOffsetPointParams(LONG packetHandle, struct UPERframeMAPNodeOffsetPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      GetUPERframeMAPNode_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      GetUPERframeMAPNode_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      GetUPERframeMAPNode_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      GetUPERframeMAPNode_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      GetUPERframeMAPNode_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      GetUPERframeMAPNode_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      GetUPERframeMAPNode_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetUPERframeMAPNodeOffsetPointParams(LONG packetHandle, struct UPERframeMAPNodeOffsetPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      SetUPERframeMAPNode_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      SetUPERframeMAPNode_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      SetUPERframeMAPNode_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      SetUPERframeMAPNode_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      SetUPERframeMAPNode_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      SetUPERframeMAPNode_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      SetUPERframeMAPNode_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetUPERframeMAPNodeAttributeListParams(LONG packetHandle, struct UPERframeMAPNodeAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPNodeAttributeListParams(LONG packetHandle, struct UPERframeMAPNodeAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "UPERframeMAP", newPath, value.arrayValue[i]);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPSegmentAttributeListParams(LONG packetHandle, struct UPERframeMAPSegmentAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPSegmentAttributeListParams(LONG packetHandle, struct UPERframeMAPSegmentAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "UPERframeMAP", newPath, value.arrayValue[i]);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPLaneDataAttributeParams(LONG packetHandle, struct UPERframeMAPLaneDataAttribute value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathEndPointAngle");
      value.pathEndPointAngle = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointCenter");
      value.laneCrownPointCenter = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointLeft");
      value.laneCrownPointLeft = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointRight");
      value.laneCrownPointRight = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAngle");
      value.laneAngle = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
      GetUPERframeMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetUPERframeMAPLaneDataAttributeParams(LONG packetHandle, struct UPERframeMAPLaneDataAttribute value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pathEndPointAngle");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.pathEndPointAngle);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointCenter");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.laneCrownPointCenter);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointLeft");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.laneCrownPointLeft);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneCrownPointRight");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.laneCrownPointRight);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAngle");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.laneAngle);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
      SetUPERframeMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetUPERframeMAPLaneDataAttributeListParams(LONG packetHandle, struct UPERframeMAPLaneDataAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPLaneDataAttributeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPLaneDataAttributeListParams(LONG packetHandle, struct UPERframeMAPLaneDataAttributeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPLaneDataAttributeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPNodeAttributeSetParams(LONG packetHandle, struct UPERframeMAPNodeAttributeSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "localNode");
  value.localNode.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.localNode.isValidFlag==1)
  {
    GetUPERframeMAPNodeAttributeListParams(packetHandle, value.localNode, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "disabled");
  value.disabled.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.disabled.isValidFlag==1)
  {
    GetUPERframeMAPSegmentAttributeListParams(packetHandle, value.disabled, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabled");
  value.enabled.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.enabled.isValidFlag==1)
  {
    GetUPERframeMAPSegmentAttributeListParams(packetHandle, value.enabled, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "data");
  value.data.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.data.isValidFlag==1)
  {
    GetUPERframeMAPLaneDataAttributeListParams(packetHandle, value.data, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dWidth");
  value.dWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.dWidth.isValidFlag==1)
  {
    value.dWidth.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dElevation");
  value.dElevation.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.dElevation.isValidFlag==1)
  {
    value.dElevation.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeMAPNodeAttributeSetParams(LONG packetHandle, struct UPERframeMAPNodeAttributeSet value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "localNode");
  if(value.localNode.isValidFlag==1)
  {
    SetUPERframeMAPNodeAttributeListParams(packetHandle, value.localNode, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "disabled");
  if(value.disabled.isValidFlag==1)
  {
    SetUPERframeMAPSegmentAttributeListParams(packetHandle, value.disabled, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabled");
  if(value.enabled.isValidFlag==1)
  {
    SetUPERframeMAPSegmentAttributeListParams(packetHandle, value.enabled, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "data");
  if(value.data.isValidFlag==1)
  {
    SetUPERframeMAPLaneDataAttributeListParams(packetHandle, value.data, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dWidth");
  if(value.dWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.dWidth.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dElevation");
  if(value.dElevation.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.dElevation.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPNodeParams(LONG packetHandle, struct UPERframeMAPNode value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "delta");
  GetUPERframeMAPNodeOffsetPointParams(packetHandle, value.delta, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "attributes");
  value.attributes.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.attributes.isValidFlag==1)
  {
    GetUPERframeMAPNodeAttributeSetParams(packetHandle, value.attributes, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeMAPNodeParams(LONG packetHandle, struct UPERframeMAPNode value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "delta");
  SetUPERframeMAPNodeOffsetPointParams(packetHandle, value.delta, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "attributes");
  if(value.attributes.isValidFlag==1)
  {
    SetUPERframeMAPNodeAttributeSetParams(packetHandle, value.attributes, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPNodeSetParams(LONG packetHandle, struct UPERframeMAPNodeSet value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPNodeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPNodeSetParams(LONG packetHandle, struct UPERframeMAPNodeSet value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPNodeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAP_ComputedLane_offsetXaxisParams(LONG packetHandle, struct UPERframeMAP_ComputedLane_offsetXaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      value.small = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      value.large = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetUPERframeMAP_ComputedLane_offsetXaxisParams(LONG packetHandle, struct UPERframeMAP_ComputedLane_offsetXaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.small);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.large);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetUPERframeMAP_ComputedLane_offsetYaxisParams(LONG packetHandle, struct UPERframeMAP_ComputedLane_offsetYaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      value.small = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      value.large = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetUPERframeMAP_ComputedLane_offsetYaxisParams(LONG packetHandle, struct UPERframeMAP_ComputedLane_offsetYaxis value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "small");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.small);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "large");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.large);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetUPERframeMAPComputedLaneParams(LONG packetHandle, struct UPERframeMAPComputedLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceLaneId");
  value.referenceLaneId = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetXaxis");
  GetUPERframeMAP_ComputedLane_offsetXaxisParams(packetHandle, value.offsetXaxis, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetYaxis");
  GetUPERframeMAP_ComputedLane_offsetYaxisParams(packetHandle, value.offsetYaxis, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rotateXY");
  value.rotateXY.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.rotateXY.isValidFlag==1)
  {
    value.rotateXY.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleXaxis");
  value.scaleXaxis.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.scaleXaxis.isValidFlag==1)
  {
    value.scaleXaxis.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleYaxis");
  value.scaleYaxis.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.scaleYaxis.isValidFlag==1)
  {
    value.scaleYaxis.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeMAPComputedLaneParams(LONG packetHandle, struct UPERframeMAPComputedLane value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "referenceLaneId");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.referenceLaneId);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetXaxis");
  SetUPERframeMAP_ComputedLane_offsetXaxisParams(packetHandle, value.offsetXaxis, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "offsetYaxis");
  SetUPERframeMAP_ComputedLane_offsetYaxisParams(packetHandle, value.offsetYaxis, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rotateXY");
  if(value.rotateXY.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.rotateXY.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleXaxis");
  if(value.scaleXaxis.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.scaleXaxis.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "scaleYaxis");
  if(value.scaleYaxis.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.scaleYaxis.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPNodeList2Params(LONG packetHandle, struct UPERframeMAPNodeList2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
      GetUPERframeMAPNodeSetParams(packetHandle, value.nodes, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "computed");
      GetUPERframeMAPComputedLaneParams(packetHandle, value.computed, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetUPERframeMAPNodeList2Params(LONG packetHandle, struct UPERframeMAPNodeList2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodes");
      SetUPERframeMAPNodeSetParams(packetHandle, value.nodes, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "computed");
      SetUPERframeMAPComputedLaneParams(packetHandle, value.computed, newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetUPERframeMAPConnectingLaneParams(LONG packetHandle, struct UPERframeMAPConnectingLane value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
  value.lane = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuver");
  value.maneuver.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.maneuver.isValidFlag==1)
  {
    value.maneuver.isValidFlag = 1;
    value.maneuver.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
    if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
    {
      if(value.maneuver.stringLength > 0)
      {
        for(j=0; j<value.maneuver.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.maneuver.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 1)
          {
            value.maneuver.string[j] = '1';
          }

          if(value.maneuver.stringLength == 1)
          {
            value.maneuver.string[1] = '0';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.maneuver.stringLength+1; k > -1; k--)
        {
          if(value.maneuver.string[k] == '1')
          {
            value.maneuver.string[k] = '0';
          }
        }
      }
    }

  }
  return result;
}

int SetUPERframeMAPConnectingLaneParams(LONG packetHandle, struct UPERframeMAPConnectingLane value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.lane);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuver");
  if(value.maneuver.isValidFlag==1)
  {
      for(j=0; j<value.maneuver.stringLength; j++)
      {
        if(value.maneuver.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPConnectionParams(LONG packetHandle, struct UPERframeMAPConnection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectingLane");
  GetUPERframeMAPConnectingLaneParams(packetHandle, value.connectingLane, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  value.remoteIntersection.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.remoteIntersection.isValidFlag==1)
  {
    GetUPERframeMAPIntersectionReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  value.signalGroup.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.signalGroup.isValidFlag==1)
  {
    value.signalGroup.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "userClass");
  value.userClass.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.userClass.isValidFlag==1)
  {
    value.userClass.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  value.connectionID.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.connectionID.isValidFlag==1)
  {
    value.connectionID.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeMAPConnectionParams(LONG packetHandle, struct UPERframeMAPConnection value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectingLane");
  SetUPERframeMAPConnectingLaneParams(packetHandle, value.connectingLane, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "remoteIntersection");
  if(value.remoteIntersection.isValidFlag==1)
  {
    SetUPERframeMAPIntersectionReferenceIDParams(packetHandle, value.remoteIntersection, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  if(value.signalGroup.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.signalGroup.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "userClass");
  if(value.userClass.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.userClass.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  if(value.connectionID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.connectionID.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPConnectsToListParams(LONG packetHandle, struct UPERframeMAPConnectsToList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPConnectionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPConnectsToListParams(LONG packetHandle, struct UPERframeMAPConnectsToList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPConnectionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPOverlayLaneListParams(LONG packetHandle, struct UPERframeMAPOverlayLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPOverlayLaneListParams(LONG packetHandle, struct UPERframeMAPOverlayLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "UPERframeMAP", newPath, value.arrayValue[i]);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPGenericLaneParams(LONG packetHandle, struct UPERframeMAPGenericLane value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  value.laneID = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "UPERframeMAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "ingressApproach");
  value.ingressApproach.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.ingressApproach.isValidFlag==1)
  {
    value.ingressApproach.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "egressApproach");
  value.egressApproach.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.egressApproach.isValidFlag==1)
  {
    value.egressApproach.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAttributes");
  GetUPERframeMAPLaneAttributesParams(packetHandle, value.laneAttributes, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuvers");
  value.maneuvers.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.maneuvers.isValidFlag==1)
  {
    value.maneuvers.isValidFlag = 1;
    value.maneuvers.stringLength = C2xGetTokenLengthBit(packetHandle, "UPERframeMAP", newPath);
    if ((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
    {
      if(value.maneuvers.stringLength > 0)
      {
        for(j=0; j<value.maneuvers.stringLength; j++)
        {
          if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 0)
          {
            value.maneuvers.string[j] = '0';
          }
          else if(C2xGetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j) == 1)
          {
            value.maneuvers.string[j] = '1';
          }

          if(value.maneuvers.stringLength == 1)
          {
            value.maneuvers.string[1] = '0';
          }
          result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
        }
      }
      else
      {
        for(k = value.maneuvers.stringLength+1; k > -1; k--)
        {
          if(value.maneuvers.string[k] == '1')
          {
            value.maneuvers.string[k] = '0';
          }
        }
      }
    }

  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodeList");
  GetUPERframeMAPNodeList2Params(packetHandle, value.nodeList, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectsTo");
  value.connectsTo.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.connectsTo.isValidFlag==1)
  {
    GetUPERframeMAPConnectsToListParams(packetHandle, value.connectsTo, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "overlays");
  value.overlays.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.overlays.isValidFlag==1)
  {
    GetUPERframeMAPOverlayLaneListParams(packetHandle, value.overlays, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeMAPGenericLaneParams(LONG packetHandle, struct UPERframeMAPGenericLane value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.laneID);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeMAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "ingressApproach");
  if(value.ingressApproach.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.ingressApproach.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "egressApproach");
  if(value.egressApproach.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.egressApproach.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneAttributes");
  SetUPERframeMAPLaneAttributesParams(packetHandle, value.laneAttributes, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuvers");
  if(value.maneuvers.isValidFlag==1)
  {
      for(j=0; j<value.maneuvers.stringLength; j++)
      {
        if(value.maneuvers.string[j] == '0')
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 0);
        }
        else
        {
          C2xSetTokenBitOfBitString(packetHandle, "UPERframeMAP", newPath, j, 1);
        }
        result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
      }
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodeList");
  SetUPERframeMAPNodeList2Params(packetHandle, value.nodeList, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectsTo");
  if(value.connectsTo.isValidFlag==1)
  {
    SetUPERframeMAPConnectsToListParams(packetHandle, value.connectsTo, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "overlays");
  if(value.overlays.isValidFlag==1)
  {
    SetUPERframeMAPOverlayLaneListParams(packetHandle, value.overlays, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPLaneListParams(LONG packetHandle, struct UPERframeMAPLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPLaneListParams(LONG packetHandle, struct UPERframeMAPLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPIntersectionGeometryParams(LONG packetHandle, struct UPERframeMAPIntersectionGeometry value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "UPERframeMAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetUPERframeMAPIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  GetUPERframeMAPPosition3D_2Params(packetHandle, value.refPoint, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  value.laneWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.laneWidth.isValidFlag==1)
  {
    value.laneWidth.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  value.speedLimits.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.speedLimits.isValidFlag==1)
  {
    GetUPERframeMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneSet");
  GetUPERframeMAPLaneListParams(packetHandle, value.laneSet, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPIntersectionGeometryParams(LONG packetHandle, struct UPERframeMAPIntersectionGeometry value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeMAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetUPERframeMAPIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.revision);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  SetUPERframeMAPPosition3D_2Params(packetHandle, value.refPoint, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  if(value.laneWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.laneWidth.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  if(value.speedLimits.isValidFlag==1)
  {
    SetUPERframeMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneSet");
  SetUPERframeMAPLaneListParams(packetHandle, value.laneSet, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPIntersectionGeometryListParams(LONG packetHandle, struct UPERframeMAPIntersectionGeometryList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPIntersectionGeometryParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPIntersectionGeometryListParams(LONG packetHandle, struct UPERframeMAPIntersectionGeometryList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPIntersectionGeometryParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPRoadSegmentReferenceIDParams(LONG packetHandle, struct UPERframeMAPRoadSegmentReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPRoadSegmentReferenceIDParams(LONG packetHandle, struct UPERframeMAPRoadSegmentReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.region.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.id);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPRoadLaneSetListParams(LONG packetHandle, struct UPERframeMAPRoadLaneSetList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPRoadLaneSetListParams(LONG packetHandle, struct UPERframeMAPRoadLaneSetList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPGenericLaneParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPRoadSegmentParams(LONG packetHandle, struct UPERframeMAPRoadSegment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "UPERframeMAP", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetUPERframeMAPRoadSegmentReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  GetUPERframeMAPPosition3D_2Params(packetHandle, value.refPoint, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  value.laneWidth.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.laneWidth.isValidFlag==1)
  {
    value.laneWidth.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  value.speedLimits.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.speedLimits.isValidFlag==1)
  {
    GetUPERframeMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadLaneSet");
  GetUPERframeMAPRoadLaneSetListParams(packetHandle, value.roadLaneSet, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPRoadSegmentParams(LONG packetHandle, struct UPERframeMAPRoadSegment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeMAP", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetUPERframeMAPRoadSegmentReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.revision);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "refPoint");
  SetUPERframeMAPPosition3D_2Params(packetHandle, value.refPoint, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneWidth");
  if(value.laneWidth.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.laneWidth.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speedLimits");
  if(value.speedLimits.isValidFlag==1)
  {
    SetUPERframeMAPSpeedLimitListParams(packetHandle, value.speedLimits, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadLaneSet");
  SetUPERframeMAPRoadLaneSetListParams(packetHandle, value.roadLaneSet, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPRoadSegmentListParams(LONG packetHandle, struct UPERframeMAPRoadSegmentList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPRoadSegmentParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPRoadSegmentListParams(LONG packetHandle, struct UPERframeMAPRoadSegmentList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPRoadSegmentParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPDataParametersParams(LONG packetHandle, struct UPERframeMAPDataParameters value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processMethod");
  value.processMethod.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.processMethod.isValidFlag==1)
  {
    value.processMethod.stringLength = C2xGetTokenData(packetHandle, "UPERframeMAP", newPath, elcount(value.processMethod.string), value.processMethod.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processAgency");
  value.processAgency.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.processAgency.isValidFlag==1)
  {
    value.processAgency.stringLength = C2xGetTokenData(packetHandle, "UPERframeMAP", newPath, elcount(value.processAgency.string), value.processAgency.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lastCheckedDate");
  value.lastCheckedDate.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.lastCheckedDate.isValidFlag==1)
  {
    value.lastCheckedDate.stringLength = C2xGetTokenData(packetHandle, "UPERframeMAP", newPath, elcount(value.lastCheckedDate.string), value.lastCheckedDate.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "geoidUsed");
  value.geoidUsed.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.geoidUsed.isValidFlag==1)
  {
    value.geoidUsed.stringLength = C2xGetTokenData(packetHandle, "UPERframeMAP", newPath, elcount(value.geoidUsed.string), value.geoidUsed.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int SetUPERframeMAPDataParametersParams(LONG packetHandle, struct UPERframeMAPDataParameters value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processMethod");
  if(value.processMethod.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeMAP", newPath, value.processMethod.stringLength, value.processMethod.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "processAgency");
  if(value.processAgency.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeMAP", newPath, value.processAgency.stringLength, value.processAgency.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lastCheckedDate");
  if(value.lastCheckedDate.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeMAP", newPath, value.lastCheckedDate.stringLength, value.lastCheckedDate.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "geoidUsed");
  if(value.geoidUsed.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeMAP", newPath, value.geoidUsed.stringLength, value.geoidUsed.string);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPRestrictionUserTypeParams(LONG packetHandle, struct UPERframeMAPRestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "basicType");
      value.basicType = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetUPERframeMAPRestrictionUserTypeParams(LONG packetHandle, struct UPERframeMAPRestrictionUserType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "basicType");
      C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.basicType);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetUPERframeMAPRestrictionUserTypeListParams(LONG packetHandle, struct UPERframeMAPRestrictionUserTypeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPRestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPRestrictionUserTypeListParams(LONG packetHandle, struct UPERframeMAPRestrictionUserTypeList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPRestrictionUserTypeParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAPRestrictionClassAssignmentParams(LONG packetHandle, struct UPERframeMAPRestrictionClassAssignment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "users");
  GetUPERframeMAPRestrictionUserTypeListParams(packetHandle, value.users, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPRestrictionClassAssignmentParams(LONG packetHandle, struct UPERframeMAPRestrictionClassAssignment value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.id);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "users");
  SetUPERframeMAPRestrictionUserTypeListParams(packetHandle, value.users, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPRestrictionClassListParams(LONG packetHandle, struct UPERframeMAPRestrictionClassList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "UPERframeMAP", oldPath);
  if((result = CheckLastError("UPERframeMAP", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetUPERframeMAPRestrictionClassAssignmentParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetUPERframeMAPRestrictionClassListParams(LONG packetHandle, struct UPERframeMAPRestrictionClassList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "UPERframeMAP", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetUPERframeMAPRestrictionClassAssignmentParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  return result;
}

int GetUPERframeMAP_Blob_MsgCRCParams(LONG packetHandle, struct UPERframeMAP_Blob_MsgCRC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCRC");
  value.msgCRC = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAP_Blob_MsgCRCParams(LONG packetHandle, struct UPERframeMAP_Blob_MsgCRC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgCRC");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.msgCRC);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPMsgCRCParams(LONG packetHandle, struct UPERframeMAPMsgCRC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_MsgCRC");
  GetUPERframeMAP_Blob_MsgCRCParams(packetHandle, value._Blob_MsgCRC, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPMsgCRCParams(LONG packetHandle, struct UPERframeMAPMsgCRC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "_Blob_MsgCRC");
  SetUPERframeMAP_Blob_MsgCRCParams(packetHandle, value._Blob_MsgCRC, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int GetUPERframeMAPMapDataParams(LONG packetHandle, struct UPERframeMAPMapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgID");
  value.msgID = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgSubID");
  value.msgSubID.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.msgSubID.isValidFlag==1)
  {
    value.msgSubID.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgIssueRevision");
  value.msgIssueRevision = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerType");
  value.layerType.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.layerType.isValidFlag==1)
  {
    value.layerType.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerID");
  value.layerID.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.layerID.isValidFlag==1)
  {
    value.layerID.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  value.intersections.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.intersections.isValidFlag==1)
  {
    GetUPERframeMAPIntersectionGeometryListParams(packetHandle, value.intersections, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadSegments");
  value.roadSegments.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.roadSegments.isValidFlag==1)
  {
    GetUPERframeMAPRoadSegmentListParams(packetHandle, value.roadSegments, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dataParameters");
  value.dataParameters.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.dataParameters.isValidFlag==1)
  {
    GetUPERframeMAPDataParametersParams(packetHandle, value.dataParameters, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restrictionList");
  value.restrictionList.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.restrictionList.isValidFlag==1)
  {
    GetUPERframeMAPRestrictionClassListParams(packetHandle, value.restrictionList, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crc");
  value.crc.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath);
  if(value.crc.isValidFlag==1)
  {
    value.crc.isValidFlag = 1;
    value.crc.stringLength = C2xGetTokenData(packetHandle, "UPERframeMAP", newPath, elcount(value.crc.string), value.crc.string);
  }
  return result;
}

int SetUPERframeMAPMapDataParams(LONG packetHandle, struct UPERframeMAPMapData value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgID");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.msgID);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgSubID");
  if(value.msgSubID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.msgSubID.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "msgIssueRevision");
  C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.msgIssueRevision);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerType");
  if(value.layerType.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.layerType.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "layerID");
  if(value.layerID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", newPath, value.layerID.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  if(value.intersections.isValidFlag==1)
  {
    SetUPERframeMAPIntersectionGeometryListParams(packetHandle, value.intersections, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "roadSegments");
  if(value.roadSegments.isValidFlag==1)
  {
    SetUPERframeMAPRoadSegmentListParams(packetHandle, value.roadSegments, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "dataParameters");
  if(value.dataParameters.isValidFlag==1)
  {
    SetUPERframeMAPDataParametersParams(packetHandle, value.dataParameters, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "restrictionList");
  if(value.restrictionList.isValidFlag==1)
  {
    SetUPERframeMAPRestrictionClassListParams(packetHandle, value.restrictionList, newPath);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "crc");
  if(value.crc.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "UPERframeMAP", newPath, value.crc.stringLength, value.crc.string);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", newPath) )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", newPath);
    }
  }

  return result;
}

int GetUPERframeMAPUPER_BlobMAPParams(LONG packetHandle, struct UPERframeMAPUPER_BlobMAP value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "MapData");
  GetUPERframeMAPMapDataParams(packetHandle, value.MapData, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int SetUPERframeMAPUPER_BlobMAPParams(LONG packetHandle, struct UPERframeMAPUPER_BlobMAP value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "MapData");
  SetUPERframeMAPMapDataParams(packetHandle, value.MapData, newPath);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  return result;
}

int API_GetUPERframeMAPParams(LONG packetHandle, struct UPERframeMAP value)
{
  int result;
  result = 0;

  value.msgID = C2xGetTokenInt(packetHandle, "UPERframeMAP", "msgID");
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  value.msgSubID.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", "msgSubID");
  if(value.msgSubID.isValidFlag == 1)
  {
    value.msgSubID.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", "msgSubID");
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  }
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", "timeStamp");
  if(value.timeStamp.isValidFlag == 1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "UPERframeMAP", "timeStamp");
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  }
  value.contentID = C2xGetTokenInt(packetHandle, "UPERframeMAP", "contentID");
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  value.msgBlob.isValidFlag = 1;
  GetUPERframeMAPUPER_BlobMAPParams(packetHandle, value.msgBlob, "msgBlob");
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  value.crc.isValidFlag = C2xIsTokenAvailable(packetHandle, "UPERframeMAP", "crc");
  if(value.crc.isValidFlag == 1)
  {
    value.crc.isValidFlag = 1;
    GetUPERframeMAPMsgCRCParams(packetHandle, value.crc, "crc");
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  }
  return result;
}

int API_SetUPERframeMAPParams(LONG packetHandle, struct UPERframeMAP value)
{
  int result;
  result = 0;

  value.msgID = 17;

  C2xSetTokenInt(packetHandle, "UPERframeMAP", "msgID", value.msgID);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  if (value.msgSubID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", "msgSubID", value.msgSubID.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", "msgSubID") )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", "msgSubID");
    }
  }

  if (value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "UPERframeMAP", "timeStamp", value.timeStamp.value);
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", "timeStamp") )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", "timeStamp");
    }
  }

  value.contentID = 18;

  C2xSetTokenInt(packetHandle, "UPERframeMAP", "contentID", value.contentID);
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  SetUPERframeMAPUPER_BlobMAPParams(packetHandle, value.msgBlob, "msgBlob");
  result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  if (value.crc.isValidFlag==1)
  {
    SetUPERframeMAPMsgCRCParams(packetHandle, value.crc, "crc");
    result = CheckLastError("UPERframeMAP", gkFuncRefGet, result);

  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "UPERframeMAP", "crc") )
    {
      C2xRemoveToken(packetHandle, "UPERframeMAP", "crc");
    }
  }

  return result;
}

