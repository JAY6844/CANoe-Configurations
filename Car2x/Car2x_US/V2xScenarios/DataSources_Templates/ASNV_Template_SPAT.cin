/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct SPAT payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitSPATPacket();
//  if (packetHandle!=0) {
//    if (API_SetSPATParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    const int sizeSPATDSRC_MovementState = 20;    // Original size is 255, but compilation time is very high with this value. Recommended val is 20
                                                  // Path in SPAT: .value.signalPhaseAndTimingMessage.intersections.arrayValue[0].states.arrayValue[0]
  
    const int sizeSPATDSRC_IntersectionState = 4; // Original size is 32, but compilation time is very high with this value. Recommended val is 4
                                                  // Path in SPAT: .value.signalPhaseAndTimingMessage.intersections.arrayValue[0]
  
    struct SPATDescriptiveName {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[64];
        INT  stringLength;
    };
    
    struct SPATIntersectionReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct SPATIntersectionStatusObject {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct SPATEnabledLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        BYTE arrayValue[16];  // INTEGER, 0..255;
    };
    
    struct SPATTimeChangeDetails {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN startTime;  // INTEGER, OPTIONAL, 0..36001;
        WORD minEndTime;  // INTEGER, 0..36001;
        struct OPT_WORD_ASN maxEndTime;  // INTEGER, OPTIONAL, 0..36001;
        struct OPT_WORD_ASN likelyTime;  // INTEGER, OPTIONAL, 0..36001;
        struct OPT_BYTE_ASN confidence;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_WORD_ASN nextTime;  // INTEGER, OPTIONAL, 0..36001;
    };
    
    struct SPATREG_EXT_ID_AND_TYPE_Empty {
    };
    
    struct SPATRegionalExtensionAdvisorySpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct SPAT_AdvisorySpeed_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATRegionalExtensionAdvisorySpeed arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATAdvisorySpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT type;  // ENUMERATED, none(0), greenwave(1), ecoDrive(2), transit(3);
        struct OPT_WORD_ASN speed;  // INTEGER, OPTIONAL, 0..500;
        struct OPT_ENUM_ASN confidence;  // ENUMERATED, OPTIONAL, unavailable(0), prec100ms(1), prec10ms(2), prec5ms(3), prec1ms(4), prec0_1ms(5), prec0_05ms(6), prec0_01ms(7);
        struct OPT_WORD_ASN distance;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_BYTE_ASN class;  // INTEGER, OPTIONAL, 0..255;
        struct SPAT_AdvisorySpeed_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATAdvisorySpeedList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATAdvisorySpeed arrayValue[16];  // SEQUENCE;
    };
    
    struct SPAT_AddGrpB_MovementEvent_addGrpB {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN startTime;  // INTEGER, OPTIONAL, 0..9001;
        WORD minEndTime;  // INTEGER, 0..2402;
        struct OPT_WORD_ASN maxEndTime;  // INTEGER, OPTIONAL, 0..2402;
        struct OPT_WORD_ASN likelyTime;  // INTEGER, OPTIONAL, 0..9001;
        struct OPT_BYTE_ASN confidence;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_WORD_ASN nextTime;  // INTEGER, OPTIONAL, 0..9001;
    };
    
    struct SPATREG_EXT_ID_AND_TYPE_MovementEvent {
        struct SPAT_AddGrpB_MovementEvent_addGrpB addGrpB;  // SEQUENCE;
    };
    
    struct SPATRegionalExtensionMovementEvent {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATREG_EXT_ID_AND_TYPE_MovementEvent regExtValue;  // TABLE;
    };
    
    struct SPAT_MovementEvent_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATRegionalExtensionMovementEvent arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATMovementEvent {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT eventState;  // ENUMERATED, unavailable(0), dark(1), stop_Then_Proceed(2), stop_And_Remain(3), pre_Movement(4), permissive_Movement_Allowed(5), protected_Movement_Allowed(6), permissive_clearance(7), protected_clearance(8), caution_Conflicting_Traffic(9);
        struct SPATTimeChangeDetails timing;  // SEQUENCE, OPTIONAL;
        struct SPATAdvisorySpeedList speeds;  // SEQUENCEOF, OPTIONAL;
        struct SPAT_MovementEvent_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATMovementEventList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATMovementEvent arrayValue[16];  // SEQUENCE;
    };
    
    struct SPAT_AddGrpC_VehicleToLanePosition {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        DWORD stationID;  // INTEGER, 0..4294967295;
        BYTE laneID;  // INTEGER, 0..255;
    };
    
    struct SPAT_AddGrpC_VehicleToLanePositionList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPAT_AddGrpC_VehicleToLanePosition arrayValue[5];  // SEQUENCE;
    };
    
    struct SPATNode_XY_20b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -512..511;
        INT y;  // INTEGER, -512..511;
    };
    
    struct SPATNode_XY_22b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -1024..1023;
        INT y;  // INTEGER, -1024..1023;
    };
    
    struct SPATNode_XY_24b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -2048..2047;
        INT y;  // INTEGER, -2048..2047;
    };
    
    struct SPATNode_XY_26b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -4096..4095;
        INT y;  // INTEGER, -4096..4095;
    };
    
    struct SPATNode_XY_28b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -8192..8191;
        INT y;  // INTEGER, -8192..8191;
    };
    
    struct SPATNode_XY_32b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -32768..32767;
        INT y;  // INTEGER, -32768..32767;
    };
    
    struct SPATNode_LLmD_64b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -1799999999..1800000001;
        LONG lat;  // INTEGER, -900000000..900000001;
    };
    
    struct SPAT_AddGrpB_Node_LLdms_48b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -64800000..64800000;
        LONG lat;  // INTEGER, -32400000..32400000;
    };
    
    struct SPAT_AddGrpB_LongitudeDMS2 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT d;  // INTEGER, -180..180;
        BYTE m;  // INTEGER, 0..59;
        WORD s;  // INTEGER, 0..5999;
    };
    
    struct SPAT_AddGrpB_LatitudeDMS2 {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT d;  // INTEGER, -90..90;
        BYTE m;  // INTEGER, 0..59;
        WORD s;  // INTEGER, 0..5999;
    };
    
    struct SPAT_AddGrpB_Node_LLdms_80b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPAT_AddGrpB_LongitudeDMS2 lon;  // SEQUENCE;
        struct SPAT_AddGrpB_LatitudeDMS2 lat;  // SEQUENCE;
    };
    
    struct SPAT_AddGrpB_NodeOffsetPointXY_addGrpB {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct SPAT_AddGrpB_Node_LLdms_48b posA;  // SEQUENCE;
        struct SPAT_AddGrpB_Node_LLdms_80b posB;  // SEQUENCE;
    };
    
    struct SPATREG_EXT_ID_AND_TYPE_NodeOffsetPointXY {
        struct SPAT_AddGrpB_NodeOffsetPointXY_addGrpB addGrpB;  // CHOICE;
    };
    
    struct SPATRegionalExtensionNodeOffsetPointXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATREG_EXT_ID_AND_TYPE_NodeOffsetPointXY regExtValue;  // TABLE;
    };
    
    struct SPATNodeOffsetPointXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct SPATNode_XY_20b node_XY1;  // SEQUENCE;
        struct SPATNode_XY_22b node_XY2;  // SEQUENCE;
        struct SPATNode_XY_24b node_XY3;  // SEQUENCE;
        struct SPATNode_XY_26b node_XY4;  // SEQUENCE;
        struct SPATNode_XY_28b node_XY5;  // SEQUENCE;
        struct SPATNode_XY_32b node_XY6;  // SEQUENCE;
        struct SPATNode_LLmD_64b node_LatLon;  // SEQUENCE;
        struct SPATRegionalExtensionNodeOffsetPointXY regional;  // SEQUENCE;
    };
    
    struct SPAT_AddGrpC_ConnectionManeuverAssist_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPAT_AddGrpC_VehicleToLanePositionList vehicleToLanePositions;  // SEQUENCEOF;
        struct SPATNodeOffsetPointXY rsuDistanceFromAnchor;  // CHOICE, OPTIONAL;
    };
    
    struct SPATREG_EXT_ID_AND_TYPE_ConnectionManeuverAssist {
        struct SPAT_AddGrpC_ConnectionManeuverAssist_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct SPATRegionalExtensionConnectionManeuverAssist {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATREG_EXT_ID_AND_TYPE_ConnectionManeuverAssist regExtValue;  // TABLE;
    };
    
    struct SPAT_ConnectionManeuverAssist_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATRegionalExtensionConnectionManeuverAssist arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATConnectionManeuverAssist {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE connectionID;  // INTEGER, 0..255;
        struct OPT_WORD_ASN queueLength;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_WORD_ASN availableStorageLength;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_BOOL_ASN waitOnStop;  // BOOLEAN, OPTIONAL;
        struct OPT_BOOL_ASN pedBicycleDetect;  // BOOLEAN, OPTIONAL;
        struct SPAT_ConnectionManeuverAssist_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATManeuverAssistList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATConnectionManeuverAssist arrayValue[16];  // SEQUENCE;
    };
    
    struct SPATRegionalExtensionMovementState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct SPAT_MovementState_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATRegionalExtensionMovementState arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATMovementState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPATDescriptiveName movementName;  // IA5STRING, OPTIONAL;
        BYTE signalGroup;  // INTEGER, 0..255;
        struct SPATMovementEventList state_time_speed;  // SEQUENCEOF;
        struct SPATManeuverAssistList maneuverAssistList;  // SEQUENCEOF, OPTIONAL;
        struct SPAT_MovementState_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATMovementList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATMovementState arrayValue[sizeSPATDSRC_MovementState];  // SEQUENCE;
    };
    
    struct SPAT_AddGrpC_PrioritizationResponse {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        DWORD stationID;  // INTEGER, 0..4294967295;
        INT priorState;  // ENUMERATED, unknown(0), requested(1), processing(2), watchOtherTraffic(3), granted(4), rejected(5), maxPresence(6), reserviceLocked(7);
        BYTE signalGroup;  // INTEGER, 0..255;
    };
    
    struct SPAT_AddGrpC_PrioritizationResponseList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPAT_AddGrpC_PrioritizationResponse arrayValue[10];  // SEQUENCE;
    };
    
    struct SPAT_AddGrpC_IntersectionState_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPAT_AddGrpC_PrioritizationResponseList activePrioritizations;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATREG_EXT_ID_AND_TYPE_IntersectionState {
        struct SPAT_AddGrpC_IntersectionState_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct SPATRegionalExtensionIntersectionState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATREG_EXT_ID_AND_TYPE_IntersectionState regExtValue;  // TABLE;
    };
    
    struct SPAT_IntersectionState_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATRegionalExtensionIntersectionState arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATIntersectionState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPATDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct SPATIntersectionReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct SPATIntersectionStatusObject status;  // BITSTRING;
        struct OPT_DWORD_ASN moy;  // INTEGER, OPTIONAL, 0..527040;
        struct OPT_WORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..65535;
        struct SPATEnabledLaneList enabledLanes;  // SEQUENCEOF, OPTIONAL;
        struct SPATMovementList states;  // SEQUENCEOF;
        struct SPATManeuverAssistList maneuverAssistList;  // SEQUENCEOF, OPTIONAL;
        struct SPAT_IntersectionState_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATIntersectionStateList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATIntersectionState arrayValue[sizeSPATDSRC_IntersectionState];  // SEQUENCE;
    };
    
    struct SPATRegionalExtensionSPAT {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct SPAT_SPAT_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATRegionalExtensionSPAT arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATSpat {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        struct SPATDescriptiveName name;  // IA5STRING, OPTIONAL;
        struct SPATIntersectionStateList intersections;  // SEQUENCEOF;
        struct SPAT_SPAT_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATMESSAGE_ID_AND_TYPE {
        struct SPATSpat signalPhaseAndTimingMessage;  // SEQUENCE;
    };
    
    struct SPAT {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD messageId;  // INTEGER, 0..32767, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollision_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData(18), signalPhaseAndTimingMessage(19), basicSafetyMessage(20), commonSafetyRequest(21), emergencyVehicleAlert(22), intersectionCollision(23), nmeaCorrections(24), probeDataManagement(25), probeVehicleData(26), roadSideAlert(27), rtcmCorrections(28), signalRequestMessage(29), signalStatusMessage(30), travelerInformation(31), personalSafetyMessage(32), testMessage00(240), testMessage01(241), testMessage02(242), testMessage03(243), testMessage04(244), testMessage05(245), testMessage06(246), testMessage07(247), testMessage08(248), testMessage09(249), testMessage10(250), testMessage11(251), testMessage12(252), testMessage13(253), testMessage14(254), testMessage15(255);
        struct SPATMESSAGE_ID_AND_TYPE value;  // TABLE;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitSPATPacket()
{
  return C2xInitPacket("SPAT"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitSPATPacket(struct SPAT msgStruct)
{
  long pktHandle;

  pktHandle = API_InitSPATPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetSPATParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitSPATPacket(struct SPAT msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("SPAT", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetSPATParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetSPATIntersectionReferenceIDParams(LONG packetHandle, struct SPATIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATIntersectionReferenceIDParams(LONG packetHandle, struct SPATIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.region.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.id);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATEnabledLaneListParams(LONG packetHandle, struct SPATEnabledLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATEnabledLaneListParams(LONG packetHandle, struct SPATEnabledLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.arrayValue[i]);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATTimeChangeDetailsParams(LONG packetHandle, struct SPATTimeChangeDetails value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startTime");
  value.startTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.startTime.isValidFlag==1)
  {
    value.startTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minEndTime");
  value.minEndTime = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maxEndTime");
  value.maxEndTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.maxEndTime.isValidFlag==1)
  {
    value.maxEndTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "likelyTime");
  value.likelyTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.likelyTime.isValidFlag==1)
  {
    value.likelyTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.confidence.isValidFlag==1)
  {
    value.confidence.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nextTime");
  value.nextTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.nextTime.isValidFlag==1)
  {
    value.nextTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATTimeChangeDetailsParams(LONG packetHandle, struct SPATTimeChangeDetails value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startTime");
  if(value.startTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.startTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minEndTime");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.minEndTime);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maxEndTime");
  if(value.maxEndTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.maxEndTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "likelyTime");
  if(value.likelyTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.likelyTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  if(value.confidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.confidence.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nextTime");
  if(value.nextTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.nextTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATRegionalExtensionAdvisorySpeedParams(LONG packetHandle, struct SPATRegionalExtensionAdvisorySpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATRegionalExtensionAdvisorySpeedParams(LONG packetHandle, struct SPATRegionalExtensionAdvisorySpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetSPAT_AdvisorySpeed_regionalParams(LONG packetHandle, struct SPAT_AdvisorySpeed_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATRegionalExtensionAdvisorySpeedParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPAT_AdvisorySpeed_regionalParams(LONG packetHandle, struct SPAT_AdvisorySpeed_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATRegionalExtensionAdvisorySpeedParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATAdvisorySpeedParams(LONG packetHandle, struct SPATAdvisorySpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  value.type = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.speed.isValidFlag==1)
  {
    value.speed.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.confidence.isValidFlag==1)
  {
    value.confidence.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "distance");
  value.distance.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.distance.isValidFlag==1)
  {
    value.distance.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "class");
  value.class.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.class.isValidFlag==1)
  {
    value.class.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPAT_AdvisorySpeed_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATAdvisorySpeedParams(LONG packetHandle, struct SPATAdvisorySpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.type);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  if(value.speed.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.speed.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  if(value.confidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.confidence.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "distance");
  if(value.distance.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.distance.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "class");
  if(value.class.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.class.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPAT_AdvisorySpeed_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATAdvisorySpeedListParams(LONG packetHandle, struct SPATAdvisorySpeedList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATAdvisorySpeedParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATAdvisorySpeedListParams(LONG packetHandle, struct SPATAdvisorySpeedList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATAdvisorySpeedParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPAT_AddGrpB_MovementEvent_addGrpBParams(LONG packetHandle, struct SPAT_AddGrpB_MovementEvent_addGrpB value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startTime");
  value.startTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.startTime.isValidFlag==1)
  {
    value.startTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minEndTime");
  value.minEndTime = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maxEndTime");
  value.maxEndTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.maxEndTime.isValidFlag==1)
  {
    value.maxEndTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "likelyTime");
  value.likelyTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.likelyTime.isValidFlag==1)
  {
    value.likelyTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.confidence.isValidFlag==1)
  {
    value.confidence.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nextTime");
  value.nextTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.nextTime.isValidFlag==1)
  {
    value.nextTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPAT_AddGrpB_MovementEvent_addGrpBParams(LONG packetHandle, struct SPAT_AddGrpB_MovementEvent_addGrpB value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startTime");
  if(value.startTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.startTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minEndTime");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.minEndTime);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maxEndTime");
  if(value.maxEndTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.maxEndTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "likelyTime");
  if(value.likelyTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.likelyTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  if(value.confidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.confidence.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nextTime");
  if(value.nextTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.nextTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATREG_EXT_ID_AND_TYPE_MovementEventParams(LONG packetHandle, WORD tableKey, struct SPATREG_EXT_ID_AND_TYPE_MovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpB");
      GetSPAT_AddGrpB_MovementEvent_addGrpBParams(packetHandle, value.addGrpB, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATREG_EXT_ID_AND_TYPE_MovementEventParams(LONG packetHandle, WORD tableKey, struct SPATREG_EXT_ID_AND_TYPE_MovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpB");
      SetSPAT_AddGrpB_MovementEvent_addGrpBParams(packetHandle, value.addGrpB, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPATRegionalExtensionMovementEventParams(LONG packetHandle, struct SPATRegionalExtensionMovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetSPATREG_EXT_ID_AND_TYPE_MovementEventParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATRegionalExtensionMovementEventParams(LONG packetHandle, struct SPATRegionalExtensionMovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetSPATREG_EXT_ID_AND_TYPE_MovementEventParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_MovementEvent_regionalParams(LONG packetHandle, struct SPAT_MovementEvent_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATRegionalExtensionMovementEventParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPAT_MovementEvent_regionalParams(LONG packetHandle, struct SPAT_MovementEvent_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATRegionalExtensionMovementEventParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATMovementEventParams(LONG packetHandle, struct SPATMovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventState");
  value.eventState = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timing");
  value.timing.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.timing.isValidFlag==1)
  {
    GetSPATTimeChangeDetailsParams(packetHandle, value.timing, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speeds");
  value.speeds.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.speeds.isValidFlag==1)
  {
    GetSPATAdvisorySpeedListParams(packetHandle, value.speeds, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPAT_MovementEvent_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATMovementEventParams(LONG packetHandle, struct SPATMovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventState");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.eventState);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timing");
  if(value.timing.isValidFlag==1)
  {
    SetSPATTimeChangeDetailsParams(packetHandle, value.timing, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speeds");
  if(value.speeds.isValidFlag==1)
  {
    SetSPATAdvisorySpeedListParams(packetHandle, value.speeds, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPAT_MovementEvent_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATMovementEventListParams(LONG packetHandle, struct SPATMovementEventList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATMovementEventParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATMovementEventListParams(LONG packetHandle, struct SPATMovementEventList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATMovementEventParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPAT_AddGrpC_VehicleToLanePositionParams(LONG packetHandle, struct SPAT_AddGrpC_VehicleToLanePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  value.stationID = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  value.laneID = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPAT_AddGrpC_VehicleToLanePositionParams(LONG packetHandle, struct SPAT_AddGrpC_VehicleToLanePosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.stationID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.laneID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_AddGrpC_VehicleToLanePositionListParams(LONG packetHandle, struct SPAT_AddGrpC_VehicleToLanePositionList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPAT_AddGrpC_VehicleToLanePositionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPAT_AddGrpC_VehicleToLanePositionListParams(LONG packetHandle, struct SPAT_AddGrpC_VehicleToLanePositionList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPAT_AddGrpC_VehicleToLanePositionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATNode_XY_20bParams(LONG packetHandle, struct SPATNode_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATNode_XY_20bParams(LONG packetHandle, struct SPATNode_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATNode_XY_22bParams(LONG packetHandle, struct SPATNode_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATNode_XY_22bParams(LONG packetHandle, struct SPATNode_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATNode_XY_24bParams(LONG packetHandle, struct SPATNode_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATNode_XY_24bParams(LONG packetHandle, struct SPATNode_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATNode_XY_26bParams(LONG packetHandle, struct SPATNode_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATNode_XY_26bParams(LONG packetHandle, struct SPATNode_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATNode_XY_28bParams(LONG packetHandle, struct SPATNode_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATNode_XY_28bParams(LONG packetHandle, struct SPATNode_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATNode_XY_32bParams(LONG packetHandle, struct SPATNode_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATNode_XY_32bParams(LONG packetHandle, struct SPATNode_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATNode_LLmD_64bParams(LONG packetHandle, struct SPATNode_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATNode_LLmD_64bParams(LONG packetHandle, struct SPATNode_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.lon);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.lat);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_AddGrpB_Node_LLdms_48bParams(LONG packetHandle, struct SPAT_AddGrpB_Node_LLdms_48b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPAT_AddGrpB_Node_LLdms_48bParams(LONG packetHandle, struct SPAT_AddGrpB_Node_LLdms_48b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.lon);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.lat);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_AddGrpB_LongitudeDMS2Params(LONG packetHandle, struct SPAT_AddGrpB_LongitudeDMS2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "d");
  value.d = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "m");
  value.m = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "s");
  value.s = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPAT_AddGrpB_LongitudeDMS2Params(LONG packetHandle, struct SPAT_AddGrpB_LongitudeDMS2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "d");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.d);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "m");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.m);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "s");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.s);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_AddGrpB_LatitudeDMS2Params(LONG packetHandle, struct SPAT_AddGrpB_LatitudeDMS2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "d");
  value.d = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "m");
  value.m = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "s");
  value.s = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPAT_AddGrpB_LatitudeDMS2Params(LONG packetHandle, struct SPAT_AddGrpB_LatitudeDMS2 value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "d");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.d);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "m");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.m);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "s");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.s);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_AddGrpB_Node_LLdms_80bParams(LONG packetHandle, struct SPAT_AddGrpB_Node_LLdms_80b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  GetSPAT_AddGrpB_LongitudeDMS2Params(packetHandle, value.lon, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  GetSPAT_AddGrpB_LatitudeDMS2Params(packetHandle, value.lat, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPAT_AddGrpB_Node_LLdms_80bParams(LONG packetHandle, struct SPAT_AddGrpB_Node_LLdms_80b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  SetSPAT_AddGrpB_LongitudeDMS2Params(packetHandle, value.lon, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  SetSPAT_AddGrpB_LatitudeDMS2Params(packetHandle, value.lat, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_AddGrpB_NodeOffsetPointXY_addGrpBParams(LONG packetHandle, struct SPAT_AddGrpB_NodeOffsetPointXY_addGrpB value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "SPAT", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posA");
      GetSPAT_AddGrpB_Node_LLdms_48bParams(packetHandle, value.posA, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posB");
      GetSPAT_AddGrpB_Node_LLdms_80bParams(packetHandle, value.posB, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPAT_AddGrpB_NodeOffsetPointXY_addGrpBParams(LONG packetHandle, struct SPAT_AddGrpB_NodeOffsetPointXY_addGrpB value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posA");
      SetSPAT_AddGrpB_Node_LLdms_48bParams(packetHandle, value.posA, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "posB");
      SetSPAT_AddGrpB_Node_LLdms_80bParams(packetHandle, value.posB, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPATREG_EXT_ID_AND_TYPE_NodeOffsetPointXYParams(LONG packetHandle, WORD tableKey, struct SPATREG_EXT_ID_AND_TYPE_NodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpB");
      GetSPAT_AddGrpB_NodeOffsetPointXY_addGrpBParams(packetHandle, value.addGrpB, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATREG_EXT_ID_AND_TYPE_NodeOffsetPointXYParams(LONG packetHandle, WORD tableKey, struct SPATREG_EXT_ID_AND_TYPE_NodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpB");
      SetSPAT_AddGrpB_NodeOffsetPointXY_addGrpBParams(packetHandle, value.addGrpB, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPATRegionalExtensionNodeOffsetPointXYParams(LONG packetHandle, struct SPATRegionalExtensionNodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetSPATREG_EXT_ID_AND_TYPE_NodeOffsetPointXYParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATRegionalExtensionNodeOffsetPointXYParams(LONG packetHandle, struct SPATRegionalExtensionNodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetSPATREG_EXT_ID_AND_TYPE_NodeOffsetPointXYParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATNodeOffsetPointXYParams(LONG packetHandle, struct SPATNodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "SPAT", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      GetSPATNode_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      GetSPATNode_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      GetSPATNode_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      GetSPATNode_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      GetSPATNode_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      GetSPATNode_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      GetSPATNode_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      GetSPATRegionalExtensionNodeOffsetPointXYParams(packetHandle, value.regional, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATNodeOffsetPointXYParams(LONG packetHandle, struct SPATNodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      SetSPATNode_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      SetSPATNode_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      SetSPATNode_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      SetSPATNode_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      SetSPATNode_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      SetSPATNode_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      SetSPATNode_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      SetSPATRegionalExtensionNodeOffsetPointXYParams(packetHandle, value.regional, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPAT_AddGrpC_ConnectionManeuverAssist_addGrpCParams(LONG packetHandle, struct SPAT_AddGrpC_ConnectionManeuverAssist_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleToLanePositions");
  GetSPAT_AddGrpC_VehicleToLanePositionListParams(packetHandle, value.vehicleToLanePositions, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rsuDistanceFromAnchor");
  value.rsuDistanceFromAnchor.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.rsuDistanceFromAnchor.isValidFlag==1)
  {
    GetSPATNodeOffsetPointXYParams(packetHandle, value.rsuDistanceFromAnchor, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPAT_AddGrpC_ConnectionManeuverAssist_addGrpCParams(LONG packetHandle, struct SPAT_AddGrpC_ConnectionManeuverAssist_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "vehicleToLanePositions");
  SetSPAT_AddGrpC_VehicleToLanePositionListParams(packetHandle, value.vehicleToLanePositions, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rsuDistanceFromAnchor");
  if(value.rsuDistanceFromAnchor.isValidFlag==1)
  {
    SetSPATNodeOffsetPointXYParams(packetHandle, value.rsuDistanceFromAnchor, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATREG_EXT_ID_AND_TYPE_ConnectionManeuverAssistParams(LONG packetHandle, WORD tableKey, struct SPATREG_EXT_ID_AND_TYPE_ConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetSPAT_AddGrpC_ConnectionManeuverAssist_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATREG_EXT_ID_AND_TYPE_ConnectionManeuverAssistParams(LONG packetHandle, WORD tableKey, struct SPATREG_EXT_ID_AND_TYPE_ConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetSPAT_AddGrpC_ConnectionManeuverAssist_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPATRegionalExtensionConnectionManeuverAssistParams(LONG packetHandle, struct SPATRegionalExtensionConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetSPATREG_EXT_ID_AND_TYPE_ConnectionManeuverAssistParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATRegionalExtensionConnectionManeuverAssistParams(LONG packetHandle, struct SPATRegionalExtensionConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetSPATREG_EXT_ID_AND_TYPE_ConnectionManeuverAssistParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_ConnectionManeuverAssist_regionalParams(LONG packetHandle, struct SPAT_ConnectionManeuverAssist_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATRegionalExtensionConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPAT_ConnectionManeuverAssist_regionalParams(LONG packetHandle, struct SPAT_ConnectionManeuverAssist_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATRegionalExtensionConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATConnectionManeuverAssistParams(LONG packetHandle, struct SPATConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  value.connectionID = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "queueLength");
  value.queueLength.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.queueLength.isValidFlag==1)
  {
    value.queueLength.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "availableStorageLength");
  value.availableStorageLength.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.availableStorageLength.isValidFlag==1)
  {
    value.availableStorageLength.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "waitOnStop");
  value.waitOnStop.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.waitOnStop.isValidFlag==1)
  {
    value.waitOnStop.value = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pedBicycleDetect");
  value.pedBicycleDetect.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.pedBicycleDetect.isValidFlag==1)
  {
    value.pedBicycleDetect.value = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPAT_ConnectionManeuverAssist_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATConnectionManeuverAssistParams(LONG packetHandle, struct SPATConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.connectionID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "queueLength");
  if(value.queueLength.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.queueLength.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "availableStorageLength");
  if(value.availableStorageLength.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.availableStorageLength.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "waitOnStop");
  if(value.waitOnStop.isValidFlag==1)
  {
    C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.waitOnStop.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pedBicycleDetect");
  if(value.pedBicycleDetect.isValidFlag==1)
  {
    C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.pedBicycleDetect.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPAT_ConnectionManeuverAssist_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATManeuverAssistListParams(LONG packetHandle, struct SPATManeuverAssistList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATManeuverAssistListParams(LONG packetHandle, struct SPATManeuverAssistList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATRegionalExtensionMovementStateParams(LONG packetHandle, struct SPATRegionalExtensionMovementState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATRegionalExtensionMovementStateParams(LONG packetHandle, struct SPATRegionalExtensionMovementState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetSPAT_MovementState_regionalParams(LONG packetHandle, struct SPAT_MovementState_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATRegionalExtensionMovementStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPAT_MovementState_regionalParams(LONG packetHandle, struct SPAT_MovementState_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATRegionalExtensionMovementStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATMovementStateParams(LONG packetHandle, struct SPATMovementState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "movementName");
  value.movementName.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.movementName.isValidFlag==1)
  {
    value.movementName.stringLength = C2xGetTokenData(packetHandle, "SPAT", newPath, elcount(value.movementName.string), value.movementName.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  value.signalGroup = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "state_time_speed");
  GetSPATMovementEventListParams(packetHandle, value.state_time_speed, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  value.maneuverAssistList.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.maneuverAssistList.isValidFlag==1)
  {
    GetSPATManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPAT_MovementState_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATMovementStateParams(LONG packetHandle, struct SPATMovementState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "movementName");
  if(value.movementName.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "SPAT", newPath, value.movementName.stringLength, value.movementName.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.signalGroup);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "state_time_speed");
  SetSPATMovementEventListParams(packetHandle, value.state_time_speed, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  if(value.maneuverAssistList.isValidFlag==1)
  {
    SetSPATManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPAT_MovementState_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATMovementListParams(LONG packetHandle, struct SPATMovementList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATMovementStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATMovementListParams(LONG packetHandle, struct SPATMovementList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATMovementStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPAT_AddGrpC_PrioritizationResponseParams(LONG packetHandle, struct SPAT_AddGrpC_PrioritizationResponse value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  value.stationID = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "priorState");
  value.priorState = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  value.signalGroup = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPAT_AddGrpC_PrioritizationResponseParams(LONG packetHandle, struct SPAT_AddGrpC_PrioritizationResponse value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.stationID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "priorState");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.priorState);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.signalGroup);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_AddGrpC_PrioritizationResponseListParams(LONG packetHandle, struct SPAT_AddGrpC_PrioritizationResponseList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPAT_AddGrpC_PrioritizationResponseParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPAT_AddGrpC_PrioritizationResponseListParams(LONG packetHandle, struct SPAT_AddGrpC_PrioritizationResponseList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPAT_AddGrpC_PrioritizationResponseParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPAT_AddGrpC_IntersectionState_addGrpCParams(LONG packetHandle, struct SPAT_AddGrpC_IntersectionState_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "activePrioritizations");
  value.activePrioritizations.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.activePrioritizations.isValidFlag==1)
  {
    GetSPAT_AddGrpC_PrioritizationResponseListParams(packetHandle, value.activePrioritizations, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPAT_AddGrpC_IntersectionState_addGrpCParams(LONG packetHandle, struct SPAT_AddGrpC_IntersectionState_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "activePrioritizations");
  if(value.activePrioritizations.isValidFlag==1)
  {
    SetSPAT_AddGrpC_PrioritizationResponseListParams(packetHandle, value.activePrioritizations, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATREG_EXT_ID_AND_TYPE_IntersectionStateParams(LONG packetHandle, WORD tableKey, struct SPATREG_EXT_ID_AND_TYPE_IntersectionState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetSPAT_AddGrpC_IntersectionState_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATREG_EXT_ID_AND_TYPE_IntersectionStateParams(LONG packetHandle, WORD tableKey, struct SPATREG_EXT_ID_AND_TYPE_IntersectionState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetSPAT_AddGrpC_IntersectionState_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPATRegionalExtensionIntersectionStateParams(LONG packetHandle, struct SPATRegionalExtensionIntersectionState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetSPATREG_EXT_ID_AND_TYPE_IntersectionStateParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATRegionalExtensionIntersectionStateParams(LONG packetHandle, struct SPATRegionalExtensionIntersectionState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetSPATREG_EXT_ID_AND_TYPE_IntersectionStateParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPAT_IntersectionState_regionalParams(LONG packetHandle, struct SPAT_IntersectionState_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATRegionalExtensionIntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPAT_IntersectionState_regionalParams(LONG packetHandle, struct SPAT_IntersectionState_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATRegionalExtensionIntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATIntersectionStateParams(LONG packetHandle, struct SPATIntersectionState value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "SPAT", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetSPATIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
  value.status.isValidFlag = 1;
  value.status.stringLength = C2xGetTokenLengthBit(packetHandle, "SPAT", newPath);
  if ((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    if(value.status.stringLength > 0)
    {
      for(j=0; j<value.status.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "SPAT", newPath, j) == 0)
        {
          value.status.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "SPAT", newPath, j) == 1)
        {
          value.status.string[j] = '1';
        }

        if(value.status.stringLength == 1)
        {
          value.status.string[1] = '0';
        }
        result = CheckLastError("SPAT", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.status.stringLength+1; k > -1; k--)
      {
        if(value.status.string[k] == '1')
        {
          value.status.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "moy");
  value.moy.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.moy.isValidFlag==1)
  {
    value.moy.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabledLanes");
  value.enabledLanes.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.enabledLanes.isValidFlag==1)
  {
    GetSPATEnabledLaneListParams(packetHandle, value.enabledLanes, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "states");
  GetSPATMovementListParams(packetHandle, value.states, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  value.maneuverAssistList.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.maneuverAssistList.isValidFlag==1)
  {
    GetSPATManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPAT_IntersectionState_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATIntersectionStateParams(LONG packetHandle, struct SPATIntersectionState value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "SPAT", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetSPATIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.revision);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
    for(j=0; j<value.status.stringLength; j++)
    {
      if(value.status.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "SPAT", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "SPAT", newPath, j, 1);
      }
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "moy");
  if(value.moy.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.moy.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.timeStamp.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabledLanes");
  if(value.enabledLanes.isValidFlag==1)
  {
    SetSPATEnabledLaneListParams(packetHandle, value.enabledLanes, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "states");
  SetSPATMovementListParams(packetHandle, value.states, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  if(value.maneuverAssistList.isValidFlag==1)
  {
    SetSPATManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPAT_IntersectionState_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATIntersectionStateListParams(LONG packetHandle, struct SPATIntersectionStateList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATIntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATIntersectionStateListParams(LONG packetHandle, struct SPATIntersectionStateList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATIntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATRegionalExtensionSPATParams(LONG packetHandle, struct SPATRegionalExtensionSPAT value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATRegionalExtensionSPATParams(LONG packetHandle, struct SPATRegionalExtensionSPAT value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetSPAT_SPAT_regionalParams(LONG packetHandle, struct SPAT_SPAT_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATRegionalExtensionSPATParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPAT_SPAT_regionalParams(LONG packetHandle, struct SPAT_SPAT_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATRegionalExtensionSPATParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATSpatParams(LONG packetHandle, struct SPATSpat value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "SPAT", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  GetSPATIntersectionStateListParams(packetHandle, value.intersections, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPAT_SPAT_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATSpatParams(LONG packetHandle, struct SPATSpat value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.timeStamp.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "SPAT", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  SetSPATIntersectionStateListParams(packetHandle, value.intersections, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPAT_SPAT_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATMESSAGE_ID_AND_TYPEParams(LONG packetHandle, WORD tableKey, struct SPATMESSAGE_ID_AND_TYPE value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 19:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalPhaseAndTimingMessage");
      GetSPATSpatParams(packetHandle, value.signalPhaseAndTimingMessage, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATMESSAGE_ID_AND_TYPEParams(LONG packetHandle, WORD tableKey, struct SPATMESSAGE_ID_AND_TYPE value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 19:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalPhaseAndTimingMessage");
      SetSPATSpatParams(packetHandle, value.signalPhaseAndTimingMessage, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int API_GetSPATParams(LONG packetHandle, struct SPAT value)
{
  int result;
  result = 0;

  value.messageId = C2xGetTokenInt(packetHandle, "SPAT", "messageId");
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  GetSPATMESSAGE_ID_AND_TYPEParams(packetHandle, value.messageId, value.value, "value");
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int API_SetSPATParams(LONG packetHandle, struct SPAT value)
{
  int result;
  result = 0;

  value.messageId = 19;

  SetSPATMESSAGE_ID_AND_TYPEParams(packetHandle, value.messageId, value.value, "value");
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

