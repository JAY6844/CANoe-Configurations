/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct SignalStatusMessage payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitSignalStatusMessagePacket();
//  if (packetHandle!=0) {
//    if (API_SetSignalStatusMessageParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    struct SignalStatusMessageIntersectionReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct SignalStatusMessageTemporaryID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[5];
        INT  stringLength;
    };
    
    struct SignalStatusMessageVehicleID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct SignalStatusMessageTemporaryID entityID;  // OCTETSTRING;
        DWORD stationID;  // INTEGER, 0..4294967295;
    };
    
    struct SignalStatusMessageREG_EXT_ID_AND_TYPE_Empty {
    };
    
    struct SignalStatusMessageRegionalExtensionRequestorType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SignalStatusMessageREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct SignalStatusMessageRequestorType {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT role;  // ENUMERATED, basicVehicle(0), publicTransport(1), specialTransport(2), dangerousGoods(3), roadWork(4), roadRescue(5), emergency(6), safetyCar(7), none_unknown(8), truck(9), motorcycle(10), roadSideSource(11), police(12), fire(13), ambulance(14), dot(15), transit(16), slowMoving(17), stopNgo(18), cyclist(19), pedestrian(20), nonMotorized(21), military(22);
        struct OPT_ENUM_ASN subrole;  // ENUMERATED, OPTIONAL, requestSubRoleUnKnown(0), requestSubRole1(1), requestSubRole2(2), requestSubRole3(3), requestSubRole4(4), requestSubRole5(5), requestSubRole6(6), requestSubRole7(7), requestSubRole8(8), requestSubRole9(9), requestSubRole10(10), requestSubRole11(11), requestSubRole12(12), requestSubRole13(13), requestSubRole14(14), requestSubRoleReserved(15);
        struct OPT_ENUM_ASN request;  // ENUMERATED, OPTIONAL, requestImportanceLevelUnKnown(0), requestImportanceLevel1(1), requestImportanceLevel2(2), requestImportanceLevel3(3), requestImportanceLevel4(4), requestImportanceLevel5(5), requestImportanceLevel6(6), requestImportanceLevel7(7), requestImportanceLevel8(8), requestImportanceLevel9(9), requestImportanceLevel10(10), requestImportanceLevel11(11), requestImportanceLevel12(12), requestImportanceLevel13(13), requestImportanceLevel14(14), requestImportanceReserved(15);
        struct OPT_BYTE_ASN iso3883;  // INTEGER, OPTIONAL, 0..100;
        struct OPT_ENUM_ASN hpmsType;  // ENUMERATED, OPTIONAL, none(0), unknown(1), special(2), moto(3), car(4), carOther(5), bus(6), axleCnt2(7), axleCnt3(8), axleCnt4(9), axleCnt4Trailer(10), axleCnt5Trailer(11), axleCnt6Trailer(12), axleCnt5MultiTrailer(13), axleCnt6MultiTrailer(14), axleCnt7MultiTrailer(15);
        struct SignalStatusMessageRegionalExtensionRequestorType regional;  // SEQUENCE, OPTIONAL;
    };
    
    struct SignalStatusMessageSignalRequesterInfo {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SignalStatusMessageVehicleID id;  // CHOICE;
        BYTE request;  // INTEGER, 0..255;
        BYTE sequenceNumber;  // INTEGER, 0..127;
        struct OPT_ENUM_ASN role;  // ENUMERATED, OPTIONAL, basicVehicle(0), publicTransport(1), specialTransport(2), dangerousGoods(3), roadWork(4), roadRescue(5), emergency(6), safetyCar(7), none_unknown(8), truck(9), motorcycle(10), roadSideSource(11), police(12), fire(13), ambulance(14), dot(15), transit(16), slowMoving(17), stopNgo(18), cyclist(19), pedestrian(20), nonMotorized(21), military(22);
        struct SignalStatusMessageRequestorType typeData;  // SEQUENCE, OPTIONAL;
    };
    
    struct SignalStatusMessageIntersectionAccessPoint {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        BYTE lane;  // INTEGER, 0..255;
        BYTE approach;  // INTEGER, 0..15;
        BYTE connection;  // INTEGER, 0..255;
    };
    
    struct SignalStatusMessageRegionalExtensionSignalStatusPackage {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SignalStatusMessageREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct SignalStatusMessage_SignalStatusPackage_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SignalStatusMessageRegionalExtensionSignalStatusPackage arrayValue[4];  // SEQUENCE;
    };
    
    struct SignalStatusMessageSignalStatusPackage {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SignalStatusMessageSignalRequesterInfo requester;  // SEQUENCE, OPTIONAL;
        struct SignalStatusMessageIntersectionAccessPoint inboundOn;  // CHOICE;
        struct SignalStatusMessageIntersectionAccessPoint outboundOn;  // CHOICE, OPTIONAL;
        struct OPT_DWORD_ASN minute;  // INTEGER, OPTIONAL, 0..527040;
        struct OPT_WORD_ASN second;  // INTEGER, OPTIONAL, 0..65535;
        struct OPT_WORD_ASN duration;  // INTEGER, OPTIONAL, 0..65535;
        INT status;  // ENUMERATED, unknown(0), requested(1), processing(2), watchOtherTraffic(3), granted(4), rejected(5), maxPresence(6), reserviceLocked(7);
        struct SignalStatusMessage_SignalStatusPackage_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SignalStatusMessageSignalStatusPackageList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SignalStatusMessageSignalStatusPackage arrayValue[32];  // SEQUENCE;
    };
    
    struct SignalStatusMessageRegionalExtensionSignalStatus {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SignalStatusMessageREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct SignalStatusMessage_SignalStatus_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SignalStatusMessageRegionalExtensionSignalStatus arrayValue[4];  // SEQUENCE;
    };
    
    struct SignalStatusMessageSignalStatus {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE sequenceNumber;  // INTEGER, 0..127;
        struct SignalStatusMessageIntersectionReferenceID id;  // SEQUENCE;
        struct SignalStatusMessageSignalStatusPackageList sigStatus;  // SEQUENCEOF;
        struct SignalStatusMessage_SignalStatus_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SignalStatusMessageSignalStatusList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SignalStatusMessageSignalStatus arrayValue[32];  // SEQUENCE;
    };
    
    struct SignalStatusMessageRegionalExtensionSignalStatusMessage {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SignalStatusMessageREG_EXT_ID_AND_TYPE_Empty regExtValue;  // TABLE;
    };
    
    struct SignalStatusMessage_SignalStatusMessage_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SignalStatusMessageRegionalExtensionSignalStatusMessage arrayValue[4];  // SEQUENCE;
    };
    
    struct SignalStatusMessageSSM {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        WORD second;  // INTEGER, 0..65535;
        struct OPT_BYTE_ASN sequenceNumber;  // INTEGER, OPTIONAL, 0..127;
        struct SignalStatusMessageSignalStatusList status;  // SEQUENCEOF;
        struct SignalStatusMessage_SignalStatusMessage_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SignalStatusMessageMESSAGE_ID_AND_TYPE {
        struct SignalStatusMessageSSM signalStatusMessage;  // SEQUENCE;
    };
    
    struct SignalStatusMessage {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        WORD messageId;  // INTEGER, 0..32767, reservedMessageId_D(0), alaCarteMessage_D(1), basicSafetyMessage_D(2), basicSafetyMessageVerbose_D(3), commonSafetyRequest_D(4), emergencyVehicleAlert_D(5), intersectionCollision_D(6), mapData_D(7), nmeaCorrections_D(8), probeDataManagement_D(9), probeVehicleData_D(10), roadSideAlert_D(11), rtcmCorrections_D(12), signalPhaseAndTimingMessage_D(13), signalRequestMessage_D(14), signalStatusMessage_D(15), travelerInformation_D(16), uperFrame_D(17), mapData(18), signalPhaseAndTimingMessage(19), basicSafetyMessage(20), commonSafetyRequest(21), emergencyVehicleAlert(22), intersectionCollision(23), nmeaCorrections(24), probeDataManagement(25), probeVehicleData(26), roadSideAlert(27), rtcmCorrections(28), signalRequestMessage(29), signalStatusMessage(30), travelerInformation(31), personalSafetyMessage(32), testMessage00(240), testMessage01(241), testMessage02(242), testMessage03(243), testMessage04(244), testMessage05(245), testMessage06(246), testMessage07(247), testMessage08(248), testMessage09(249), testMessage10(250), testMessage11(251), testMessage12(252), testMessage13(253), testMessage14(254), testMessage15(255);
        struct SignalStatusMessageMESSAGE_ID_AND_TYPE value;  // TABLE;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitSignalStatusMessagePacket()
{
  return C2xInitPacket("SignalStatusMessage"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitSignalStatusMessagePacket(struct SignalStatusMessage msgStruct)
{
  long pktHandle;

  pktHandle = API_InitSignalStatusMessagePacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetSignalStatusMessageParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitSignalStatusMessagePacket(struct SignalStatusMessage msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("SignalStatusMessage", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetSignalStatusMessageParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetSignalStatusMessageIntersectionReferenceIDParams(LONG packetHandle, struct SignalStatusMessageIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  return result;
}

int SetSignalStatusMessageIntersectionReferenceIDParams(LONG packetHandle, struct SignalStatusMessageIntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.region.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.id);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  return result;
}

int GetSignalStatusMessageVehicleIDParams(LONG packetHandle, struct SignalStatusMessageVehicleID value, char oldPath[])
{
  char newPath[300];
  char buffer[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "SignalStatusMessage", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "entityID");
      value.entityID.stringLength = C2xGetTokenData(packetHandle, "SignalStatusMessage", newPath, elcount(value.entityID.string), value.entityID.string);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
      value.stationID = C2xGetTokenInt64(packetHandle, "SignalStatusMessage", newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSignalStatusMessageVehicleIDParams(LONG packetHandle, struct SignalStatusMessageVehicleID value, char oldPath[])
{
  char newPath[300];
  char buffer[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "entityID");
      C2xSetTokenData(packetHandle, "SignalStatusMessage", newPath, value.entityID.stringLength, value.entityID.string);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
      C2xSetTokenInt64(packetHandle, "SignalStatusMessage", newPath, value.stationID);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSignalStatusMessageRegionalExtensionRequestorTypeParams(LONG packetHandle, struct SignalStatusMessageRegionalExtensionRequestorType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  return result;
}

int SetSignalStatusMessageRegionalExtensionRequestorTypeParams(LONG packetHandle, struct SignalStatusMessageRegionalExtensionRequestorType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetSignalStatusMessageRequestorTypeParams(LONG packetHandle, struct SignalStatusMessageRequestorType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "role");
  value.role = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "subrole");
  value.subrole.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.subrole.isValidFlag==1)
  {
    value.subrole.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "request");
  value.request.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.request.isValidFlag==1)
  {
    value.request.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "iso3883");
  value.iso3883.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.iso3883.isValidFlag==1)
  {
    value.iso3883.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hpmsType");
  value.hpmsType.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.hpmsType.isValidFlag==1)
  {
    value.hpmsType.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSignalStatusMessageRegionalExtensionRequestorTypeParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int SetSignalStatusMessageRequestorTypeParams(LONG packetHandle, struct SignalStatusMessageRequestorType value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "role");
  C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.role);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "subrole");
  if(value.subrole.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.subrole.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "request");
  if(value.request.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.request.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "iso3883");
  if(value.iso3883.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.iso3883.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "hpmsType");
  if(value.hpmsType.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.hpmsType.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSignalStatusMessageRegionalExtensionRequestorTypeParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  return result;
}

int GetSignalStatusMessageSignalRequesterInfoParams(LONG packetHandle, struct SignalStatusMessageSignalRequesterInfo value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetSignalStatusMessageVehicleIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "request");
  value.request = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  value.sequenceNumber = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "role");
  value.role.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.role.isValidFlag==1)
  {
    value.role.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "typeData");
  value.typeData.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.typeData.isValidFlag==1)
  {
    GetSignalStatusMessageRequestorTypeParams(packetHandle, value.typeData, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int SetSignalStatusMessageSignalRequesterInfoParams(LONG packetHandle, struct SignalStatusMessageSignalRequesterInfo value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetSignalStatusMessageVehicleIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "request");
  C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.request);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.sequenceNumber);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "role");
  if(value.role.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.role.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "typeData");
  if(value.typeData.isValidFlag==1)
  {
    SetSignalStatusMessageRequestorTypeParams(packetHandle, value.typeData, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  return result;
}

int GetSignalStatusMessageIntersectionAccessPointParams(LONG packetHandle, struct SignalStatusMessageIntersectionAccessPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "SignalStatusMessage", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
      value.lane = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "approach");
      value.approach = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connection");
      value.connection = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSignalStatusMessageIntersectionAccessPointParams(LONG packetHandle, struct SignalStatusMessageIntersectionAccessPoint value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lane");
      C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.lane);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "approach");
      C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.approach);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connection");
      C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.connection);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSignalStatusMessageRegionalExtensionSignalStatusPackageParams(LONG packetHandle, struct SignalStatusMessageRegionalExtensionSignalStatusPackage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  return result;
}

int SetSignalStatusMessageRegionalExtensionSignalStatusPackageParams(LONG packetHandle, struct SignalStatusMessageRegionalExtensionSignalStatusPackage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetSignalStatusMessage_SignalStatusPackage_regionalParams(LONG packetHandle, struct SignalStatusMessage_SignalStatusPackage_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SignalStatusMessage", oldPath);
  if((result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSignalStatusMessageRegionalExtensionSignalStatusPackageParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSignalStatusMessage_SignalStatusPackage_regionalParams(LONG packetHandle, struct SignalStatusMessage_SignalStatusPackage_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SignalStatusMessage", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSignalStatusMessageRegionalExtensionSignalStatusPackageParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int GetSignalStatusMessageSignalStatusPackageParams(LONG packetHandle, struct SignalStatusMessageSignalStatusPackage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "requester");
  value.requester.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.requester.isValidFlag==1)
  {
    GetSignalStatusMessageSignalRequesterInfoParams(packetHandle, value.requester, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "inboundOn");
  GetSignalStatusMessageIntersectionAccessPointParams(packetHandle, value.inboundOn, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "outboundOn");
  value.outboundOn.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.outboundOn.isValidFlag==1)
  {
    GetSignalStatusMessageIntersectionAccessPointParams(packetHandle, value.outboundOn, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minute");
  value.minute.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.minute.isValidFlag==1)
  {
    value.minute.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  value.second.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.second.isValidFlag==1)
  {
    value.second.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "duration");
  value.duration.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.duration.isValidFlag==1)
  {
    value.duration.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
  value.status = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSignalStatusMessage_SignalStatusPackage_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int SetSignalStatusMessageSignalStatusPackageParams(LONG packetHandle, struct SignalStatusMessageSignalStatusPackage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "requester");
  if(value.requester.isValidFlag==1)
  {
    SetSignalStatusMessageSignalRequesterInfoParams(packetHandle, value.requester, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "inboundOn");
  SetSignalStatusMessageIntersectionAccessPointParams(packetHandle, value.inboundOn, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "outboundOn");
  if(value.outboundOn.isValidFlag==1)
  {
    SetSignalStatusMessageIntersectionAccessPointParams(packetHandle, value.outboundOn, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minute");
  if(value.minute.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.minute.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  if(value.second.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.second.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "duration");
  if(value.duration.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.duration.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
  C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.status);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSignalStatusMessage_SignalStatusPackage_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  return result;
}

int GetSignalStatusMessageSignalStatusPackageListParams(LONG packetHandle, struct SignalStatusMessageSignalStatusPackageList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SignalStatusMessage", oldPath);
  if((result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSignalStatusMessageSignalStatusPackageParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSignalStatusMessageSignalStatusPackageListParams(LONG packetHandle, struct SignalStatusMessageSignalStatusPackageList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SignalStatusMessage", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSignalStatusMessageSignalStatusPackageParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int GetSignalStatusMessageRegionalExtensionSignalStatusParams(LONG packetHandle, struct SignalStatusMessageRegionalExtensionSignalStatus value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  return result;
}

int SetSignalStatusMessageRegionalExtensionSignalStatusParams(LONG packetHandle, struct SignalStatusMessageRegionalExtensionSignalStatus value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetSignalStatusMessage_SignalStatus_regionalParams(LONG packetHandle, struct SignalStatusMessage_SignalStatus_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SignalStatusMessage", oldPath);
  if((result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSignalStatusMessageRegionalExtensionSignalStatusParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSignalStatusMessage_SignalStatus_regionalParams(LONG packetHandle, struct SignalStatusMessage_SignalStatus_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SignalStatusMessage", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSignalStatusMessageRegionalExtensionSignalStatusParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int GetSignalStatusMessageSignalStatusParams(LONG packetHandle, struct SignalStatusMessageSignalStatus value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  value.sequenceNumber = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetSignalStatusMessageIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sigStatus");
  GetSignalStatusMessageSignalStatusPackageListParams(packetHandle, value.sigStatus, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSignalStatusMessage_SignalStatus_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int SetSignalStatusMessageSignalStatusParams(LONG packetHandle, struct SignalStatusMessageSignalStatus value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.sequenceNumber);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetSignalStatusMessageIntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sigStatus");
  SetSignalStatusMessageSignalStatusPackageListParams(packetHandle, value.sigStatus, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSignalStatusMessage_SignalStatus_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  return result;
}

int GetSignalStatusMessageSignalStatusListParams(LONG packetHandle, struct SignalStatusMessageSignalStatusList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SignalStatusMessage", oldPath);
  if((result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSignalStatusMessageSignalStatusParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSignalStatusMessageSignalStatusListParams(LONG packetHandle, struct SignalStatusMessageSignalStatusList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SignalStatusMessage", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSignalStatusMessageSignalStatusParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int GetSignalStatusMessageRegionalExtensionSignalStatusMessageParams(LONG packetHandle, struct SignalStatusMessageRegionalExtensionSignalStatusMessage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  return result;
}

int SetSignalStatusMessageRegionalExtensionSignalStatusMessageParams(LONG packetHandle, struct SignalStatusMessageRegionalExtensionSignalStatusMessage value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetSignalStatusMessage_SignalStatusMessage_regionalParams(LONG packetHandle, struct SignalStatusMessage_SignalStatusMessage_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SignalStatusMessage", oldPath);
  if((result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSignalStatusMessageRegionalExtensionSignalStatusMessageParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSignalStatusMessage_SignalStatusMessage_regionalParams(LONG packetHandle, struct SignalStatusMessage_SignalStatusMessage_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SignalStatusMessage", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSignalStatusMessageRegionalExtensionSignalStatusMessageParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int GetSignalStatusMessageSSMParams(LONG packetHandle, struct SignalStatusMessageSSM value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  value.second = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  value.sequenceNumber.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.sequenceNumber.isValidFlag==1)
  {
    value.sequenceNumber.value = C2xGetTokenInt(packetHandle, "SignalStatusMessage", newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
  GetSignalStatusMessageSignalStatusListParams(packetHandle, value.status, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSignalStatusMessage_SignalStatusMessage_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  return result;
}

int SetSignalStatusMessageSSMParams(LONG packetHandle, struct SignalStatusMessageSSM value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.timeStamp.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "second");
  C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.second);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "sequenceNumber");
  if(value.sequenceNumber.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SignalStatusMessage", newPath, value.sequenceNumber.value);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
  SetSignalStatusMessageSignalStatusListParams(packetHandle, value.status, newPath);
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSignalStatusMessage_SignalStatusMessage_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SignalStatusMessage", newPath) )
    {
      C2xRemoveToken(packetHandle, "SignalStatusMessage", newPath);
    }
  }

  return result;
}

int GetSignalStatusMessageMESSAGE_ID_AND_TYPEParams(LONG packetHandle, WORD tableKey, struct SignalStatusMessageMESSAGE_ID_AND_TYPE value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 30:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalStatusMessage");
      GetSignalStatusMessageSSMParams(packetHandle, value.signalStatusMessage, newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSignalStatusMessageMESSAGE_ID_AND_TYPEParams(LONG packetHandle, WORD tableKey, struct SignalStatusMessageMESSAGE_ID_AND_TYPE value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 30:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalStatusMessage");
      SetSignalStatusMessageSSMParams(packetHandle, value.signalStatusMessage, newPath);
      result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int API_GetSignalStatusMessageParams(LONG packetHandle, struct SignalStatusMessage value)
{
  int result;
  result = 0;

  value.messageId = C2xGetTokenInt(packetHandle, "SignalStatusMessage", "messageId");
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  GetSignalStatusMessageMESSAGE_ID_AND_TYPEParams(packetHandle, value.messageId, value.value, "value");
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  return result;
}

int API_SetSignalStatusMessageParams(LONG packetHandle, struct SignalStatusMessage value)
{
  int result;
  result = 0;

  value.messageId = 30;

  SetSignalStatusMessageMESSAGE_ID_AND_TYPEParams(packetHandle, value.messageId, value.value, "value");
  result = CheckLastError("SignalStatusMessage", gkFuncRefGet, result);

  return result;
}

