/*@!Encoding:1252*/
/*
//  (c) Vector Informatik GmbH. All rights reserved.
//
//  This file contains definitions of structs and methods that may be used
//  to set and get the values of an ASN.1 defined packet's payload.
//
//  //This example demonstrates how to set a packet's payload:
//  LONG packetHandle;
//  struct SPAT payload;
//  //you need to set the values of the variable "payload" yourself
//  packetHandle = API_InitSPATPacket();
//  if (packetHandle!=0) {
//    if (API_SetSPATParams(packetHandle, payload)==0) {
//      if (C2xCompletePacket(packetHandle)==0) {
//        C2xOutputPacket(packetHandle);
//      }
//    }
//  }
//                                                                             */
includes
{

}
variables
{
    const int sizeSPATDSRC_MovementState = 20;    // Original size is 255, but compilation time is very high with this value. Recommended val is 20
                                                  // Path in SPAT: .value.signalPhaseAndTimingMessage.intersections.arrayValue[0].states.arrayValue[0]
  
    const int sizeSPATDSRC_IntersectionState = 4; // Original size is 32, but compilation time is very high with this value. Recommended val is 4
                                                  // Path in SPAT: .value.signalPhaseAndTimingMessage.intersections.arrayValue[0]
  
    struct SPATITS_Container_ItsPduHeader {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE protocolVersion;  // INTEGER, 0..255;
        BYTE messageID;  // INTEGER, 0..255, denm(1), cam(2), poi(3), spat(4), map(5), ivi(6), ev_rsr(7), tistpgtransaction(8), srem(9), ssem(10), evcsn(11), saem(12), rtcmem(13);
        DWORD stationID;  // INTEGER, 0..4294967295;
    };
    
    struct SPATDSRC_DescriptiveName {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[64];
        INT  stringLength;
    };
    
    struct SPATDSRC_IntersectionReferenceID {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN region;  // INTEGER, OPTIONAL, 0..65535;
        WORD id;  // INTEGER, 0..65535;
    };
    
    struct SPATDSRC_IntersectionStatusObject {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        CHAR string[17];
        INT  stringLength;
    };
    
    struct SPATDSRC_EnabledLaneList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        BYTE arrayValue[16];  // INTEGER, 0..255;
    };
    
    struct SPATDSRC_TimeChangeDetails {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_WORD_ASN startTime;  // INTEGER, OPTIONAL, 0..36001;
        WORD minEndTime;  // INTEGER, 0..36001;
        struct OPT_WORD_ASN maxEndTime;  // INTEGER, OPTIONAL, 0..36001;
        struct OPT_WORD_ASN likelyTime;  // INTEGER, OPTIONAL, 0..36001;
        struct OPT_BYTE_ASN confidence;  // INTEGER, OPTIONAL, 0..15;
        struct OPT_WORD_ASN nextTime;  // INTEGER, OPTIONAL, 0..36001;
    };
    
    struct SPATReg_Empty {
    };
    
    struct SPATDSRC_RegionalExtensionEmpty {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATReg_Empty regExtValue;  // TABLE;
    };
    
    struct SPATDSRC_AdvisorySpeed_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_RegionalExtensionEmpty arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATDSRC_AdvisorySpeed {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT type;  // ENUMERATED, none(0), greenwave(1), ecoDrive(2), transit(3);
        struct OPT_WORD_ASN speed;  // INTEGER, OPTIONAL, 0..500;
        struct OPT_BYTE_ASN confidence;  // INTEGER, OPTIONAL, 1..127, equalOrWithinOneCentimeterPerSec(1), equalOrWithinOneMeterPerSec(100), outOfRange(126), unavailable(127);
        struct OPT_WORD_ASN distance;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_BYTE_ASN class;  // INTEGER, OPTIONAL, 0..255;
        struct SPATDSRC_AdvisorySpeed_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATDSRC_AdvisorySpeedList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_AdvisorySpeed arrayValue[16];  // SEQUENCE;
    };
    
    struct SPATDSRC_MovementEvent_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_RegionalExtensionEmpty arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATDSRC_MovementEvent {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT eventState;  // ENUMERATED, unavailable(0), dark(1), stop_Then_Proceed(2), stop_And_Remain(3), pre_Movement(4), permissive_Movement_Allowed(5), protected_Movement_Allowed(6), permissive_clearance(7), protected_clearance(8), caution_Conflicting_Traffic(9);
        struct SPATDSRC_TimeChangeDetails timing;  // SEQUENCE, OPTIONAL;
        struct SPATDSRC_AdvisorySpeedList speeds;  // SEQUENCEOF, OPTIONAL;
        struct SPATDSRC_MovementEvent_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATDSRC_MovementEventList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_MovementEvent arrayValue[16];  // SEQUENCE;
    };
    
    struct SPATDSRC_Node_XY_20b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -512..511;
        INT y;  // INTEGER, -512..511;
    };
    
    struct SPATDSRC_Node_XY_22b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -1024..1023;
        INT y;  // INTEGER, -1024..1023;
    };
    
    struct SPATDSRC_Node_XY_24b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -2048..2047;
        INT y;  // INTEGER, -2048..2047;
    };
    
    struct SPATDSRC_Node_XY_26b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -4096..4095;
        INT y;  // INTEGER, -4096..4095;
    };
    
    struct SPATDSRC_Node_XY_28b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -8192..8191;
        INT y;  // INTEGER, -8192..8191;
    };
    
    struct SPATDSRC_Node_XY_32b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT x;  // INTEGER, -32768..32767;
        INT y;  // INTEGER, -32768..32767;
    };
    
    struct SPATDSRC_Node_LLmD_64b {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        LONG lon;  // INTEGER, -1800000000..1800000001, unavailable(1800000001);
        LONG lat;  // INTEGER, -900000000..900000001, unavailable(900000001);
    };
    
    struct SPATDSRC_NodeOffsetPointXY {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT choice;
        struct SPATDSRC_Node_XY_20b node_XY1;  // SEQUENCE;
        struct SPATDSRC_Node_XY_22b node_XY2;  // SEQUENCE;
        struct SPATDSRC_Node_XY_24b node_XY3;  // SEQUENCE;
        struct SPATDSRC_Node_XY_26b node_XY4;  // SEQUENCE;
        struct SPATDSRC_Node_XY_28b node_XY5;  // SEQUENCE;
        struct SPATDSRC_Node_XY_32b node_XY6;  // SEQUENCE;
        struct SPATDSRC_Node_LLmD_64b node_LatLon;  // SEQUENCE;
        struct SPATDSRC_RegionalExtensionEmpty regional;  // SEQUENCE;
    };
    
    struct SPATAddGrpC_ItsStationPosition {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        DWORD stationID;  // INTEGER, 0..4294967295;
        struct OPT_BYTE_ASN laneID;  // INTEGER, OPTIONAL, 0..255;
        struct SPATDSRC_NodeOffsetPointXY nodeXY;  // CHOICE, OPTIONAL;
        struct OPT_WORD_ASN timeReference;  // INTEGER, OPTIONAL, 0..65535, oneMilliSec(1);
    };
    
    struct SPATAddGrpC_ItsStationPositionList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATAddGrpC_ItsStationPosition arrayValue[5];  // SEQUENCE;
    };
    
    struct SPATAddGrpC_ConnectionManeuverAssist_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPATAddGrpC_ItsStationPositionList itsStationPositions;  // SEQUENCEOF, OPTIONAL;
        struct SPATDSRC_NodeOffsetPointXY rsuGNSSOffset;  // CHOICE, OPTIONAL;
    };
    
    struct SPATReg_ConnectionManeuverAssist {
        struct SPATAddGrpC_ConnectionManeuverAssist_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct SPATDSRC_RegionalExtensionConnectionManeuverAssist {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATReg_ConnectionManeuverAssist regExtValue;  // TABLE;
    };
    
    struct SPATDSRC_ConnectionManeuverAssist_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_RegionalExtensionConnectionManeuverAssist arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATDSRC_ConnectionManeuverAssist {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE connectionID;  // INTEGER, 0..255;
        struct OPT_WORD_ASN queueLength;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_WORD_ASN availableStorageLength;  // INTEGER, OPTIONAL, 0..10000;
        struct OPT_BOOL_ASN waitOnStop;  // BOOLEAN, OPTIONAL;
        struct OPT_BOOL_ASN pedBicycleDetect;  // BOOLEAN, OPTIONAL;
        struct SPATDSRC_ConnectionManeuverAssist_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATDSRC_ManeuverAssistList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_ConnectionManeuverAssist arrayValue[16];  // SEQUENCE;
    };
    
    struct SPATDSRC_MovementState_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_RegionalExtensionEmpty arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATDSRC_MovementState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPATDSRC_DescriptiveName movementName;  // IA5STRING, OPTIONAL;
        BYTE signalGroup;  // INTEGER, 0..255;
        struct SPATDSRC_MovementEventList state_time_speed;  // SEQUENCEOF;
        struct SPATDSRC_ManeuverAssistList maneuverAssistList;  // SEQUENCEOF, OPTIONAL;
        struct SPATDSRC_MovementState_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATDSRC_MovementList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_MovementState arrayValue[sizeSPATDSRC_MovementState];  // SEQUENCE;
    };
    
    struct SPATAddGrpC_PrioritizationResponse {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        DWORD stationID;  // INTEGER, 0..4294967295;
        INT priorState;  // ENUMERATED, unknown(0), requested(1), processing(2), watchOtherTraffic(3), granted(4), rejected(5), maxPresence(6), reserviceLocked(7);
        BYTE signalGroup;  // INTEGER, 0..255;
    };
    
    struct SPATAddGrpC_PrioritizationResponseList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATAddGrpC_PrioritizationResponse arrayValue[10];  // SEQUENCE;
    };
    
    struct SPATAddGrpC_IntersectionState_addGrpC {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPATAddGrpC_PrioritizationResponseList activePrioritizations;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATReg_IntersectionState {
        struct SPATAddGrpC_IntersectionState_addGrpC addGrpC;  // SEQUENCE;
    };
    
    struct SPATDSRC_RegionalExtensionIntersectionState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        BYTE regionId;  // INTEGER, 0..255, noRegion(0), addGrpA(1), addGrpB(2), addGrpC(3);
        struct SPATReg_IntersectionState regExtValue;  // TABLE;
    };
    
    struct SPATDSRC_IntersectionState_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_RegionalExtensionIntersectionState arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATDSRC_IntersectionState {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPATDSRC_DescriptiveName name;  // IA5STRING, OPTIONAL;
        struct SPATDSRC_IntersectionReferenceID id;  // SEQUENCE;
        BYTE revision;  // INTEGER, 0..127;
        struct SPATDSRC_IntersectionStatusObject status;  // BITSTRING;
        struct OPT_DWORD_ASN moy;  // INTEGER, OPTIONAL, 0..527040;
        struct OPT_WORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..65535;
        struct SPATDSRC_EnabledLaneList enabledLanes;  // SEQUENCEOF, OPTIONAL;
        struct SPATDSRC_MovementList states;  // SEQUENCEOF;
        struct SPATDSRC_ManeuverAssistList maneuverAssistList;  // SEQUENCEOF, OPTIONAL;
        struct SPATDSRC_IntersectionState_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPATDSRC_IntersectionStateList {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_IntersectionState arrayValue[sizeSPATDSRC_IntersectionState];  // SEQUENCE;
    };
    
    struct SPATDSRC_SPAT_regional {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        INT length;
        struct SPATDSRC_RegionalExtensionEmpty arrayValue[4];  // SEQUENCE;
    };
    
    struct SPATDSRC_SPAT {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct OPT_DWORD_ASN timeStamp;  // INTEGER, OPTIONAL, 0..527040;
        struct SPATDSRC_DescriptiveName name;  // IA5STRING, OPTIONAL;
        struct SPATDSRC_IntersectionStateList intersections;  // SEQUENCEOF;
        struct SPATDSRC_SPAT_regional regional;  // SEQUENCEOF, OPTIONAL;
    };
    
    struct SPAT {
        INT isValidFlag;   // necessary if this struct is used as an optional field of a SEQUENCE
        struct SPATITS_Container_ItsPduHeader header;  // SEQUENCE;
        struct SPATDSRC_SPAT spat;  // SEQUENCE;
    };
    
}

/*
// init function to create a simple packet handle
*/ 
LONG API_InitSPATPacket()
{
  return C2xInitPacket("SPAT"); 
}

/*
// init function to create a simple packet handle and
// initialize the struct with valid data
*/ 
LONG API_InitSPATPacket(struct SPAT msgStruct)
{
  long pktHandle;

  pktHandle = API_InitSPATPacket();

  if (pktHandle != 0)
  {
    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      API_GetSPATParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}

/*
// init function to create a packet with security layer and
// initialize the struct with valid data
*/ 
LONG API_InitSPATPacket(struct SPAT msgStruct, char packetTypeDesignator[], char certificateName[])
{
  long pktHandle, certHdl;

  // initialize the packet
  pktHandle = C2xInitPacket("SPAT", packetTypeDesignator);

  if (pktHandle != 0)
  {
    certHdl = C2xSecCertificateGetHandle(certificateName);  // get the certificate handle for the cert with name "certificateName"
    if (certHdl != 0) 
    {
      C2xSecPacketSetSignerHandle(pktHandle, certHdl); // set the certHdl to the packet
    }

    // create valid message and application data
    if (C2xCompletePacket(pktHandle) == 0) 
    {
      // copy application data to the application structure
      API_GetSPATParams(pktHandle, msgStruct);
    }
  }
  return pktHandle;
}
    

int GetSPATITS_Container_ItsPduHeaderParams(LONG packetHandle, struct SPATITS_Container_ItsPduHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "protocolVersion");
  value.protocolVersion = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "messageID");
  value.messageID = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  value.stationID = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATITS_Container_ItsPduHeaderParams(LONG packetHandle, struct SPATITS_Container_ItsPduHeader value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "protocolVersion");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.protocolVersion);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "messageID");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.messageID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.stationID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_IntersectionReferenceIDParams(LONG packetHandle, struct SPATDSRC_IntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  value.region.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.region.isValidFlag==1)
  {
    value.region.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  value.id = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_IntersectionReferenceIDParams(LONG packetHandle, struct SPATDSRC_IntersectionReferenceID value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "region");
  if(value.region.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.region.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.id);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_EnabledLaneListParams(LONG packetHandle, struct SPATDSRC_EnabledLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      value.arrayValue[i] = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_EnabledLaneListParams(LONG packetHandle, struct SPATDSRC_EnabledLaneList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.arrayValue[i]);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_TimeChangeDetailsParams(LONG packetHandle, struct SPATDSRC_TimeChangeDetails value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startTime");
  value.startTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.startTime.isValidFlag==1)
  {
    value.startTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minEndTime");
  value.minEndTime = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maxEndTime");
  value.maxEndTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.maxEndTime.isValidFlag==1)
  {
    value.maxEndTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "likelyTime");
  value.likelyTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.likelyTime.isValidFlag==1)
  {
    value.likelyTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.confidence.isValidFlag==1)
  {
    value.confidence.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nextTime");
  value.nextTime.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.nextTime.isValidFlag==1)
  {
    value.nextTime.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATDSRC_TimeChangeDetailsParams(LONG packetHandle, struct SPATDSRC_TimeChangeDetails value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "startTime");
  if(value.startTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.startTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "minEndTime");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.minEndTime);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maxEndTime");
  if(value.maxEndTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.maxEndTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "likelyTime");
  if(value.likelyTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.likelyTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  if(value.confidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.confidence.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nextTime");
  if(value.nextTime.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.nextTime.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATDSRC_RegionalExtensionEmptyParams(LONG packetHandle, struct SPATDSRC_RegionalExtensionEmpty value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_RegionalExtensionEmptyParams(LONG packetHandle, struct SPATDSRC_RegionalExtensionEmpty value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  return result;
}

int GetSPATDSRC_AdvisorySpeed_regionalParams(LONG packetHandle, struct SPATDSRC_AdvisorySpeed_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_AdvisorySpeed_regionalParams(LONG packetHandle, struct SPATDSRC_AdvisorySpeed_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_AdvisorySpeedParams(LONG packetHandle, struct SPATDSRC_AdvisorySpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  value.type = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  value.speed.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.speed.isValidFlag==1)
  {
    value.speed.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  value.confidence.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.confidence.isValidFlag==1)
  {
    value.confidence.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "distance");
  value.distance.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.distance.isValidFlag==1)
  {
    value.distance.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "class");
  value.class.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.class.isValidFlag==1)
  {
    value.class.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPATDSRC_AdvisorySpeed_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATDSRC_AdvisorySpeedParams(LONG packetHandle, struct SPATDSRC_AdvisorySpeed value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "type");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.type);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speed");
  if(value.speed.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.speed.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "confidence");
  if(value.confidence.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.confidence.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "distance");
  if(value.distance.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.distance.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "class");
  if(value.class.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.class.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPATDSRC_AdvisorySpeed_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATDSRC_AdvisorySpeedListParams(LONG packetHandle, struct SPATDSRC_AdvisorySpeedList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_AdvisorySpeedParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_AdvisorySpeedListParams(LONG packetHandle, struct SPATDSRC_AdvisorySpeedList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_AdvisorySpeedParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_MovementEvent_regionalParams(LONG packetHandle, struct SPATDSRC_MovementEvent_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_MovementEvent_regionalParams(LONG packetHandle, struct SPATDSRC_MovementEvent_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_MovementEventParams(LONG packetHandle, struct SPATDSRC_MovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventState");
  value.eventState = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timing");
  value.timing.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.timing.isValidFlag==1)
  {
    GetSPATDSRC_TimeChangeDetailsParams(packetHandle, value.timing, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speeds");
  value.speeds.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.speeds.isValidFlag==1)
  {
    GetSPATDSRC_AdvisorySpeedListParams(packetHandle, value.speeds, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPATDSRC_MovementEvent_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATDSRC_MovementEventParams(LONG packetHandle, struct SPATDSRC_MovementEvent value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "eventState");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.eventState);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timing");
  if(value.timing.isValidFlag==1)
  {
    SetSPATDSRC_TimeChangeDetailsParams(packetHandle, value.timing, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "speeds");
  if(value.speeds.isValidFlag==1)
  {
    SetSPATDSRC_AdvisorySpeedListParams(packetHandle, value.speeds, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPATDSRC_MovementEvent_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATDSRC_MovementEventListParams(LONG packetHandle, struct SPATDSRC_MovementEventList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_MovementEventParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_MovementEventListParams(LONG packetHandle, struct SPATDSRC_MovementEventList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_MovementEventParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_Node_XY_20bParams(LONG packetHandle, struct SPATDSRC_Node_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_Node_XY_20bParams(LONG packetHandle, struct SPATDSRC_Node_XY_20b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_Node_XY_22bParams(LONG packetHandle, struct SPATDSRC_Node_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_Node_XY_22bParams(LONG packetHandle, struct SPATDSRC_Node_XY_22b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_Node_XY_24bParams(LONG packetHandle, struct SPATDSRC_Node_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_Node_XY_24bParams(LONG packetHandle, struct SPATDSRC_Node_XY_24b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_Node_XY_26bParams(LONG packetHandle, struct SPATDSRC_Node_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_Node_XY_26bParams(LONG packetHandle, struct SPATDSRC_Node_XY_26b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_Node_XY_28bParams(LONG packetHandle, struct SPATDSRC_Node_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_Node_XY_28bParams(LONG packetHandle, struct SPATDSRC_Node_XY_28b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_Node_XY_32bParams(LONG packetHandle, struct SPATDSRC_Node_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  value.x = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  value.y = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_Node_XY_32bParams(LONG packetHandle, struct SPATDSRC_Node_XY_32b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "x");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.x);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "y");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.y);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_Node_LLmD_64bParams(LONG packetHandle, struct SPATDSRC_Node_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  value.lon = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  value.lat = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_Node_LLmD_64bParams(LONG packetHandle, struct SPATDSRC_Node_LLmD_64b value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lon");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.lon);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "lat");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.lat);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_NodeOffsetPointXYParams(LONG packetHandle, struct SPATDSRC_NodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  value.choice = C2xGetTokenInt(packetHandle, "SPAT", oldPath);

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      GetSPATDSRC_Node_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      GetSPATDSRC_Node_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      GetSPATDSRC_Node_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      GetSPATDSRC_Node_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      GetSPATDSRC_Node_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      GetSPATDSRC_Node_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      GetSPATDSRC_Node_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      GetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.regional, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATDSRC_NodeOffsetPointXYParams(LONG packetHandle, struct SPATDSRC_NodeOffsetPointXY value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(value.choice)
  {
    case 0:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY1");
      SetSPATDSRC_Node_XY_20bParams(packetHandle, value.node_XY1, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 1:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY2");
      SetSPATDSRC_Node_XY_22bParams(packetHandle, value.node_XY2, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 2:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY3");
      SetSPATDSRC_Node_XY_24bParams(packetHandle, value.node_XY3, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY4");
      SetSPATDSRC_Node_XY_26bParams(packetHandle, value.node_XY4, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 4:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY5");
      SetSPATDSRC_Node_XY_28bParams(packetHandle, value.node_XY5, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 5:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_XY6");
      SetSPATDSRC_Node_XY_32bParams(packetHandle, value.node_XY6, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 6:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "node_LatLon");
      SetSPATDSRC_Node_LLmD_64bParams(packetHandle, value.node_LatLon, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
    case 7:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
      SetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.regional, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPATAddGrpC_ItsStationPositionParams(LONG packetHandle, struct SPATAddGrpC_ItsStationPosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  value.stationID = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  value.laneID.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.laneID.isValidFlag==1)
  {
    value.laneID.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodeXY");
  value.nodeXY.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.nodeXY.isValidFlag==1)
  {
    GetSPATDSRC_NodeOffsetPointXYParams(packetHandle, value.nodeXY, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeReference");
  value.timeReference.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.timeReference.isValidFlag==1)
  {
    value.timeReference.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATAddGrpC_ItsStationPositionParams(LONG packetHandle, struct SPATAddGrpC_ItsStationPosition value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.stationID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "laneID");
  if(value.laneID.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.laneID.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "nodeXY");
  if(value.nodeXY.isValidFlag==1)
  {
    SetSPATDSRC_NodeOffsetPointXYParams(packetHandle, value.nodeXY, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeReference");
  if(value.timeReference.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.timeReference.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATAddGrpC_ItsStationPositionListParams(LONG packetHandle, struct SPATAddGrpC_ItsStationPositionList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATAddGrpC_ItsStationPositionParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATAddGrpC_ItsStationPositionListParams(LONG packetHandle, struct SPATAddGrpC_ItsStationPositionList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATAddGrpC_ItsStationPositionParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATAddGrpC_ConnectionManeuverAssist_addGrpCParams(LONG packetHandle, struct SPATAddGrpC_ConnectionManeuverAssist_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "itsStationPositions");
  value.itsStationPositions.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.itsStationPositions.isValidFlag==1)
  {
    GetSPATAddGrpC_ItsStationPositionListParams(packetHandle, value.itsStationPositions, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rsuGNSSOffset");
  value.rsuGNSSOffset.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.rsuGNSSOffset.isValidFlag==1)
  {
    GetSPATDSRC_NodeOffsetPointXYParams(packetHandle, value.rsuGNSSOffset, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATAddGrpC_ConnectionManeuverAssist_addGrpCParams(LONG packetHandle, struct SPATAddGrpC_ConnectionManeuverAssist_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "itsStationPositions");
  if(value.itsStationPositions.isValidFlag==1)
  {
    SetSPATAddGrpC_ItsStationPositionListParams(packetHandle, value.itsStationPositions, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "rsuGNSSOffset");
  if(value.rsuGNSSOffset.isValidFlag==1)
  {
    SetSPATDSRC_NodeOffsetPointXYParams(packetHandle, value.rsuGNSSOffset, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATReg_ConnectionManeuverAssistParams(LONG packetHandle, WORD tableKey, struct SPATReg_ConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetSPATAddGrpC_ConnectionManeuverAssist_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATReg_ConnectionManeuverAssistParams(LONG packetHandle, WORD tableKey, struct SPATReg_ConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetSPATAddGrpC_ConnectionManeuverAssist_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPATDSRC_RegionalExtensionConnectionManeuverAssistParams(LONG packetHandle, struct SPATDSRC_RegionalExtensionConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetSPATReg_ConnectionManeuverAssistParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_RegionalExtensionConnectionManeuverAssistParams(LONG packetHandle, struct SPATDSRC_RegionalExtensionConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetSPATReg_ConnectionManeuverAssistParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_ConnectionManeuverAssist_regionalParams(LONG packetHandle, struct SPATDSRC_ConnectionManeuverAssist_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_RegionalExtensionConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_ConnectionManeuverAssist_regionalParams(LONG packetHandle, struct SPATDSRC_ConnectionManeuverAssist_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_RegionalExtensionConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_ConnectionManeuverAssistParams(LONG packetHandle, struct SPATDSRC_ConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  value.connectionID = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "queueLength");
  value.queueLength.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.queueLength.isValidFlag==1)
  {
    value.queueLength.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "availableStorageLength");
  value.availableStorageLength.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.availableStorageLength.isValidFlag==1)
  {
    value.availableStorageLength.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "waitOnStop");
  value.waitOnStop.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.waitOnStop.isValidFlag==1)
  {
    value.waitOnStop.value = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pedBicycleDetect");
  value.pedBicycleDetect.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.pedBicycleDetect.isValidFlag==1)
  {
    value.pedBicycleDetect.value = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPATDSRC_ConnectionManeuverAssist_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATDSRC_ConnectionManeuverAssistParams(LONG packetHandle, struct SPATDSRC_ConnectionManeuverAssist value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "connectionID");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.connectionID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "queueLength");
  if(value.queueLength.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.queueLength.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "availableStorageLength");
  if(value.availableStorageLength.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.availableStorageLength.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "waitOnStop");
  if(value.waitOnStop.isValidFlag==1)
  {
    C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.waitOnStop.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "pedBicycleDetect");
  if(value.pedBicycleDetect.isValidFlag==1)
  {
    C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.pedBicycleDetect.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPATDSRC_ConnectionManeuverAssist_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATDSRC_ManeuverAssistListParams(LONG packetHandle, struct SPATDSRC_ManeuverAssistList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_ConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_ManeuverAssistListParams(LONG packetHandle, struct SPATDSRC_ManeuverAssistList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_ConnectionManeuverAssistParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_MovementState_regionalParams(LONG packetHandle, struct SPATDSRC_MovementState_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_MovementState_regionalParams(LONG packetHandle, struct SPATDSRC_MovementState_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_MovementStateParams(LONG packetHandle, struct SPATDSRC_MovementState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "movementName");
  value.movementName.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.movementName.isValidFlag==1)
  {
    value.movementName.stringLength = C2xGetTokenData(packetHandle, "SPAT", newPath, elcount(value.movementName.string), value.movementName.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  value.signalGroup = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "state_time_speed");
  GetSPATDSRC_MovementEventListParams(packetHandle, value.state_time_speed, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  value.maneuverAssistList.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.maneuverAssistList.isValidFlag==1)
  {
    GetSPATDSRC_ManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPATDSRC_MovementState_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATDSRC_MovementStateParams(LONG packetHandle, struct SPATDSRC_MovementState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "movementName");
  if(value.movementName.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "SPAT", newPath, value.movementName.stringLength, value.movementName.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.signalGroup);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "state_time_speed");
  SetSPATDSRC_MovementEventListParams(packetHandle, value.state_time_speed, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  if(value.maneuverAssistList.isValidFlag==1)
  {
    SetSPATDSRC_ManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPATDSRC_MovementState_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATDSRC_MovementListParams(LONG packetHandle, struct SPATDSRC_MovementList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_MovementStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_MovementListParams(LONG packetHandle, struct SPATDSRC_MovementList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_MovementStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATAddGrpC_PrioritizationResponseParams(LONG packetHandle, struct SPATAddGrpC_PrioritizationResponse value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  value.stationID = C2xGetTokenInt64(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "priorState");
  value.priorState = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  value.signalGroup = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATAddGrpC_PrioritizationResponseParams(LONG packetHandle, struct SPATAddGrpC_PrioritizationResponse value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "stationID");
  C2xSetTokenInt64(packetHandle, "SPAT", newPath, value.stationID);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "priorState");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.priorState);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "signalGroup");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.signalGroup);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATAddGrpC_PrioritizationResponseListParams(LONG packetHandle, struct SPATAddGrpC_PrioritizationResponseList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATAddGrpC_PrioritizationResponseParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATAddGrpC_PrioritizationResponseListParams(LONG packetHandle, struct SPATAddGrpC_PrioritizationResponseList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATAddGrpC_PrioritizationResponseParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATAddGrpC_IntersectionState_addGrpCParams(LONG packetHandle, struct SPATAddGrpC_IntersectionState_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "activePrioritizations");
  value.activePrioritizations.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.activePrioritizations.isValidFlag==1)
  {
    GetSPATAddGrpC_PrioritizationResponseListParams(packetHandle, value.activePrioritizations, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATAddGrpC_IntersectionState_addGrpCParams(LONG packetHandle, struct SPATAddGrpC_IntersectionState_addGrpC value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "activePrioritizations");
  if(value.activePrioritizations.isValidFlag==1)
  {
    SetSPATAddGrpC_PrioritizationResponseListParams(packetHandle, value.activePrioritizations, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATReg_IntersectionStateParams(LONG packetHandle, WORD tableKey, struct SPATReg_IntersectionState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      GetSPATAddGrpC_IntersectionState_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int SetSPATReg_IntersectionStateParams(LONG packetHandle, WORD tableKey, struct SPATReg_IntersectionState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  switch(tableKey)
  {
    case 3:
    {
      snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "addGrpC");
      SetSPATAddGrpC_IntersectionState_addGrpCParams(packetHandle, value.addGrpC, newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
    break;
  }
  return result;
}

int GetSPATDSRC_RegionalExtensionIntersectionStateParams(LONG packetHandle, struct SPATDSRC_RegionalExtensionIntersectionState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regionId");
  value.regionId = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  GetSPATReg_IntersectionStateParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int SetSPATDSRC_RegionalExtensionIntersectionStateParams(LONG packetHandle, struct SPATDSRC_RegionalExtensionIntersectionState value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;


  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regExtValue");
  SetSPATReg_IntersectionStateParams(packetHandle, value.regionId, value.regExtValue, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int GetSPATDSRC_IntersectionState_regionalParams(LONG packetHandle, struct SPATDSRC_IntersectionState_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_RegionalExtensionIntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_IntersectionState_regionalParams(LONG packetHandle, struct SPATDSRC_IntersectionState_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_RegionalExtensionIntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_IntersectionStateParams(LONG packetHandle, struct SPATDSRC_IntersectionState value, char oldPath[])
{
  char newPath[300]; 
  int j; 
  int k;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "SPAT", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  GetSPATDSRC_IntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  value.revision = C2xGetTokenInt(packetHandle, "SPAT", newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
  value.status.isValidFlag = 1;
  value.status.stringLength = C2xGetTokenLengthBit(packetHandle, "SPAT", newPath);
  if ((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    if(value.status.stringLength > 0)
    {
      for(j=0; j<value.status.stringLength; j++)
      {
        if(C2xGetTokenBitOfBitString(packetHandle, "SPAT", newPath, j) == 0)
        {
          value.status.string[j] = '0';
        }
        else if(C2xGetTokenBitOfBitString(packetHandle, "SPAT", newPath, j) == 1)
        {
          value.status.string[j] = '1';
        }

        if(value.status.stringLength == 1)
        {
          value.status.string[1] = '0';
        }
        result = CheckLastError("SPAT", gkFuncRefGet, result);
      }
    }
    else
    {
      for(k = value.status.stringLength+1; k > -1; k--)
      {
        if(value.status.string[k] == '1')
        {
          value.status.string[k] = '0';
        }
      }
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "moy");
  value.moy.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.moy.isValidFlag==1)
  {
    value.moy.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabledLanes");
  value.enabledLanes.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.enabledLanes.isValidFlag==1)
  {
    GetSPATDSRC_EnabledLaneListParams(packetHandle, value.enabledLanes, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "states");
  GetSPATDSRC_MovementListParams(packetHandle, value.states, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  value.maneuverAssistList.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.maneuverAssistList.isValidFlag==1)
  {
    GetSPATDSRC_ManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPATDSRC_IntersectionState_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATDSRC_IntersectionStateParams(LONG packetHandle, struct SPATDSRC_IntersectionState value, char oldPath[])
{
  char newPath[300]; 
  int j;
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "SPAT", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "id");
  SetSPATDSRC_IntersectionReferenceIDParams(packetHandle, value.id, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "revision");
  C2xSetTokenInt(packetHandle, "SPAT", newPath, value.revision);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "status");
    for(j=0; j<value.status.stringLength; j++)
    {
      if(value.status.string[j] == '0')
      {
        C2xSetTokenBitOfBitString(packetHandle, "SPAT", newPath, j, 0);
      }
      else
      {
        C2xSetTokenBitOfBitString(packetHandle, "SPAT", newPath, j, 1);
      }
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "moy");
  if(value.moy.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.moy.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.timeStamp.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "enabledLanes");
  if(value.enabledLanes.isValidFlag==1)
  {
    SetSPATDSRC_EnabledLaneListParams(packetHandle, value.enabledLanes, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "states");
  SetSPATDSRC_MovementListParams(packetHandle, value.states, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "maneuverAssistList");
  if(value.maneuverAssistList.isValidFlag==1)
  {
    SetSPATDSRC_ManeuverAssistListParams(packetHandle, value.maneuverAssistList, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPATDSRC_IntersectionState_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int GetSPATDSRC_IntersectionStateListParams(LONG packetHandle, struct SPATDSRC_IntersectionStateList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_IntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_IntersectionStateListParams(LONG packetHandle, struct SPATDSRC_IntersectionStateList value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_IntersectionStateParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_SPAT_regionalParams(LONG packetHandle, struct SPATDSRC_SPAT_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  value.length = C2xGetTokenInt(packetHandle, "SPAT", oldPath);
  if((result = CheckLastError("SPAT", gkFuncRefGet, result))==0)
  {
    for(i=0; i<value.length; i++)
    {
      snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
      GetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
      result = CheckLastError("SPAT", gkFuncRefGet, result);
    }
  }
  return result;
}

int SetSPATDSRC_SPAT_regionalParams(LONG packetHandle, struct SPATDSRC_SPAT_regional value, char oldPath[])
{
  char newPath[300]; 
  int i;
  int result;

  result = 0;

  C2xRemoveToken(packetHandle, "SPAT", oldPath);
  for(i=0; i<value.length; i++)
  {
    snprintf(newPath, elcount(newPath), "%s[%d]", oldPath, i);
    SetSPATDSRC_RegionalExtensionEmptyParams(packetHandle, value.arrayValue[i], newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int GetSPATDSRC_SPATParams(LONG packetHandle, struct SPATDSRC_SPAT value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  value.timeStamp.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.timeStamp.isValidFlag==1)
  {
    value.timeStamp.value = C2xGetTokenInt(packetHandle, "SPAT", newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  value.name.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.name.isValidFlag==1)
  {
    value.name.stringLength = C2xGetTokenData(packetHandle, "SPAT", newPath, elcount(value.name.string), value.name.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  GetSPATDSRC_IntersectionStateListParams(packetHandle, value.intersections, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  value.regional.isValidFlag = C2xIsTokenAvailable(packetHandle, "SPAT", newPath);
  if(value.regional.isValidFlag==1)
  {
    GetSPATDSRC_SPAT_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  return result;
}

int SetSPATDSRC_SPATParams(LONG packetHandle, struct SPATDSRC_SPAT value, char oldPath[])
{
  char newPath[300];
  int result;

  result = 0;

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "timeStamp");
  if(value.timeStamp.isValidFlag==1)
  {
    C2xSetTokenInt(packetHandle, "SPAT", newPath, value.timeStamp.value);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "name");
  if(value.name.isValidFlag==1)
  {
    C2xSetTokenData(packetHandle, "SPAT", newPath, value.name.stringLength, value.name.string);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "intersections");
  SetSPATDSRC_IntersectionStateListParams(packetHandle, value.intersections, newPath);
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  snprintf(newPath, elcount(newPath), "%s.%s", oldPath, "regional");
  if(value.regional.isValidFlag==1)
  {
    SetSPATDSRC_SPAT_regionalParams(packetHandle, value.regional, newPath);
    result = CheckLastError("SPAT", gkFuncRefGet, result);
  }
  else
  {
    if( C2xIsTokenAvailable(packetHandle, "SPAT", newPath) )
    {
      C2xRemoveToken(packetHandle, "SPAT", newPath);
    }
  }

  return result;
}

int API_GetSPATParams(LONG packetHandle, struct SPAT value)
{
  int result;
  result = 0;

  value.header.isValidFlag = 1;
  GetSPATITS_Container_ItsPduHeaderParams(packetHandle, value.header, "header");
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  value.spat.isValidFlag = 1;
  GetSPATDSRC_SPATParams(packetHandle, value.spat, "spat");
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

int API_SetSPATParams(LONG packetHandle, struct SPAT value)
{
  int result;
  result = 0;

  SetSPATITS_Container_ItsPduHeaderParams(packetHandle, value.header, "header");
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  SetSPATDSRC_SPATParams(packetHandle, value.spat, "spat");
  result = CheckLastError("SPAT", gkFuncRefGet, result);

  return result;
}

